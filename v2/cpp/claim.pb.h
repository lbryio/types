// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: claim.proto

#ifndef PROTOBUF_claim_2eproto__INCLUDED
#define PROTOBUF_claim_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_claim_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsClaimImpl();
void InitDefaultsClaim();
void InitDefaultsChannelImpl();
void InitDefaultsChannel();
void InitDefaultsStreamImpl();
void InitDefaultsStream();
void InitDefaultsFeeImpl();
void InitDefaultsFee();
void InitDefaultsFileImpl();
void InitDefaultsFile();
void InitDefaultsImageImpl();
void InitDefaultsImage();
void InitDefaultsVideoImpl();
void InitDefaultsVideo();
void InitDefaultsAudioImpl();
void InitDefaultsAudio();
void InitDefaultsLanguageImpl();
void InitDefaultsLanguage();
void InitDefaultsLocationImpl();
void InitDefaultsLocation();
inline void InitDefaults() {
  InitDefaultsClaim();
  InitDefaultsChannel();
  InitDefaultsStream();
  InitDefaultsFee();
  InitDefaultsFile();
  InitDefaultsImage();
  InitDefaultsVideo();
  InitDefaultsAudio();
  InitDefaultsLanguage();
  InitDefaultsLocation();
}
}  // namespace protobuf_claim_2eproto
namespace pb {
class Audio;
class AudioDefaultTypeInternal;
extern AudioDefaultTypeInternal _Audio_default_instance_;
class Channel;
class ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class Claim;
class ClaimDefaultTypeInternal;
extern ClaimDefaultTypeInternal _Claim_default_instance_;
class Fee;
class FeeDefaultTypeInternal;
extern FeeDefaultTypeInternal _Fee_default_instance_;
class File;
class FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class Image;
class ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Language;
class LanguageDefaultTypeInternal;
extern LanguageDefaultTypeInternal _Language_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Stream;
class StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Video;
class VideoDefaultTypeInternal;
extern VideoDefaultTypeInternal _Video_default_instance_;
}  // namespace pb
namespace pb {

enum Fee_Currency {
  Fee_Currency_UNKNOWN_CURRENCY = 0,
  Fee_Currency_LBC = 1,
  Fee_Currency_BTC = 2,
  Fee_Currency_USD = 3,
  Fee_Currency_Fee_Currency_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Fee_Currency_Fee_Currency_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Fee_Currency_IsValid(int value);
const Fee_Currency Fee_Currency_Currency_MIN = Fee_Currency_UNKNOWN_CURRENCY;
const Fee_Currency Fee_Currency_Currency_MAX = Fee_Currency_USD;
const int Fee_Currency_Currency_ARRAYSIZE = Fee_Currency_Currency_MAX + 1;

const ::google::protobuf::EnumDescriptor* Fee_Currency_descriptor();
inline const ::std::string& Fee_Currency_Name(Fee_Currency value) {
  return ::google::protobuf::internal::NameOfEnum(
    Fee_Currency_descriptor(), value);
}
inline bool Fee_Currency_Parse(
    const ::std::string& name, Fee_Currency* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Fee_Currency>(
    Fee_Currency_descriptor(), name, value);
}
enum Language_Language {
  Language_Language_UNKNOWN_LANGUAGE = 0,
  Language_Language_en = 1,
  Language_Language_aa = 2,
  Language_Language_ab = 3,
  Language_Language_ae = 4,
  Language_Language_af = 5,
  Language_Language_ak = 6,
  Language_Language_am = 7,
  Language_Language_an = 8,
  Language_Language_ar = 9,
  Language_Language_as = 10,
  Language_Language_av = 11,
  Language_Language_ay = 12,
  Language_Language_az = 13,
  Language_Language_ba = 14,
  Language_Language_be = 15,
  Language_Language_bg = 16,
  Language_Language_bh = 17,
  Language_Language_bi = 18,
  Language_Language_bm = 19,
  Language_Language_bn = 20,
  Language_Language_bo = 21,
  Language_Language_br = 22,
  Language_Language_bs = 23,
  Language_Language_ca = 24,
  Language_Language_ce = 25,
  Language_Language_ch = 26,
  Language_Language_co = 27,
  Language_Language_cr = 28,
  Language_Language_cs = 29,
  Language_Language_cu = 30,
  Language_Language_cv = 31,
  Language_Language_cy = 32,
  Language_Language_da = 33,
  Language_Language_de = 34,
  Language_Language_dv = 35,
  Language_Language_dz = 36,
  Language_Language_ee = 37,
  Language_Language_el = 38,
  Language_Language_eo = 39,
  Language_Language_es = 40,
  Language_Language_et = 41,
  Language_Language_eu = 42,
  Language_Language_fa = 43,
  Language_Language_ff = 44,
  Language_Language_fi = 45,
  Language_Language_fj = 46,
  Language_Language_fo = 47,
  Language_Language_fr = 48,
  Language_Language_fy = 49,
  Language_Language_ga = 50,
  Language_Language_gd = 51,
  Language_Language_gl = 52,
  Language_Language_gn = 53,
  Language_Language_gu = 54,
  Language_Language_gv = 55,
  Language_Language_ha = 56,
  Language_Language_he = 57,
  Language_Language_hi = 58,
  Language_Language_ho = 59,
  Language_Language_hr = 60,
  Language_Language_ht = 61,
  Language_Language_hu = 62,
  Language_Language_hy = 63,
  Language_Language_hz = 64,
  Language_Language_ia = 65,
  Language_Language_id = 66,
  Language_Language_ie = 67,
  Language_Language_ig = 68,
  Language_Language_ii = 69,
  Language_Language_ik = 70,
  Language_Language_io = 71,
  Language_Language_is = 72,
  Language_Language_it = 73,
  Language_Language_iu = 74,
  Language_Language_ja = 75,
  Language_Language_jv = 76,
  Language_Language_ka = 77,
  Language_Language_kg = 78,
  Language_Language_ki = 79,
  Language_Language_kj = 80,
  Language_Language_kk = 81,
  Language_Language_kl = 82,
  Language_Language_km = 83,
  Language_Language_kn = 84,
  Language_Language_ko = 85,
  Language_Language_kr = 86,
  Language_Language_ks = 87,
  Language_Language_ku = 88,
  Language_Language_kv = 89,
  Language_Language_kw = 90,
  Language_Language_ky = 91,
  Language_Language_la = 92,
  Language_Language_lb = 93,
  Language_Language_lg = 94,
  Language_Language_li = 95,
  Language_Language_ln = 96,
  Language_Language_lo = 97,
  Language_Language_lt = 98,
  Language_Language_lu = 99,
  Language_Language_lv = 100,
  Language_Language_mg = 101,
  Language_Language_mh = 102,
  Language_Language_mi = 103,
  Language_Language_mk = 104,
  Language_Language_ml = 105,
  Language_Language_mn = 106,
  Language_Language_mr = 107,
  Language_Language_ms = 108,
  Language_Language_mt = 109,
  Language_Language_my = 110,
  Language_Language_na = 111,
  Language_Language_nb = 112,
  Language_Language_nd = 113,
  Language_Language_ne = 114,
  Language_Language_ng = 115,
  Language_Language_nl = 116,
  Language_Language_nn = 117,
  Language_Language_no = 118,
  Language_Language_nr = 119,
  Language_Language_nv = 120,
  Language_Language_ny = 121,
  Language_Language_oc = 122,
  Language_Language_oj = 123,
  Language_Language_om = 124,
  Language_Language_or_ = 125,
  Language_Language_os = 126,
  Language_Language_pa = 127,
  Language_Language_pi = 128,
  Language_Language_pl = 129,
  Language_Language_ps = 130,
  Language_Language_pt = 131,
  Language_Language_qu = 132,
  Language_Language_rm = 133,
  Language_Language_rn = 134,
  Language_Language_ro = 135,
  Language_Language_ru = 136,
  Language_Language_rw = 137,
  Language_Language_sa = 138,
  Language_Language_sc = 139,
  Language_Language_sd = 140,
  Language_Language_se = 141,
  Language_Language_sg = 142,
  Language_Language_si = 143,
  Language_Language_sk = 144,
  Language_Language_sl = 145,
  Language_Language_sm = 146,
  Language_Language_sn = 147,
  Language_Language_so = 148,
  Language_Language_sq = 149,
  Language_Language_sr = 150,
  Language_Language_ss = 151,
  Language_Language_st = 152,
  Language_Language_su = 153,
  Language_Language_sv = 154,
  Language_Language_sw = 155,
  Language_Language_ta = 156,
  Language_Language_te = 157,
  Language_Language_tg = 158,
  Language_Language_th = 159,
  Language_Language_ti = 160,
  Language_Language_tk = 161,
  Language_Language_tl = 162,
  Language_Language_tn = 163,
  Language_Language_to = 164,
  Language_Language_tr = 165,
  Language_Language_ts = 166,
  Language_Language_tt = 167,
  Language_Language_tw = 168,
  Language_Language_ty = 169,
  Language_Language_ug = 170,
  Language_Language_uk = 171,
  Language_Language_ur = 172,
  Language_Language_uz = 173,
  Language_Language_ve = 174,
  Language_Language_vi = 175,
  Language_Language_vo = 176,
  Language_Language_wa = 177,
  Language_Language_wo = 178,
  Language_Language_xh = 179,
  Language_Language_yi = 180,
  Language_Language_yo = 181,
  Language_Language_za = 182,
  Language_Language_zh = 183,
  Language_Language_zu = 184,
  Language_Language_Language_Language_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Language_Language_Language_Language_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Language_Language_IsValid(int value);
const Language_Language Language_Language_Language_MIN = Language_Language_UNKNOWN_LANGUAGE;
const Language_Language Language_Language_Language_MAX = Language_Language_zu;
const int Language_Language_Language_ARRAYSIZE = Language_Language_Language_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_Language_descriptor();
inline const ::std::string& Language_Language_Name(Language_Language value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_Language_descriptor(), value);
}
inline bool Language_Language_Parse(
    const ::std::string& name, Language_Language* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language_Language>(
    Language_Language_descriptor(), name, value);
}
enum Language_Script {
  Language_Script_UNKNOWN_SCRIPT = 0,
  Language_Script_Adlm = 1,
  Language_Script_Afak = 2,
  Language_Script_Aghb = 3,
  Language_Script_Ahom = 4,
  Language_Script_Arab = 5,
  Language_Script_Aran = 6,
  Language_Script_Armi = 7,
  Language_Script_Armn = 8,
  Language_Script_Avst = 9,
  Language_Script_Bali = 10,
  Language_Script_Bamu = 11,
  Language_Script_Bass = 12,
  Language_Script_Batk = 13,
  Language_Script_Beng = 14,
  Language_Script_Bhks = 15,
  Language_Script_Blis = 16,
  Language_Script_Bopo = 17,
  Language_Script_Brah = 18,
  Language_Script_Brai = 19,
  Language_Script_Bugi = 20,
  Language_Script_Buhd = 21,
  Language_Script_Cakm = 22,
  Language_Script_Cans = 23,
  Language_Script_Cari = 24,
  Language_Script_Cham = 25,
  Language_Script_Cher = 26,
  Language_Script_Cirt = 27,
  Language_Script_Copt = 28,
  Language_Script_Cpmn = 29,
  Language_Script_Cprt = 30,
  Language_Script_Cyrl = 31,
  Language_Script_Cyrs = 32,
  Language_Script_Deva = 33,
  Language_Script_Dogr = 34,
  Language_Script_Dsrt = 35,
  Language_Script_Dupl = 36,
  Language_Script_Egyd = 37,
  Language_Script_Egyh = 38,
  Language_Script_Egyp = 39,
  Language_Script_Elba = 40,
  Language_Script_Elym = 41,
  Language_Script_Ethi = 42,
  Language_Script_Geok = 43,
  Language_Script_Geor = 44,
  Language_Script_Glag = 45,
  Language_Script_Gong = 46,
  Language_Script_Gonm = 47,
  Language_Script_Goth = 48,
  Language_Script_Gran = 49,
  Language_Script_Grek = 50,
  Language_Script_Gujr = 51,
  Language_Script_Guru = 52,
  Language_Script_Hanb = 53,
  Language_Script_Hang = 54,
  Language_Script_Hani = 55,
  Language_Script_Hano = 56,
  Language_Script_Hans = 57,
  Language_Script_Hant = 58,
  Language_Script_Hatr = 59,
  Language_Script_Hebr = 60,
  Language_Script_Hira = 61,
  Language_Script_Hluw = 62,
  Language_Script_Hmng = 63,
  Language_Script_Hmnp = 64,
  Language_Script_Hrkt = 65,
  Language_Script_Hung = 66,
  Language_Script_Inds = 67,
  Language_Script_Ital = 68,
  Language_Script_Jamo = 69,
  Language_Script_Java = 70,
  Language_Script_Jpan = 71,
  Language_Script_Jurc = 72,
  Language_Script_Kali = 73,
  Language_Script_Kana = 74,
  Language_Script_Khar = 75,
  Language_Script_Khmr = 76,
  Language_Script_Khoj = 77,
  Language_Script_Kitl = 78,
  Language_Script_Kits = 79,
  Language_Script_Knda = 80,
  Language_Script_Kore = 81,
  Language_Script_Kpel = 82,
  Language_Script_Kthi = 83,
  Language_Script_Lana = 84,
  Language_Script_Laoo = 85,
  Language_Script_Latf = 86,
  Language_Script_Latg = 87,
  Language_Script_Latn = 88,
  Language_Script_Leke = 89,
  Language_Script_Lepc = 90,
  Language_Script_Limb = 91,
  Language_Script_Lina = 92,
  Language_Script_Linb = 93,
  Language_Script_Lisu = 94,
  Language_Script_Loma = 95,
  Language_Script_Lyci = 96,
  Language_Script_Lydi = 97,
  Language_Script_Mahj = 98,
  Language_Script_Maka = 99,
  Language_Script_Mand = 100,
  Language_Script_Mani = 101,
  Language_Script_Marc = 102,
  Language_Script_Maya = 103,
  Language_Script_Medf = 104,
  Language_Script_Mend = 105,
  Language_Script_Merc = 106,
  Language_Script_Mero = 107,
  Language_Script_Mlym = 108,
  Language_Script_Modi = 109,
  Language_Script_Mong = 110,
  Language_Script_Moon = 111,
  Language_Script_Mroo = 112,
  Language_Script_Mtei = 113,
  Language_Script_Mult = 114,
  Language_Script_Mymr = 115,
  Language_Script_Nand = 116,
  Language_Script_Narb = 117,
  Language_Script_Nbat = 118,
  Language_Script_Newa = 119,
  Language_Script_Nkdb = 120,
  Language_Script_Nkgb = 121,
  Language_Script_Nkoo = 122,
  Language_Script_Nshu = 123,
  Language_Script_Ogam = 124,
  Language_Script_Olck = 125,
  Language_Script_Orkh = 126,
  Language_Script_Orya = 127,
  Language_Script_Osge = 128,
  Language_Script_Osma = 129,
  Language_Script_Palm = 130,
  Language_Script_Pauc = 131,
  Language_Script_Perm = 132,
  Language_Script_Phag = 133,
  Language_Script_Phli = 134,
  Language_Script_Phlp = 135,
  Language_Script_Phlv = 136,
  Language_Script_Phnx = 137,
  Language_Script_Plrd = 138,
  Language_Script_Piqd = 139,
  Language_Script_Prti = 140,
  Language_Script_Qaaa = 141,
  Language_Script_Qabx = 142,
  Language_Script_Rjng = 143,
  Language_Script_Rohg = 144,
  Language_Script_Roro = 145,
  Language_Script_Runr = 146,
  Language_Script_Samr = 147,
  Language_Script_Sara = 148,
  Language_Script_Sarb = 149,
  Language_Script_Saur = 150,
  Language_Script_Sgnw = 151,
  Language_Script_Shaw = 152,
  Language_Script_Shrd = 153,
  Language_Script_Shui = 154,
  Language_Script_Sidd = 155,
  Language_Script_Sind = 156,
  Language_Script_Sinh = 157,
  Language_Script_Sogd = 158,
  Language_Script_Sogo = 159,
  Language_Script_Sora = 160,
  Language_Script_Soyo = 161,
  Language_Script_Sund = 162,
  Language_Script_Sylo = 163,
  Language_Script_Syrc = 164,
  Language_Script_Syre = 165,
  Language_Script_Syrj = 166,
  Language_Script_Syrn = 167,
  Language_Script_Tagb = 168,
  Language_Script_Takr = 169,
  Language_Script_Tale = 170,
  Language_Script_Talu = 171,
  Language_Script_Taml = 172,
  Language_Script_Tang = 173,
  Language_Script_Tavt = 174,
  Language_Script_Telu = 175,
  Language_Script_Teng = 176,
  Language_Script_Tfng = 177,
  Language_Script_Tglg = 178,
  Language_Script_Thaa = 179,
  Language_Script_Thai = 180,
  Language_Script_Tibt = 181,
  Language_Script_Tirh = 182,
  Language_Script_Ugar = 183,
  Language_Script_Vaii = 184,
  Language_Script_Visp = 185,
  Language_Script_Wara = 186,
  Language_Script_Wcho = 187,
  Language_Script_Wole = 188,
  Language_Script_Xpeo = 189,
  Language_Script_Xsux = 190,
  Language_Script_Yiii = 191,
  Language_Script_Zanb = 192,
  Language_Script_Zinh = 193,
  Language_Script_Zmth = 194,
  Language_Script_Zsye = 195,
  Language_Script_Zsym = 196,
  Language_Script_Zxxx = 197,
  Language_Script_Zyyy = 198,
  Language_Script_Zzzz = 199,
  Language_Script_Language_Script_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Language_Script_Language_Script_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Language_Script_IsValid(int value);
const Language_Script Language_Script_Script_MIN = Language_Script_UNKNOWN_SCRIPT;
const Language_Script Language_Script_Script_MAX = Language_Script_Zzzz;
const int Language_Script_Script_ARRAYSIZE = Language_Script_Script_MAX + 1;

const ::google::protobuf::EnumDescriptor* Language_Script_descriptor();
inline const ::std::string& Language_Script_Name(Language_Script value) {
  return ::google::protobuf::internal::NameOfEnum(
    Language_Script_descriptor(), value);
}
inline bool Language_Script_Parse(
    const ::std::string& name, Language_Script* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Language_Script>(
    Language_Script_descriptor(), name, value);
}
enum Location_Country {
  Location_Country_UNKNOWN_COUNTRY = 0,
  Location_Country_AF = 1,
  Location_Country_AX = 2,
  Location_Country_AL = 3,
  Location_Country_DZ = 4,
  Location_Country_AS = 5,
  Location_Country_AD = 6,
  Location_Country_AO = 7,
  Location_Country_AI = 8,
  Location_Country_AQ = 9,
  Location_Country_AG = 10,
  Location_Country_AR = 11,
  Location_Country_AM = 12,
  Location_Country_AW = 13,
  Location_Country_AU = 14,
  Location_Country_AT = 15,
  Location_Country_AZ = 16,
  Location_Country_BS = 17,
  Location_Country_BH = 18,
  Location_Country_BD = 19,
  Location_Country_BB = 20,
  Location_Country_BY = 21,
  Location_Country_BE = 22,
  Location_Country_BZ = 23,
  Location_Country_BJ = 24,
  Location_Country_BM = 25,
  Location_Country_BT = 26,
  Location_Country_BO = 27,
  Location_Country_BQ = 28,
  Location_Country_BA = 29,
  Location_Country_BW = 30,
  Location_Country_BV = 31,
  Location_Country_BR = 32,
  Location_Country_IO = 33,
  Location_Country_BN = 34,
  Location_Country_BG = 35,
  Location_Country_BF = 36,
  Location_Country_BI = 37,
  Location_Country_KH = 38,
  Location_Country_CM = 39,
  Location_Country_CA = 40,
  Location_Country_CV = 41,
  Location_Country_KY = 42,
  Location_Country_CF = 43,
  Location_Country_TD = 44,
  Location_Country_CL = 45,
  Location_Country_CN = 46,
  Location_Country_CX = 47,
  Location_Country_CC = 48,
  Location_Country_CO = 49,
  Location_Country_KM = 50,
  Location_Country_CG = 51,
  Location_Country_CD = 52,
  Location_Country_CK = 53,
  Location_Country_CR = 54,
  Location_Country_CI = 55,
  Location_Country_HR = 56,
  Location_Country_CU = 57,
  Location_Country_CW = 58,
  Location_Country_CY = 59,
  Location_Country_CZ = 60,
  Location_Country_DK = 61,
  Location_Country_DJ = 62,
  Location_Country_DM = 63,
  Location_Country_DO = 64,
  Location_Country_EC = 65,
  Location_Country_EG = 66,
  Location_Country_SV = 67,
  Location_Country_GQ = 68,
  Location_Country_ER = 69,
  Location_Country_EE = 70,
  Location_Country_ET = 71,
  Location_Country_FK = 72,
  Location_Country_FO = 73,
  Location_Country_FJ = 74,
  Location_Country_FI = 75,
  Location_Country_FR = 76,
  Location_Country_GF = 77,
  Location_Country_PF = 78,
  Location_Country_TF = 79,
  Location_Country_GA = 80,
  Location_Country_GM = 81,
  Location_Country_GE = 82,
  Location_Country_DE = 83,
  Location_Country_GH = 84,
  Location_Country_GI = 85,
  Location_Country_GR = 86,
  Location_Country_GL = 87,
  Location_Country_GD = 88,
  Location_Country_GP = 89,
  Location_Country_GU = 90,
  Location_Country_GT = 91,
  Location_Country_GG = 92,
  Location_Country_GN = 93,
  Location_Country_GW = 94,
  Location_Country_GY = 95,
  Location_Country_HT = 96,
  Location_Country_HM = 97,
  Location_Country_VA = 98,
  Location_Country_HN = 99,
  Location_Country_HK = 100,
  Location_Country_HU = 101,
  Location_Country_IS = 102,
  Location_Country_IN = 103,
  Location_Country_ID = 104,
  Location_Country_IR = 105,
  Location_Country_IQ = 106,
  Location_Country_IE = 107,
  Location_Country_IM = 108,
  Location_Country_IL = 109,
  Location_Country_IT = 110,
  Location_Country_JM = 111,
  Location_Country_JP = 112,
  Location_Country_JE = 113,
  Location_Country_JO = 114,
  Location_Country_KZ = 115,
  Location_Country_KE = 116,
  Location_Country_KI = 117,
  Location_Country_KP = 118,
  Location_Country_KR = 119,
  Location_Country_KW = 120,
  Location_Country_KG = 121,
  Location_Country_LA = 122,
  Location_Country_LV = 123,
  Location_Country_LB = 124,
  Location_Country_LS = 125,
  Location_Country_LR = 126,
  Location_Country_LY = 127,
  Location_Country_LI = 128,
  Location_Country_LT = 129,
  Location_Country_LU = 130,
  Location_Country_MO = 131,
  Location_Country_MK = 132,
  Location_Country_MG = 133,
  Location_Country_MW = 134,
  Location_Country_MY = 135,
  Location_Country_MV = 136,
  Location_Country_ML = 137,
  Location_Country_MT = 138,
  Location_Country_MH = 139,
  Location_Country_MQ = 140,
  Location_Country_MR = 141,
  Location_Country_MU = 142,
  Location_Country_YT = 143,
  Location_Country_MX = 144,
  Location_Country_FM = 145,
  Location_Country_MD = 146,
  Location_Country_MC = 147,
  Location_Country_MN = 148,
  Location_Country_ME = 149,
  Location_Country_MS = 150,
  Location_Country_MA = 151,
  Location_Country_MZ = 152,
  Location_Country_MM = 153,
  Location_Country_NA = 154,
  Location_Country_NR = 155,
  Location_Country_NP = 156,
  Location_Country_NL = 157,
  Location_Country_NC = 158,
  Location_Country_NZ = 159,
  Location_Country_NI = 160,
  Location_Country_NE = 161,
  Location_Country_NG = 162,
  Location_Country_NU = 163,
  Location_Country_NF = 164,
  Location_Country_MP = 165,
  Location_Country_NO = 166,
  Location_Country_OM = 167,
  Location_Country_PK = 168,
  Location_Country_PW = 169,
  Location_Country_PS = 170,
  Location_Country_PA = 171,
  Location_Country_PG = 172,
  Location_Country_PY = 173,
  Location_Country_PE = 174,
  Location_Country_PH = 175,
  Location_Country_PN = 176,
  Location_Country_PL = 177,
  Location_Country_PT = 178,
  Location_Country_PR = 179,
  Location_Country_QA = 180,
  Location_Country_RE = 181,
  Location_Country_RO = 182,
  Location_Country_RU = 183,
  Location_Country_RW = 184,
  Location_Country_BL = 185,
  Location_Country_SH = 186,
  Location_Country_KN = 187,
  Location_Country_LC = 188,
  Location_Country_MF = 189,
  Location_Country_PM = 190,
  Location_Country_VC = 191,
  Location_Country_WS = 192,
  Location_Country_SM = 193,
  Location_Country_ST = 194,
  Location_Country_SA = 195,
  Location_Country_SN = 196,
  Location_Country_RS = 197,
  Location_Country_SC = 198,
  Location_Country_SL = 199,
  Location_Country_SG = 200,
  Location_Country_SX = 201,
  Location_Country_SK = 202,
  Location_Country_SI = 203,
  Location_Country_SB = 204,
  Location_Country_SO = 205,
  Location_Country_ZA = 206,
  Location_Country_GS = 207,
  Location_Country_SS = 208,
  Location_Country_ES = 209,
  Location_Country_LK = 210,
  Location_Country_SD = 211,
  Location_Country_SR = 212,
  Location_Country_SJ = 213,
  Location_Country_SZ = 214,
  Location_Country_SE = 215,
  Location_Country_CH = 216,
  Location_Country_SY = 217,
  Location_Country_TW = 218,
  Location_Country_TJ = 219,
  Location_Country_TZ = 220,
  Location_Country_TH = 221,
  Location_Country_TL = 222,
  Location_Country_TG = 223,
  Location_Country_TK = 224,
  Location_Country_TO = 225,
  Location_Country_TT = 226,
  Location_Country_TN = 227,
  Location_Country_TR = 228,
  Location_Country_TM = 229,
  Location_Country_TC = 230,
  Location_Country_TV = 231,
  Location_Country_UG = 232,
  Location_Country_UA = 233,
  Location_Country_AE = 234,
  Location_Country_GB = 235,
  Location_Country_US = 236,
  Location_Country_UM = 237,
  Location_Country_UY = 238,
  Location_Country_UZ = 239,
  Location_Country_VU = 240,
  Location_Country_VE = 241,
  Location_Country_VN = 242,
  Location_Country_VG = 243,
  Location_Country_VI = 244,
  Location_Country_WF = 245,
  Location_Country_EH = 246,
  Location_Country_YE = 247,
  Location_Country_ZM = 248,
  Location_Country_ZW = 249,
  Location_Country_Location_Country_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Location_Country_Location_Country_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Location_Country_IsValid(int value);
const Location_Country Location_Country_Country_MIN = Location_Country_UNKNOWN_COUNTRY;
const Location_Country Location_Country_Country_MAX = Location_Country_ZW;
const int Location_Country_Country_ARRAYSIZE = Location_Country_Country_MAX + 1;

const ::google::protobuf::EnumDescriptor* Location_Country_descriptor();
inline const ::std::string& Location_Country_Name(Location_Country value) {
  return ::google::protobuf::internal::NameOfEnum(
    Location_Country_descriptor(), value);
}
inline bool Location_Country_Parse(
    const ::std::string& name, Location_Country* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Location_Country>(
    Location_Country_descriptor(), name, value);
}
// ===================================================================

class Claim : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Claim) */ {
 public:
  Claim();
  virtual ~Claim();

  Claim(const Claim& from);

  inline Claim& operator=(const Claim& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Claim(Claim&& from) noexcept
    : Claim() {
    *this = ::std::move(from);
  }

  inline Claim& operator=(Claim&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Claim& default_instance();

  enum TypeCase {
    kStream = 1,
    kChannel = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Claim* internal_default_instance() {
    return reinterpret_cast<const Claim*>(
               &_Claim_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Claim* other);
  friend void swap(Claim& a, Claim& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Claim* New() const PROTOBUF_FINAL { return New(NULL); }

  Claim* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Claim& from);
  void MergeFrom(const Claim& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Claim* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .pb.Stream stream = 1;
  bool has_stream() const;
  void clear_stream();
  static const int kStreamFieldNumber = 1;
  const ::pb::Stream& stream() const;
  ::pb::Stream* release_stream();
  ::pb::Stream* mutable_stream();
  void set_allocated_stream(::pb::Stream* stream);

  // .pb.Channel channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  const ::pb::Channel& channel() const;
  ::pb::Channel* release_channel();
  ::pb::Channel* mutable_channel();
  void set_allocated_channel(::pb::Channel* channel);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:pb.Claim)
 private:
  void set_has_stream();
  void set_has_channel();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::pb::Stream* stream_;
    ::pb::Channel* channel_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsClaimImpl();
};
// -------------------------------------------------------------------

class Channel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Channel) */ {
 public:
  Channel();
  virtual ~Channel();

  Channel(const Channel& from);

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Channel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Channel* other);
  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const PROTOBUF_FINAL { return New(NULL); }

  Channel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Channel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 5;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 5;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated .pb.Language languages = 6;
  int languages_size() const;
  void clear_languages();
  static const int kLanguagesFieldNumber = 6;
  const ::pb::Language& languages(int index) const;
  ::pb::Language* mutable_languages(int index);
  ::pb::Language* add_languages();
  ::google::protobuf::RepeatedPtrField< ::pb::Language >*
      mutable_languages();
  const ::google::protobuf::RepeatedPtrField< ::pb::Language >&
      languages() const;

  // repeated .pb.Location locations = 7;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 7;
  const ::pb::Location& locations(int index) const;
  ::pb::Location* mutable_locations(int index);
  ::pb::Location* add_locations();
  ::google::protobuf::RepeatedPtrField< ::pb::Location >*
      mutable_locations();
  const ::google::protobuf::RepeatedPtrField< ::pb::Location >&
      locations() const;

  // bytes public_key = 1;
  void clear_public_key();
  static const int kPublicKeyFieldNumber = 1;
  const ::std::string& public_key() const;
  void set_public_key(const ::std::string& value);
  #if LANG_CXX11
  void set_public_key(::std::string&& value);
  #endif
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  ::std::string* mutable_public_key();
  ::std::string* release_public_key();
  void set_allocated_public_key(::std::string* public_key);

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string thumbnail_url = 4;
  void clear_thumbnail_url();
  static const int kThumbnailUrlFieldNumber = 4;
  const ::std::string& thumbnail_url() const;
  void set_thumbnail_url(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_url(::std::string&& value);
  #endif
  void set_thumbnail_url(const char* value);
  void set_thumbnail_url(const char* value, size_t size);
  ::std::string* mutable_thumbnail_url();
  ::std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(::std::string* thumbnail_url);

  // string contact_email = 8;
  void clear_contact_email();
  static const int kContactEmailFieldNumber = 8;
  const ::std::string& contact_email() const;
  void set_contact_email(const ::std::string& value);
  #if LANG_CXX11
  void set_contact_email(::std::string&& value);
  #endif
  void set_contact_email(const char* value);
  void set_contact_email(const char* value, size_t size);
  ::std::string* mutable_contact_email();
  ::std::string* release_contact_email();
  void set_allocated_contact_email(::std::string* contact_email);

  // string homepage_url = 9;
  void clear_homepage_url();
  static const int kHomepageUrlFieldNumber = 9;
  const ::std::string& homepage_url() const;
  void set_homepage_url(const ::std::string& value);
  #if LANG_CXX11
  void set_homepage_url(::std::string&& value);
  #endif
  void set_homepage_url(const char* value);
  void set_homepage_url(const char* value, size_t size);
  ::std::string* mutable_homepage_url();
  ::std::string* release_homepage_url();
  void set_allocated_homepage_url(::std::string* homepage_url);

  // string cover_url = 10;
  void clear_cover_url();
  static const int kCoverUrlFieldNumber = 10;
  const ::std::string& cover_url() const;
  void set_cover_url(const ::std::string& value);
  #if LANG_CXX11
  void set_cover_url(::std::string&& value);
  #endif
  void set_cover_url(const char* value);
  void set_cover_url(const char* value, size_t size);
  ::std::string* mutable_cover_url();
  ::std::string* release_cover_url();
  void set_allocated_cover_url(::std::string* cover_url);

  // @@protoc_insertion_point(class_scope:pb.Channel)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::pb::Language > languages_;
  ::google::protobuf::RepeatedPtrField< ::pb::Location > locations_;
  ::google::protobuf::internal::ArenaStringPtr public_key_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_url_;
  ::google::protobuf::internal::ArenaStringPtr contact_email_;
  ::google::protobuf::internal::ArenaStringPtr homepage_url_;
  ::google::protobuf::internal::ArenaStringPtr cover_url_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsChannelImpl();
};
// -------------------------------------------------------------------

class Stream : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Stream) */ {
 public:
  Stream();
  virtual ~Stream();

  Stream(const Stream& from);

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stream& default_instance();

  enum TypeCase {
    kImage = 16,
    kVideo = 17,
    kAudio = 18,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Stream* other);
  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const PROTOBUF_FINAL { return New(NULL); }

  Stream* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Stream* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string tags = 5;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 5;
  const ::std::string& tags(int index) const;
  ::std::string* mutable_tags(int index);
  void set_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_tags(int index, ::std::string&& value);
  #endif
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  ::std::string* add_tags();
  void add_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_tags(::std::string&& value);
  #endif
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tags();

  // repeated .pb.Language languages = 6;
  int languages_size() const;
  void clear_languages();
  static const int kLanguagesFieldNumber = 6;
  const ::pb::Language& languages(int index) const;
  ::pb::Language* mutable_languages(int index);
  ::pb::Language* add_languages();
  ::google::protobuf::RepeatedPtrField< ::pb::Language >*
      mutable_languages();
  const ::google::protobuf::RepeatedPtrField< ::pb::Language >&
      languages() const;

  // repeated .pb.Location locations = 7;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 7;
  const ::pb::Location& locations(int index) const;
  ::pb::Location* mutable_locations(int index);
  ::pb::Location* add_locations();
  ::google::protobuf::RepeatedPtrField< ::pb::Location >*
      mutable_locations();
  const ::google::protobuf::RepeatedPtrField< ::pb::Location >&
      locations() const;

  // bytes sd_hash = 1;
  void clear_sd_hash();
  static const int kSdHashFieldNumber = 1;
  const ::std::string& sd_hash() const;
  void set_sd_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_sd_hash(::std::string&& value);
  #endif
  void set_sd_hash(const char* value);
  void set_sd_hash(const void* value, size_t size);
  ::std::string* mutable_sd_hash();
  ::std::string* release_sd_hash();
  void set_allocated_sd_hash(::std::string* sd_hash);

  // string title = 2;
  void clear_title();
  static const int kTitleFieldNumber = 2;
  const ::std::string& title() const;
  void set_title(const ::std::string& value);
  #if LANG_CXX11
  void set_title(::std::string&& value);
  #endif
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  ::std::string* mutable_title();
  ::std::string* release_title();
  void set_allocated_title(::std::string* title);

  // string description = 3;
  void clear_description();
  static const int kDescriptionFieldNumber = 3;
  const ::std::string& description() const;
  void set_description(const ::std::string& value);
  #if LANG_CXX11
  void set_description(::std::string&& value);
  #endif
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  ::std::string* mutable_description();
  ::std::string* release_description();
  void set_allocated_description(::std::string* description);

  // string thumbnail_url = 4;
  void clear_thumbnail_url();
  static const int kThumbnailUrlFieldNumber = 4;
  const ::std::string& thumbnail_url() const;
  void set_thumbnail_url(const ::std::string& value);
  #if LANG_CXX11
  void set_thumbnail_url(::std::string&& value);
  #endif
  void set_thumbnail_url(const char* value);
  void set_thumbnail_url(const char* value, size_t size);
  ::std::string* mutable_thumbnail_url();
  ::std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(::std::string* thumbnail_url);

  // string author = 8;
  void clear_author();
  static const int kAuthorFieldNumber = 8;
  const ::std::string& author() const;
  void set_author(const ::std::string& value);
  #if LANG_CXX11
  void set_author(::std::string&& value);
  #endif
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  ::std::string* mutable_author();
  ::std::string* release_author();
  void set_allocated_author(::std::string* author);

  // string license = 9;
  void clear_license();
  static const int kLicenseFieldNumber = 9;
  const ::std::string& license() const;
  void set_license(const ::std::string& value);
  #if LANG_CXX11
  void set_license(::std::string&& value);
  #endif
  void set_license(const char* value);
  void set_license(const char* value, size_t size);
  ::std::string* mutable_license();
  ::std::string* release_license();
  void set_allocated_license(::std::string* license);

  // string license_url = 10;
  void clear_license_url();
  static const int kLicenseUrlFieldNumber = 10;
  const ::std::string& license_url() const;
  void set_license_url(const ::std::string& value);
  #if LANG_CXX11
  void set_license_url(::std::string&& value);
  #endif
  void set_license_url(const char* value);
  void set_license_url(const char* value, size_t size);
  ::std::string* mutable_license_url();
  ::std::string* release_license_url();
  void set_allocated_license_url(::std::string* license_url);

  // string media_type = 13;
  void clear_media_type();
  static const int kMediaTypeFieldNumber = 13;
  const ::std::string& media_type() const;
  void set_media_type(const ::std::string& value);
  #if LANG_CXX11
  void set_media_type(::std::string&& value);
  #endif
  void set_media_type(const char* value);
  void set_media_type(const char* value, size_t size);
  ::std::string* mutable_media_type();
  ::std::string* release_media_type();
  void set_allocated_media_type(::std::string* media_type);

  // .pb.File file = 14;
  bool has_file() const;
  void clear_file();
  static const int kFileFieldNumber = 14;
  const ::pb::File& file() const;
  ::pb::File* release_file();
  ::pb::File* mutable_file();
  void set_allocated_file(::pb::File* file);

  // .pb.Fee fee = 15;
  bool has_fee() const;
  void clear_fee();
  static const int kFeeFieldNumber = 15;
  const ::pb::Fee& fee() const;
  ::pb::Fee* release_fee();
  ::pb::Fee* mutable_fee();
  void set_allocated_fee(::pb::Fee* fee);

  // int64 release_time = 11;
  void clear_release_time();
  static const int kReleaseTimeFieldNumber = 11;
  ::google::protobuf::int64 release_time() const;
  void set_release_time(::google::protobuf::int64 value);

  // .pb.Image image = 16;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 16;
  const ::pb::Image& image() const;
  ::pb::Image* release_image();
  ::pb::Image* mutable_image();
  void set_allocated_image(::pb::Image* image);

  // .pb.Video video = 17;
  bool has_video() const;
  void clear_video();
  static const int kVideoFieldNumber = 17;
  const ::pb::Video& video() const;
  ::pb::Video* release_video();
  ::pb::Video* mutable_video();
  void set_allocated_video(::pb::Video* video);

  // .pb.Audio audio = 18;
  bool has_audio() const;
  void clear_audio();
  static const int kAudioFieldNumber = 18;
  const ::pb::Audio& audio() const;
  ::pb::Audio* release_audio();
  ::pb::Audio* mutable_audio();
  void set_allocated_audio(::pb::Audio* audio);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:pb.Stream)
 private:
  void set_has_image();
  void set_has_video();
  void set_has_audio();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tags_;
  ::google::protobuf::RepeatedPtrField< ::pb::Language > languages_;
  ::google::protobuf::RepeatedPtrField< ::pb::Location > locations_;
  ::google::protobuf::internal::ArenaStringPtr sd_hash_;
  ::google::protobuf::internal::ArenaStringPtr title_;
  ::google::protobuf::internal::ArenaStringPtr description_;
  ::google::protobuf::internal::ArenaStringPtr thumbnail_url_;
  ::google::protobuf::internal::ArenaStringPtr author_;
  ::google::protobuf::internal::ArenaStringPtr license_;
  ::google::protobuf::internal::ArenaStringPtr license_url_;
  ::google::protobuf::internal::ArenaStringPtr media_type_;
  ::pb::File* file_;
  ::pb::Fee* fee_;
  ::google::protobuf::int64 release_time_;
  union TypeUnion {
    TypeUnion() {}
    ::pb::Image* image_;
    ::pb::Video* video_;
    ::pb::Audio* audio_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsStreamImpl();
};
// -------------------------------------------------------------------

class Fee : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Fee) */ {
 public:
  Fee();
  virtual ~Fee();

  Fee(const Fee& from);

  inline Fee& operator=(const Fee& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Fee(Fee&& from) noexcept
    : Fee() {
    *this = ::std::move(from);
  }

  inline Fee& operator=(Fee&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Fee& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Fee* internal_default_instance() {
    return reinterpret_cast<const Fee*>(
               &_Fee_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Fee* other);
  friend void swap(Fee& a, Fee& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Fee* New() const PROTOBUF_FINAL { return New(NULL); }

  Fee* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Fee& from);
  void MergeFrom(const Fee& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Fee* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Fee_Currency Currency;
  static const Currency UNKNOWN_CURRENCY =
    Fee_Currency_UNKNOWN_CURRENCY;
  static const Currency LBC =
    Fee_Currency_LBC;
  static const Currency BTC =
    Fee_Currency_BTC;
  static const Currency USD =
    Fee_Currency_USD;
  static inline bool Currency_IsValid(int value) {
    return Fee_Currency_IsValid(value);
  }
  static const Currency Currency_MIN =
    Fee_Currency_Currency_MIN;
  static const Currency Currency_MAX =
    Fee_Currency_Currency_MAX;
  static const int Currency_ARRAYSIZE =
    Fee_Currency_Currency_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Currency_descriptor() {
    return Fee_Currency_descriptor();
  }
  static inline const ::std::string& Currency_Name(Currency value) {
    return Fee_Currency_Name(value);
  }
  static inline bool Currency_Parse(const ::std::string& name,
      Currency* value) {
    return Fee_Currency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bytes address = 2;
  void clear_address();
  static const int kAddressFieldNumber = 2;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // uint64 amount = 3;
  void clear_amount();
  static const int kAmountFieldNumber = 3;
  ::google::protobuf::uint64 amount() const;
  void set_amount(::google::protobuf::uint64 value);

  // .pb.Fee.Currency currency = 1;
  void clear_currency();
  static const int kCurrencyFieldNumber = 1;
  ::pb::Fee_Currency currency() const;
  void set_currency(::pb::Fee_Currency value);

  // @@protoc_insertion_point(class_scope:pb.Fee)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  ::google::protobuf::uint64 amount_;
  int currency_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsFeeImpl();
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.File) */ {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(File&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(File* other);
  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline File* New() const PROTOBUF_FINAL { return New(NULL); }

  File* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(File* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // bytes hash = 3;
  void clear_hash();
  static const int kHashFieldNumber = 3;
  const ::std::string& hash() const;
  void set_hash(const ::std::string& value);
  #if LANG_CXX11
  void set_hash(::std::string&& value);
  #endif
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  ::std::string* mutable_hash();
  ::std::string* release_hash();
  void set_allocated_hash(::std::string* hash);

  // uint64 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::uint64 size() const;
  void set_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pb.File)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr hash_;
  ::google::protobuf::uint64 size_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsFileImpl();
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(Image&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Image& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Image* other);
  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const PROTOBUF_FINAL { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Image)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsImageImpl();
};
// -------------------------------------------------------------------

class Video : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Video) */ {
 public:
  Video();
  virtual ~Video();

  Video(const Video& from);

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Video(Video&& from) noexcept
    : Video() {
    *this = ::std::move(from);
  }

  inline Video& operator=(Video&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Video& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Video* internal_default_instance() {
    return reinterpret_cast<const Video*>(
               &_Video_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(Video* other);
  friend void swap(Video& a, Video& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Video* New() const PROTOBUF_FINAL { return New(NULL); }

  Video* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Video& from);
  void MergeFrom(const Video& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Video* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 width = 1;
  void clear_width();
  static const int kWidthFieldNumber = 1;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // uint32 height = 2;
  void clear_height();
  static const int kHeightFieldNumber = 2;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // uint32 duration = 3;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Video)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsVideoImpl();
};
// -------------------------------------------------------------------

class Audio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Audio) */ {
 public:
  Audio();
  virtual ~Audio();

  Audio(const Audio& from);

  inline Audio& operator=(const Audio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Audio(Audio&& from) noexcept
    : Audio() {
    *this = ::std::move(from);
  }

  inline Audio& operator=(Audio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Audio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Audio* internal_default_instance() {
    return reinterpret_cast<const Audio*>(
               &_Audio_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Audio* other);
  friend void swap(Audio& a, Audio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Audio* New() const PROTOBUF_FINAL { return New(NULL); }

  Audio* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Audio& from);
  void MergeFrom(const Audio& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Audio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 duration = 1;
  void clear_duration();
  static const int kDurationFieldNumber = 1;
  ::google::protobuf::uint32 duration() const;
  void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.Audio)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 duration_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsAudioImpl();
};
// -------------------------------------------------------------------

class Language : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Language) */ {
 public:
  Language();
  virtual ~Language();

  Language(const Language& from);

  inline Language& operator=(const Language& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Language(Language&& from) noexcept
    : Language() {
    *this = ::std::move(from);
  }

  inline Language& operator=(Language&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Language& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Language* internal_default_instance() {
    return reinterpret_cast<const Language*>(
               &_Language_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Language* other);
  friend void swap(Language& a, Language& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Language* New() const PROTOBUF_FINAL { return New(NULL); }

  Language* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Language& from);
  void MergeFrom(const Language& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Language* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Language_Language Language;
  static const Language UNKNOWN_LANGUAGE =
    Language_Language_UNKNOWN_LANGUAGE;
  static const Language en =
    Language_Language_en;
  static const Language aa =
    Language_Language_aa;
  static const Language ab =
    Language_Language_ab;
  static const Language ae =
    Language_Language_ae;
  static const Language af =
    Language_Language_af;
  static const Language ak =
    Language_Language_ak;
  static const Language am =
    Language_Language_am;
  static const Language an =
    Language_Language_an;
  static const Language ar =
    Language_Language_ar;
  static const Language as =
    Language_Language_as;
  static const Language av =
    Language_Language_av;
  static const Language ay =
    Language_Language_ay;
  static const Language az =
    Language_Language_az;
  static const Language ba =
    Language_Language_ba;
  static const Language be =
    Language_Language_be;
  static const Language bg =
    Language_Language_bg;
  static const Language bh =
    Language_Language_bh;
  static const Language bi =
    Language_Language_bi;
  static const Language bm =
    Language_Language_bm;
  static const Language bn =
    Language_Language_bn;
  static const Language bo =
    Language_Language_bo;
  static const Language br =
    Language_Language_br;
  static const Language bs =
    Language_Language_bs;
  static const Language ca =
    Language_Language_ca;
  static const Language ce =
    Language_Language_ce;
  static const Language ch =
    Language_Language_ch;
  static const Language co =
    Language_Language_co;
  static const Language cr =
    Language_Language_cr;
  static const Language cs =
    Language_Language_cs;
  static const Language cu =
    Language_Language_cu;
  static const Language cv =
    Language_Language_cv;
  static const Language cy =
    Language_Language_cy;
  static const Language da =
    Language_Language_da;
  static const Language de =
    Language_Language_de;
  static const Language dv =
    Language_Language_dv;
  static const Language dz =
    Language_Language_dz;
  static const Language ee =
    Language_Language_ee;
  static const Language el =
    Language_Language_el;
  static const Language eo =
    Language_Language_eo;
  static const Language es =
    Language_Language_es;
  static const Language et =
    Language_Language_et;
  static const Language eu =
    Language_Language_eu;
  static const Language fa =
    Language_Language_fa;
  static const Language ff =
    Language_Language_ff;
  static const Language fi =
    Language_Language_fi;
  static const Language fj =
    Language_Language_fj;
  static const Language fo =
    Language_Language_fo;
  static const Language fr =
    Language_Language_fr;
  static const Language fy =
    Language_Language_fy;
  static const Language ga =
    Language_Language_ga;
  static const Language gd =
    Language_Language_gd;
  static const Language gl =
    Language_Language_gl;
  static const Language gn =
    Language_Language_gn;
  static const Language gu =
    Language_Language_gu;
  static const Language gv =
    Language_Language_gv;
  static const Language ha =
    Language_Language_ha;
  static const Language he =
    Language_Language_he;
  static const Language hi =
    Language_Language_hi;
  static const Language ho =
    Language_Language_ho;
  static const Language hr =
    Language_Language_hr;
  static const Language ht =
    Language_Language_ht;
  static const Language hu =
    Language_Language_hu;
  static const Language hy =
    Language_Language_hy;
  static const Language hz =
    Language_Language_hz;
  static const Language ia =
    Language_Language_ia;
  static const Language id =
    Language_Language_id;
  static const Language ie =
    Language_Language_ie;
  static const Language ig =
    Language_Language_ig;
  static const Language ii =
    Language_Language_ii;
  static const Language ik =
    Language_Language_ik;
  static const Language io =
    Language_Language_io;
  static const Language is =
    Language_Language_is;
  static const Language it =
    Language_Language_it;
  static const Language iu =
    Language_Language_iu;
  static const Language ja =
    Language_Language_ja;
  static const Language jv =
    Language_Language_jv;
  static const Language ka =
    Language_Language_ka;
  static const Language kg =
    Language_Language_kg;
  static const Language ki =
    Language_Language_ki;
  static const Language kj =
    Language_Language_kj;
  static const Language kk =
    Language_Language_kk;
  static const Language kl =
    Language_Language_kl;
  static const Language km =
    Language_Language_km;
  static const Language kn =
    Language_Language_kn;
  static const Language ko =
    Language_Language_ko;
  static const Language kr =
    Language_Language_kr;
  static const Language ks =
    Language_Language_ks;
  static const Language ku =
    Language_Language_ku;
  static const Language kv =
    Language_Language_kv;
  static const Language kw =
    Language_Language_kw;
  static const Language ky =
    Language_Language_ky;
  static const Language la =
    Language_Language_la;
  static const Language lb =
    Language_Language_lb;
  static const Language lg =
    Language_Language_lg;
  static const Language li =
    Language_Language_li;
  static const Language ln =
    Language_Language_ln;
  static const Language lo =
    Language_Language_lo;
  static const Language lt =
    Language_Language_lt;
  static const Language lu =
    Language_Language_lu;
  static const Language lv =
    Language_Language_lv;
  static const Language mg =
    Language_Language_mg;
  static const Language mh =
    Language_Language_mh;
  static const Language mi =
    Language_Language_mi;
  static const Language mk =
    Language_Language_mk;
  static const Language ml =
    Language_Language_ml;
  static const Language mn =
    Language_Language_mn;
  static const Language mr =
    Language_Language_mr;
  static const Language ms =
    Language_Language_ms;
  static const Language mt =
    Language_Language_mt;
  static const Language my =
    Language_Language_my;
  static const Language na =
    Language_Language_na;
  static const Language nb =
    Language_Language_nb;
  static const Language nd =
    Language_Language_nd;
  static const Language ne =
    Language_Language_ne;
  static const Language ng =
    Language_Language_ng;
  static const Language nl =
    Language_Language_nl;
  static const Language nn =
    Language_Language_nn;
  static const Language no =
    Language_Language_no;
  static const Language nr =
    Language_Language_nr;
  static const Language nv =
    Language_Language_nv;
  static const Language ny =
    Language_Language_ny;
  static const Language oc =
    Language_Language_oc;
  static const Language oj =
    Language_Language_oj;
  static const Language om =
    Language_Language_om;
  static const Language or_ =
    Language_Language_or_;
  static const Language os =
    Language_Language_os;
  static const Language pa =
    Language_Language_pa;
  static const Language pi =
    Language_Language_pi;
  static const Language pl =
    Language_Language_pl;
  static const Language ps =
    Language_Language_ps;
  static const Language pt =
    Language_Language_pt;
  static const Language qu =
    Language_Language_qu;
  static const Language rm =
    Language_Language_rm;
  static const Language rn =
    Language_Language_rn;
  static const Language ro =
    Language_Language_ro;
  static const Language ru =
    Language_Language_ru;
  static const Language rw =
    Language_Language_rw;
  static const Language sa =
    Language_Language_sa;
  static const Language sc =
    Language_Language_sc;
  static const Language sd =
    Language_Language_sd;
  static const Language se =
    Language_Language_se;
  static const Language sg =
    Language_Language_sg;
  static const Language si =
    Language_Language_si;
  static const Language sk =
    Language_Language_sk;
  static const Language sl =
    Language_Language_sl;
  static const Language sm =
    Language_Language_sm;
  static const Language sn =
    Language_Language_sn;
  static const Language so =
    Language_Language_so;
  static const Language sq =
    Language_Language_sq;
  static const Language sr =
    Language_Language_sr;
  static const Language ss =
    Language_Language_ss;
  static const Language st =
    Language_Language_st;
  static const Language su =
    Language_Language_su;
  static const Language sv =
    Language_Language_sv;
  static const Language sw =
    Language_Language_sw;
  static const Language ta =
    Language_Language_ta;
  static const Language te =
    Language_Language_te;
  static const Language tg =
    Language_Language_tg;
  static const Language th =
    Language_Language_th;
  static const Language ti =
    Language_Language_ti;
  static const Language tk =
    Language_Language_tk;
  static const Language tl =
    Language_Language_tl;
  static const Language tn =
    Language_Language_tn;
  static const Language to =
    Language_Language_to;
  static const Language tr =
    Language_Language_tr;
  static const Language ts =
    Language_Language_ts;
  static const Language tt =
    Language_Language_tt;
  static const Language tw =
    Language_Language_tw;
  static const Language ty =
    Language_Language_ty;
  static const Language ug =
    Language_Language_ug;
  static const Language uk =
    Language_Language_uk;
  static const Language ur =
    Language_Language_ur;
  static const Language uz =
    Language_Language_uz;
  static const Language ve =
    Language_Language_ve;
  static const Language vi =
    Language_Language_vi;
  static const Language vo =
    Language_Language_vo;
  static const Language wa =
    Language_Language_wa;
  static const Language wo =
    Language_Language_wo;
  static const Language xh =
    Language_Language_xh;
  static const Language yi =
    Language_Language_yi;
  static const Language yo =
    Language_Language_yo;
  static const Language za =
    Language_Language_za;
  static const Language zh =
    Language_Language_zh;
  static const Language zu =
    Language_Language_zu;
  static inline bool Language_IsValid(int value) {
    return Language_Language_IsValid(value);
  }
  static const Language Language_MIN =
    Language_Language_Language_MIN;
  static const Language Language_MAX =
    Language_Language_Language_MAX;
  static const int Language_ARRAYSIZE =
    Language_Language_Language_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Language_descriptor() {
    return Language_Language_descriptor();
  }
  static inline const ::std::string& Language_Name(Language value) {
    return Language_Language_Name(value);
  }
  static inline bool Language_Parse(const ::std::string& name,
      Language* value) {
    return Language_Language_Parse(name, value);
  }

  typedef Language_Script Script;
  static const Script UNKNOWN_SCRIPT =
    Language_Script_UNKNOWN_SCRIPT;
  static const Script Adlm =
    Language_Script_Adlm;
  static const Script Afak =
    Language_Script_Afak;
  static const Script Aghb =
    Language_Script_Aghb;
  static const Script Ahom =
    Language_Script_Ahom;
  static const Script Arab =
    Language_Script_Arab;
  static const Script Aran =
    Language_Script_Aran;
  static const Script Armi =
    Language_Script_Armi;
  static const Script Armn =
    Language_Script_Armn;
  static const Script Avst =
    Language_Script_Avst;
  static const Script Bali =
    Language_Script_Bali;
  static const Script Bamu =
    Language_Script_Bamu;
  static const Script Bass =
    Language_Script_Bass;
  static const Script Batk =
    Language_Script_Batk;
  static const Script Beng =
    Language_Script_Beng;
  static const Script Bhks =
    Language_Script_Bhks;
  static const Script Blis =
    Language_Script_Blis;
  static const Script Bopo =
    Language_Script_Bopo;
  static const Script Brah =
    Language_Script_Brah;
  static const Script Brai =
    Language_Script_Brai;
  static const Script Bugi =
    Language_Script_Bugi;
  static const Script Buhd =
    Language_Script_Buhd;
  static const Script Cakm =
    Language_Script_Cakm;
  static const Script Cans =
    Language_Script_Cans;
  static const Script Cari =
    Language_Script_Cari;
  static const Script Cham =
    Language_Script_Cham;
  static const Script Cher =
    Language_Script_Cher;
  static const Script Cirt =
    Language_Script_Cirt;
  static const Script Copt =
    Language_Script_Copt;
  static const Script Cpmn =
    Language_Script_Cpmn;
  static const Script Cprt =
    Language_Script_Cprt;
  static const Script Cyrl =
    Language_Script_Cyrl;
  static const Script Cyrs =
    Language_Script_Cyrs;
  static const Script Deva =
    Language_Script_Deva;
  static const Script Dogr =
    Language_Script_Dogr;
  static const Script Dsrt =
    Language_Script_Dsrt;
  static const Script Dupl =
    Language_Script_Dupl;
  static const Script Egyd =
    Language_Script_Egyd;
  static const Script Egyh =
    Language_Script_Egyh;
  static const Script Egyp =
    Language_Script_Egyp;
  static const Script Elba =
    Language_Script_Elba;
  static const Script Elym =
    Language_Script_Elym;
  static const Script Ethi =
    Language_Script_Ethi;
  static const Script Geok =
    Language_Script_Geok;
  static const Script Geor =
    Language_Script_Geor;
  static const Script Glag =
    Language_Script_Glag;
  static const Script Gong =
    Language_Script_Gong;
  static const Script Gonm =
    Language_Script_Gonm;
  static const Script Goth =
    Language_Script_Goth;
  static const Script Gran =
    Language_Script_Gran;
  static const Script Grek =
    Language_Script_Grek;
  static const Script Gujr =
    Language_Script_Gujr;
  static const Script Guru =
    Language_Script_Guru;
  static const Script Hanb =
    Language_Script_Hanb;
  static const Script Hang =
    Language_Script_Hang;
  static const Script Hani =
    Language_Script_Hani;
  static const Script Hano =
    Language_Script_Hano;
  static const Script Hans =
    Language_Script_Hans;
  static const Script Hant =
    Language_Script_Hant;
  static const Script Hatr =
    Language_Script_Hatr;
  static const Script Hebr =
    Language_Script_Hebr;
  static const Script Hira =
    Language_Script_Hira;
  static const Script Hluw =
    Language_Script_Hluw;
  static const Script Hmng =
    Language_Script_Hmng;
  static const Script Hmnp =
    Language_Script_Hmnp;
  static const Script Hrkt =
    Language_Script_Hrkt;
  static const Script Hung =
    Language_Script_Hung;
  static const Script Inds =
    Language_Script_Inds;
  static const Script Ital =
    Language_Script_Ital;
  static const Script Jamo =
    Language_Script_Jamo;
  static const Script Java =
    Language_Script_Java;
  static const Script Jpan =
    Language_Script_Jpan;
  static const Script Jurc =
    Language_Script_Jurc;
  static const Script Kali =
    Language_Script_Kali;
  static const Script Kana =
    Language_Script_Kana;
  static const Script Khar =
    Language_Script_Khar;
  static const Script Khmr =
    Language_Script_Khmr;
  static const Script Khoj =
    Language_Script_Khoj;
  static const Script Kitl =
    Language_Script_Kitl;
  static const Script Kits =
    Language_Script_Kits;
  static const Script Knda =
    Language_Script_Knda;
  static const Script Kore =
    Language_Script_Kore;
  static const Script Kpel =
    Language_Script_Kpel;
  static const Script Kthi =
    Language_Script_Kthi;
  static const Script Lana =
    Language_Script_Lana;
  static const Script Laoo =
    Language_Script_Laoo;
  static const Script Latf =
    Language_Script_Latf;
  static const Script Latg =
    Language_Script_Latg;
  static const Script Latn =
    Language_Script_Latn;
  static const Script Leke =
    Language_Script_Leke;
  static const Script Lepc =
    Language_Script_Lepc;
  static const Script Limb =
    Language_Script_Limb;
  static const Script Lina =
    Language_Script_Lina;
  static const Script Linb =
    Language_Script_Linb;
  static const Script Lisu =
    Language_Script_Lisu;
  static const Script Loma =
    Language_Script_Loma;
  static const Script Lyci =
    Language_Script_Lyci;
  static const Script Lydi =
    Language_Script_Lydi;
  static const Script Mahj =
    Language_Script_Mahj;
  static const Script Maka =
    Language_Script_Maka;
  static const Script Mand =
    Language_Script_Mand;
  static const Script Mani =
    Language_Script_Mani;
  static const Script Marc =
    Language_Script_Marc;
  static const Script Maya =
    Language_Script_Maya;
  static const Script Medf =
    Language_Script_Medf;
  static const Script Mend =
    Language_Script_Mend;
  static const Script Merc =
    Language_Script_Merc;
  static const Script Mero =
    Language_Script_Mero;
  static const Script Mlym =
    Language_Script_Mlym;
  static const Script Modi =
    Language_Script_Modi;
  static const Script Mong =
    Language_Script_Mong;
  static const Script Moon =
    Language_Script_Moon;
  static const Script Mroo =
    Language_Script_Mroo;
  static const Script Mtei =
    Language_Script_Mtei;
  static const Script Mult =
    Language_Script_Mult;
  static const Script Mymr =
    Language_Script_Mymr;
  static const Script Nand =
    Language_Script_Nand;
  static const Script Narb =
    Language_Script_Narb;
  static const Script Nbat =
    Language_Script_Nbat;
  static const Script Newa =
    Language_Script_Newa;
  static const Script Nkdb =
    Language_Script_Nkdb;
  static const Script Nkgb =
    Language_Script_Nkgb;
  static const Script Nkoo =
    Language_Script_Nkoo;
  static const Script Nshu =
    Language_Script_Nshu;
  static const Script Ogam =
    Language_Script_Ogam;
  static const Script Olck =
    Language_Script_Olck;
  static const Script Orkh =
    Language_Script_Orkh;
  static const Script Orya =
    Language_Script_Orya;
  static const Script Osge =
    Language_Script_Osge;
  static const Script Osma =
    Language_Script_Osma;
  static const Script Palm =
    Language_Script_Palm;
  static const Script Pauc =
    Language_Script_Pauc;
  static const Script Perm =
    Language_Script_Perm;
  static const Script Phag =
    Language_Script_Phag;
  static const Script Phli =
    Language_Script_Phli;
  static const Script Phlp =
    Language_Script_Phlp;
  static const Script Phlv =
    Language_Script_Phlv;
  static const Script Phnx =
    Language_Script_Phnx;
  static const Script Plrd =
    Language_Script_Plrd;
  static const Script Piqd =
    Language_Script_Piqd;
  static const Script Prti =
    Language_Script_Prti;
  static const Script Qaaa =
    Language_Script_Qaaa;
  static const Script Qabx =
    Language_Script_Qabx;
  static const Script Rjng =
    Language_Script_Rjng;
  static const Script Rohg =
    Language_Script_Rohg;
  static const Script Roro =
    Language_Script_Roro;
  static const Script Runr =
    Language_Script_Runr;
  static const Script Samr =
    Language_Script_Samr;
  static const Script Sara =
    Language_Script_Sara;
  static const Script Sarb =
    Language_Script_Sarb;
  static const Script Saur =
    Language_Script_Saur;
  static const Script Sgnw =
    Language_Script_Sgnw;
  static const Script Shaw =
    Language_Script_Shaw;
  static const Script Shrd =
    Language_Script_Shrd;
  static const Script Shui =
    Language_Script_Shui;
  static const Script Sidd =
    Language_Script_Sidd;
  static const Script Sind =
    Language_Script_Sind;
  static const Script Sinh =
    Language_Script_Sinh;
  static const Script Sogd =
    Language_Script_Sogd;
  static const Script Sogo =
    Language_Script_Sogo;
  static const Script Sora =
    Language_Script_Sora;
  static const Script Soyo =
    Language_Script_Soyo;
  static const Script Sund =
    Language_Script_Sund;
  static const Script Sylo =
    Language_Script_Sylo;
  static const Script Syrc =
    Language_Script_Syrc;
  static const Script Syre =
    Language_Script_Syre;
  static const Script Syrj =
    Language_Script_Syrj;
  static const Script Syrn =
    Language_Script_Syrn;
  static const Script Tagb =
    Language_Script_Tagb;
  static const Script Takr =
    Language_Script_Takr;
  static const Script Tale =
    Language_Script_Tale;
  static const Script Talu =
    Language_Script_Talu;
  static const Script Taml =
    Language_Script_Taml;
  static const Script Tang =
    Language_Script_Tang;
  static const Script Tavt =
    Language_Script_Tavt;
  static const Script Telu =
    Language_Script_Telu;
  static const Script Teng =
    Language_Script_Teng;
  static const Script Tfng =
    Language_Script_Tfng;
  static const Script Tglg =
    Language_Script_Tglg;
  static const Script Thaa =
    Language_Script_Thaa;
  static const Script Thai =
    Language_Script_Thai;
  static const Script Tibt =
    Language_Script_Tibt;
  static const Script Tirh =
    Language_Script_Tirh;
  static const Script Ugar =
    Language_Script_Ugar;
  static const Script Vaii =
    Language_Script_Vaii;
  static const Script Visp =
    Language_Script_Visp;
  static const Script Wara =
    Language_Script_Wara;
  static const Script Wcho =
    Language_Script_Wcho;
  static const Script Wole =
    Language_Script_Wole;
  static const Script Xpeo =
    Language_Script_Xpeo;
  static const Script Xsux =
    Language_Script_Xsux;
  static const Script Yiii =
    Language_Script_Yiii;
  static const Script Zanb =
    Language_Script_Zanb;
  static const Script Zinh =
    Language_Script_Zinh;
  static const Script Zmth =
    Language_Script_Zmth;
  static const Script Zsye =
    Language_Script_Zsye;
  static const Script Zsym =
    Language_Script_Zsym;
  static const Script Zxxx =
    Language_Script_Zxxx;
  static const Script Zyyy =
    Language_Script_Zyyy;
  static const Script Zzzz =
    Language_Script_Zzzz;
  static inline bool Script_IsValid(int value) {
    return Language_Script_IsValid(value);
  }
  static const Script Script_MIN =
    Language_Script_Script_MIN;
  static const Script Script_MAX =
    Language_Script_Script_MAX;
  static const int Script_ARRAYSIZE =
    Language_Script_Script_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Script_descriptor() {
    return Language_Script_descriptor();
  }
  static inline const ::std::string& Script_Name(Script value) {
    return Language_Script_Name(value);
  }
  static inline bool Script_Parse(const ::std::string& name,
      Script* value) {
    return Language_Script_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .pb.Language.Language language = 1;
  void clear_language();
  static const int kLanguageFieldNumber = 1;
  ::pb::Language_Language language() const;
  void set_language(::pb::Language_Language value);

  // .pb.Language.Script script = 2;
  void clear_script();
  static const int kScriptFieldNumber = 2;
  ::pb::Language_Script script() const;
  void set_script(::pb::Language_Script value);

  // .pb.Location.Country region = 3;
  void clear_region();
  static const int kRegionFieldNumber = 3;
  ::pb::Location_Country region() const;
  void set_region(::pb::Location_Country value);

  // @@protoc_insertion_point(class_scope:pb.Language)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int language_;
  int script_;
  int region_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsLanguageImpl();
};
// -------------------------------------------------------------------

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const PROTOBUF_FINAL { return New(NULL); }

  Location* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Location_Country Country;
  static const Country UNKNOWN_COUNTRY =
    Location_Country_UNKNOWN_COUNTRY;
  static const Country AF =
    Location_Country_AF;
  static const Country AX =
    Location_Country_AX;
  static const Country AL =
    Location_Country_AL;
  static const Country DZ =
    Location_Country_DZ;
  static const Country AS =
    Location_Country_AS;
  static const Country AD =
    Location_Country_AD;
  static const Country AO =
    Location_Country_AO;
  static const Country AI =
    Location_Country_AI;
  static const Country AQ =
    Location_Country_AQ;
  static const Country AG =
    Location_Country_AG;
  static const Country AR =
    Location_Country_AR;
  static const Country AM =
    Location_Country_AM;
  static const Country AW =
    Location_Country_AW;
  static const Country AU =
    Location_Country_AU;
  static const Country AT =
    Location_Country_AT;
  static const Country AZ =
    Location_Country_AZ;
  static const Country BS =
    Location_Country_BS;
  static const Country BH =
    Location_Country_BH;
  static const Country BD =
    Location_Country_BD;
  static const Country BB =
    Location_Country_BB;
  static const Country BY =
    Location_Country_BY;
  static const Country BE =
    Location_Country_BE;
  static const Country BZ =
    Location_Country_BZ;
  static const Country BJ =
    Location_Country_BJ;
  static const Country BM =
    Location_Country_BM;
  static const Country BT =
    Location_Country_BT;
  static const Country BO =
    Location_Country_BO;
  static const Country BQ =
    Location_Country_BQ;
  static const Country BA =
    Location_Country_BA;
  static const Country BW =
    Location_Country_BW;
  static const Country BV =
    Location_Country_BV;
  static const Country BR =
    Location_Country_BR;
  static const Country IO =
    Location_Country_IO;
  static const Country BN =
    Location_Country_BN;
  static const Country BG =
    Location_Country_BG;
  static const Country BF =
    Location_Country_BF;
  static const Country BI =
    Location_Country_BI;
  static const Country KH =
    Location_Country_KH;
  static const Country CM =
    Location_Country_CM;
  static const Country CA =
    Location_Country_CA;
  static const Country CV =
    Location_Country_CV;
  static const Country KY =
    Location_Country_KY;
  static const Country CF =
    Location_Country_CF;
  static const Country TD =
    Location_Country_TD;
  static const Country CL =
    Location_Country_CL;
  static const Country CN =
    Location_Country_CN;
  static const Country CX =
    Location_Country_CX;
  static const Country CC =
    Location_Country_CC;
  static const Country CO =
    Location_Country_CO;
  static const Country KM =
    Location_Country_KM;
  static const Country CG =
    Location_Country_CG;
  static const Country CD =
    Location_Country_CD;
  static const Country CK =
    Location_Country_CK;
  static const Country CR =
    Location_Country_CR;
  static const Country CI =
    Location_Country_CI;
  static const Country HR =
    Location_Country_HR;
  static const Country CU =
    Location_Country_CU;
  static const Country CW =
    Location_Country_CW;
  static const Country CY =
    Location_Country_CY;
  static const Country CZ =
    Location_Country_CZ;
  static const Country DK =
    Location_Country_DK;
  static const Country DJ =
    Location_Country_DJ;
  static const Country DM =
    Location_Country_DM;
  static const Country DO =
    Location_Country_DO;
  static const Country EC =
    Location_Country_EC;
  static const Country EG =
    Location_Country_EG;
  static const Country SV =
    Location_Country_SV;
  static const Country GQ =
    Location_Country_GQ;
  static const Country ER =
    Location_Country_ER;
  static const Country EE =
    Location_Country_EE;
  static const Country ET =
    Location_Country_ET;
  static const Country FK =
    Location_Country_FK;
  static const Country FO =
    Location_Country_FO;
  static const Country FJ =
    Location_Country_FJ;
  static const Country FI =
    Location_Country_FI;
  static const Country FR =
    Location_Country_FR;
  static const Country GF =
    Location_Country_GF;
  static const Country PF =
    Location_Country_PF;
  static const Country TF =
    Location_Country_TF;
  static const Country GA =
    Location_Country_GA;
  static const Country GM =
    Location_Country_GM;
  static const Country GE =
    Location_Country_GE;
  static const Country DE =
    Location_Country_DE;
  static const Country GH =
    Location_Country_GH;
  static const Country GI =
    Location_Country_GI;
  static const Country GR =
    Location_Country_GR;
  static const Country GL =
    Location_Country_GL;
  static const Country GD =
    Location_Country_GD;
  static const Country GP =
    Location_Country_GP;
  static const Country GU =
    Location_Country_GU;
  static const Country GT =
    Location_Country_GT;
  static const Country GG =
    Location_Country_GG;
  static const Country GN =
    Location_Country_GN;
  static const Country GW =
    Location_Country_GW;
  static const Country GY =
    Location_Country_GY;
  static const Country HT =
    Location_Country_HT;
  static const Country HM =
    Location_Country_HM;
  static const Country VA =
    Location_Country_VA;
  static const Country HN =
    Location_Country_HN;
  static const Country HK =
    Location_Country_HK;
  static const Country HU =
    Location_Country_HU;
  static const Country IS =
    Location_Country_IS;
  static const Country IN =
    Location_Country_IN;
  static const Country ID =
    Location_Country_ID;
  static const Country IR =
    Location_Country_IR;
  static const Country IQ =
    Location_Country_IQ;
  static const Country IE =
    Location_Country_IE;
  static const Country IM =
    Location_Country_IM;
  static const Country IL =
    Location_Country_IL;
  static const Country IT =
    Location_Country_IT;
  static const Country JM =
    Location_Country_JM;
  static const Country JP =
    Location_Country_JP;
  static const Country JE =
    Location_Country_JE;
  static const Country JO =
    Location_Country_JO;
  static const Country KZ =
    Location_Country_KZ;
  static const Country KE =
    Location_Country_KE;
  static const Country KI =
    Location_Country_KI;
  static const Country KP =
    Location_Country_KP;
  static const Country KR =
    Location_Country_KR;
  static const Country KW =
    Location_Country_KW;
  static const Country KG =
    Location_Country_KG;
  static const Country LA =
    Location_Country_LA;
  static const Country LV =
    Location_Country_LV;
  static const Country LB =
    Location_Country_LB;
  static const Country LS =
    Location_Country_LS;
  static const Country LR =
    Location_Country_LR;
  static const Country LY =
    Location_Country_LY;
  static const Country LI =
    Location_Country_LI;
  static const Country LT =
    Location_Country_LT;
  static const Country LU =
    Location_Country_LU;
  static const Country MO =
    Location_Country_MO;
  static const Country MK =
    Location_Country_MK;
  static const Country MG =
    Location_Country_MG;
  static const Country MW =
    Location_Country_MW;
  static const Country MY =
    Location_Country_MY;
  static const Country MV =
    Location_Country_MV;
  static const Country ML =
    Location_Country_ML;
  static const Country MT =
    Location_Country_MT;
  static const Country MH =
    Location_Country_MH;
  static const Country MQ =
    Location_Country_MQ;
  static const Country MR =
    Location_Country_MR;
  static const Country MU =
    Location_Country_MU;
  static const Country YT =
    Location_Country_YT;
  static const Country MX =
    Location_Country_MX;
  static const Country FM =
    Location_Country_FM;
  static const Country MD =
    Location_Country_MD;
  static const Country MC =
    Location_Country_MC;
  static const Country MN =
    Location_Country_MN;
  static const Country ME =
    Location_Country_ME;
  static const Country MS =
    Location_Country_MS;
  static const Country MA =
    Location_Country_MA;
  static const Country MZ =
    Location_Country_MZ;
  static const Country MM =
    Location_Country_MM;
  static const Country NA =
    Location_Country_NA;
  static const Country NR =
    Location_Country_NR;
  static const Country NP =
    Location_Country_NP;
  static const Country NL =
    Location_Country_NL;
  static const Country NC =
    Location_Country_NC;
  static const Country NZ =
    Location_Country_NZ;
  static const Country NI =
    Location_Country_NI;
  static const Country NE =
    Location_Country_NE;
  static const Country NG =
    Location_Country_NG;
  static const Country NU =
    Location_Country_NU;
  static const Country NF =
    Location_Country_NF;
  static const Country MP =
    Location_Country_MP;
  static const Country NO =
    Location_Country_NO;
  static const Country OM =
    Location_Country_OM;
  static const Country PK =
    Location_Country_PK;
  static const Country PW =
    Location_Country_PW;
  static const Country PS =
    Location_Country_PS;
  static const Country PA =
    Location_Country_PA;
  static const Country PG =
    Location_Country_PG;
  static const Country PY =
    Location_Country_PY;
  static const Country PE =
    Location_Country_PE;
  static const Country PH =
    Location_Country_PH;
  static const Country PN =
    Location_Country_PN;
  static const Country PL =
    Location_Country_PL;
  static const Country PT =
    Location_Country_PT;
  static const Country PR =
    Location_Country_PR;
  static const Country QA =
    Location_Country_QA;
  static const Country RE =
    Location_Country_RE;
  static const Country RO =
    Location_Country_RO;
  static const Country RU =
    Location_Country_RU;
  static const Country RW =
    Location_Country_RW;
  static const Country BL =
    Location_Country_BL;
  static const Country SH =
    Location_Country_SH;
  static const Country KN =
    Location_Country_KN;
  static const Country LC =
    Location_Country_LC;
  static const Country MF =
    Location_Country_MF;
  static const Country PM =
    Location_Country_PM;
  static const Country VC =
    Location_Country_VC;
  static const Country WS =
    Location_Country_WS;
  static const Country SM =
    Location_Country_SM;
  static const Country ST =
    Location_Country_ST;
  static const Country SA =
    Location_Country_SA;
  static const Country SN =
    Location_Country_SN;
  static const Country RS =
    Location_Country_RS;
  static const Country SC =
    Location_Country_SC;
  static const Country SL =
    Location_Country_SL;
  static const Country SG =
    Location_Country_SG;
  static const Country SX =
    Location_Country_SX;
  static const Country SK =
    Location_Country_SK;
  static const Country SI =
    Location_Country_SI;
  static const Country SB =
    Location_Country_SB;
  static const Country SO =
    Location_Country_SO;
  static const Country ZA =
    Location_Country_ZA;
  static const Country GS =
    Location_Country_GS;
  static const Country SS =
    Location_Country_SS;
  static const Country ES =
    Location_Country_ES;
  static const Country LK =
    Location_Country_LK;
  static const Country SD =
    Location_Country_SD;
  static const Country SR =
    Location_Country_SR;
  static const Country SJ =
    Location_Country_SJ;
  static const Country SZ =
    Location_Country_SZ;
  static const Country SE =
    Location_Country_SE;
  static const Country CH =
    Location_Country_CH;
  static const Country SY =
    Location_Country_SY;
  static const Country TW =
    Location_Country_TW;
  static const Country TJ =
    Location_Country_TJ;
  static const Country TZ =
    Location_Country_TZ;
  static const Country TH =
    Location_Country_TH;
  static const Country TL =
    Location_Country_TL;
  static const Country TG =
    Location_Country_TG;
  static const Country TK =
    Location_Country_TK;
  static const Country TO =
    Location_Country_TO;
  static const Country TT =
    Location_Country_TT;
  static const Country TN =
    Location_Country_TN;
  static const Country TR =
    Location_Country_TR;
  static const Country TM =
    Location_Country_TM;
  static const Country TC =
    Location_Country_TC;
  static const Country TV =
    Location_Country_TV;
  static const Country UG =
    Location_Country_UG;
  static const Country UA =
    Location_Country_UA;
  static const Country AE =
    Location_Country_AE;
  static const Country GB =
    Location_Country_GB;
  static const Country US =
    Location_Country_US;
  static const Country UM =
    Location_Country_UM;
  static const Country UY =
    Location_Country_UY;
  static const Country UZ =
    Location_Country_UZ;
  static const Country VU =
    Location_Country_VU;
  static const Country VE =
    Location_Country_VE;
  static const Country VN =
    Location_Country_VN;
  static const Country VG =
    Location_Country_VG;
  static const Country VI =
    Location_Country_VI;
  static const Country WF =
    Location_Country_WF;
  static const Country EH =
    Location_Country_EH;
  static const Country YE =
    Location_Country_YE;
  static const Country ZM =
    Location_Country_ZM;
  static const Country ZW =
    Location_Country_ZW;
  static inline bool Country_IsValid(int value) {
    return Location_Country_IsValid(value);
  }
  static const Country Country_MIN =
    Location_Country_Country_MIN;
  static const Country Country_MAX =
    Location_Country_Country_MAX;
  static const int Country_ARRAYSIZE =
    Location_Country_Country_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Country_descriptor() {
    return Location_Country_descriptor();
  }
  static inline const ::std::string& Country_Name(Country value) {
    return Location_Country_Name(value);
  }
  static inline bool Country_Parse(const ::std::string& name,
      Country* value) {
    return Location_Country_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // string state = 2;
  void clear_state();
  static const int kStateFieldNumber = 2;
  const ::std::string& state() const;
  void set_state(const ::std::string& value);
  #if LANG_CXX11
  void set_state(::std::string&& value);
  #endif
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  ::std::string* mutable_state();
  ::std::string* release_state();
  void set_allocated_state(::std::string* state);

  // string city = 3;
  void clear_city();
  static const int kCityFieldNumber = 3;
  const ::std::string& city() const;
  void set_city(const ::std::string& value);
  #if LANG_CXX11
  void set_city(::std::string&& value);
  #endif
  void set_city(const char* value);
  void set_city(const char* value, size_t size);
  ::std::string* mutable_city();
  ::std::string* release_city();
  void set_allocated_city(::std::string* city);

  // string code = 4;
  void clear_code();
  static const int kCodeFieldNumber = 4;
  const ::std::string& code() const;
  void set_code(const ::std::string& value);
  #if LANG_CXX11
  void set_code(::std::string&& value);
  #endif
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  ::std::string* mutable_code();
  ::std::string* release_code();
  void set_allocated_code(::std::string* code);

  // .pb.Location.Country country = 1;
  void clear_country();
  static const int kCountryFieldNumber = 1;
  ::pb::Location_Country country() const;
  void set_country(::pb::Location_Country value);

  // sint32 latitude = 5;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 5;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // sint32 longitude = 6;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 6;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pb.Location)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr state_;
  ::google::protobuf::internal::ArenaStringPtr city_;
  ::google::protobuf::internal::ArenaStringPtr code_;
  int country_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  mutable int _cached_size_;
  friend struct ::protobuf_claim_2eproto::TableStruct;
  friend void ::protobuf_claim_2eproto::InitDefaultsLocationImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Claim

// .pb.Stream stream = 1;
inline bool Claim::has_stream() const {
  return type_case() == kStream;
}
inline void Claim::set_has_stream() {
  _oneof_case_[0] = kStream;
}
inline void Claim::clear_stream() {
  if (has_stream()) {
    delete type_.stream_;
    clear_has_type();
  }
}
inline ::pb::Stream* Claim::release_stream() {
  // @@protoc_insertion_point(field_release:pb.Claim.stream)
  if (has_stream()) {
    clear_has_type();
      ::pb::Stream* temp = type_.stream_;
    type_.stream_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pb::Stream& Claim::stream() const {
  // @@protoc_insertion_point(field_get:pb.Claim.stream)
  return has_stream()
      ? *type_.stream_
      : *reinterpret_cast< ::pb::Stream*>(&::pb::_Stream_default_instance_);
}
inline ::pb::Stream* Claim::mutable_stream() {
  if (!has_stream()) {
    clear_type();
    set_has_stream();
    type_.stream_ = new ::pb::Stream;
  }
  // @@protoc_insertion_point(field_mutable:pb.Claim.stream)
  return type_.stream_;
}

// .pb.Channel channel = 2;
inline bool Claim::has_channel() const {
  return type_case() == kChannel;
}
inline void Claim::set_has_channel() {
  _oneof_case_[0] = kChannel;
}
inline void Claim::clear_channel() {
  if (has_channel()) {
    delete type_.channel_;
    clear_has_type();
  }
}
inline ::pb::Channel* Claim::release_channel() {
  // @@protoc_insertion_point(field_release:pb.Claim.channel)
  if (has_channel()) {
    clear_has_type();
      ::pb::Channel* temp = type_.channel_;
    type_.channel_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pb::Channel& Claim::channel() const {
  // @@protoc_insertion_point(field_get:pb.Claim.channel)
  return has_channel()
      ? *type_.channel_
      : *reinterpret_cast< ::pb::Channel*>(&::pb::_Channel_default_instance_);
}
inline ::pb::Channel* Claim::mutable_channel() {
  if (!has_channel()) {
    clear_type();
    set_has_channel();
    type_.channel_ = new ::pb::Channel;
  }
  // @@protoc_insertion_point(field_mutable:pb.Claim.channel)
  return type_.channel_;
}

inline bool Claim::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Claim::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Claim::TypeCase Claim::type_case() const {
  return Claim::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Channel

// bytes public_key = 1;
inline void Channel::clear_public_key() {
  public_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::public_key() const {
  // @@protoc_insertion_point(field_get:pb.Channel.public_key)
  return public_key_.GetNoArena();
}
inline void Channel::set_public_key(const ::std::string& value) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.public_key)
}
#if LANG_CXX11
inline void Channel::set_public_key(::std::string&& value) {
  
  public_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.public_key)
}
#endif
inline void Channel::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.public_key)
}
inline void Channel::set_public_key(const void* value, size_t size) {
  
  public_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.public_key)
}
inline ::std::string* Channel::mutable_public_key() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.public_key)
  return public_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_public_key() {
  // @@protoc_insertion_point(field_release:pb.Channel.public_key)
  
  return public_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_public_key(::std::string* public_key) {
  if (public_key != NULL) {
    
  } else {
    
  }
  public_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), public_key);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.public_key)
}

// string title = 2;
inline void Channel::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::title() const {
  // @@protoc_insertion_point(field_get:pb.Channel.title)
  return title_.GetNoArena();
}
inline void Channel::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.title)
}
#if LANG_CXX11
inline void Channel::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.title)
}
#endif
inline void Channel::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.title)
}
inline void Channel::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.title)
}
inline ::std::string* Channel::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_title() {
  // @@protoc_insertion_point(field_release:pb.Channel.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.title)
}

// string description = 3;
inline void Channel::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::description() const {
  // @@protoc_insertion_point(field_get:pb.Channel.description)
  return description_.GetNoArena();
}
inline void Channel::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.description)
}
#if LANG_CXX11
inline void Channel::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.description)
}
#endif
inline void Channel::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.description)
}
inline void Channel::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.description)
}
inline ::std::string* Channel::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_description() {
  // @@protoc_insertion_point(field_release:pb.Channel.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.description)
}

// string thumbnail_url = 4;
inline void Channel::clear_thumbnail_url() {
  thumbnail_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:pb.Channel.thumbnail_url)
  return thumbnail_url_.GetNoArena();
}
inline void Channel::set_thumbnail_url(const ::std::string& value) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.thumbnail_url)
}
#if LANG_CXX11
inline void Channel::set_thumbnail_url(::std::string&& value) {
  
  thumbnail_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.thumbnail_url)
}
#endif
inline void Channel::set_thumbnail_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.thumbnail_url)
}
inline void Channel::set_thumbnail_url(const char* value, size_t size) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.thumbnail_url)
}
inline ::std::string* Channel::mutable_thumbnail_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.thumbnail_url)
  return thumbnail_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:pb.Channel.thumbnail_url)
  
  return thumbnail_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_thumbnail_url(::std::string* thumbnail_url) {
  if (thumbnail_url != NULL) {
    
  } else {
    
  }
  thumbnail_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_url);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.thumbnail_url)
}

// repeated string tags = 5;
inline int Channel::tags_size() const {
  return tags_.size();
}
inline void Channel::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Channel::tags(int index) const {
  // @@protoc_insertion_point(field_get:pb.Channel.tags)
  return tags_.Get(index);
}
inline ::std::string* Channel::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Channel.tags)
  return tags_.Mutable(index);
}
inline void Channel::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Channel.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Channel::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.Channel.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Channel::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Channel.tags)
}
inline void Channel::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.tags)
}
inline ::std::string* Channel::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:pb.Channel.tags)
  return tags_.Add();
}
inline void Channel::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Channel.tags)
}
#if LANG_CXX11
inline void Channel::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.Channel.tags)
}
#endif
inline void Channel::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Channel.tags)
}
inline void Channel::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Channel.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Channel::tags() const {
  // @@protoc_insertion_point(field_list:pb.Channel.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Channel::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:pb.Channel.tags)
  return &tags_;
}

// repeated .pb.Language languages = 6;
inline int Channel::languages_size() const {
  return languages_.size();
}
inline void Channel::clear_languages() {
  languages_.Clear();
}
inline const ::pb::Language& Channel::languages(int index) const {
  // @@protoc_insertion_point(field_get:pb.Channel.languages)
  return languages_.Get(index);
}
inline ::pb::Language* Channel::mutable_languages(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Channel.languages)
  return languages_.Mutable(index);
}
inline ::pb::Language* Channel::add_languages() {
  // @@protoc_insertion_point(field_add:pb.Channel.languages)
  return languages_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Language >*
Channel::mutable_languages() {
  // @@protoc_insertion_point(field_mutable_list:pb.Channel.languages)
  return &languages_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Language >&
Channel::languages() const {
  // @@protoc_insertion_point(field_list:pb.Channel.languages)
  return languages_;
}

// repeated .pb.Location locations = 7;
inline int Channel::locations_size() const {
  return locations_.size();
}
inline void Channel::clear_locations() {
  locations_.Clear();
}
inline const ::pb::Location& Channel::locations(int index) const {
  // @@protoc_insertion_point(field_get:pb.Channel.locations)
  return locations_.Get(index);
}
inline ::pb::Location* Channel::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Channel.locations)
  return locations_.Mutable(index);
}
inline ::pb::Location* Channel::add_locations() {
  // @@protoc_insertion_point(field_add:pb.Channel.locations)
  return locations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Location >*
Channel::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:pb.Channel.locations)
  return &locations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Location >&
Channel::locations() const {
  // @@protoc_insertion_point(field_list:pb.Channel.locations)
  return locations_;
}

// string contact_email = 8;
inline void Channel::clear_contact_email() {
  contact_email_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::contact_email() const {
  // @@protoc_insertion_point(field_get:pb.Channel.contact_email)
  return contact_email_.GetNoArena();
}
inline void Channel::set_contact_email(const ::std::string& value) {
  
  contact_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.contact_email)
}
#if LANG_CXX11
inline void Channel::set_contact_email(::std::string&& value) {
  
  contact_email_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.contact_email)
}
#endif
inline void Channel::set_contact_email(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  contact_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.contact_email)
}
inline void Channel::set_contact_email(const char* value, size_t size) {
  
  contact_email_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.contact_email)
}
inline ::std::string* Channel::mutable_contact_email() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.contact_email)
  return contact_email_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_contact_email() {
  // @@protoc_insertion_point(field_release:pb.Channel.contact_email)
  
  return contact_email_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_contact_email(::std::string* contact_email) {
  if (contact_email != NULL) {
    
  } else {
    
  }
  contact_email_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), contact_email);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.contact_email)
}

// string homepage_url = 9;
inline void Channel::clear_homepage_url() {
  homepage_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::homepage_url() const {
  // @@protoc_insertion_point(field_get:pb.Channel.homepage_url)
  return homepage_url_.GetNoArena();
}
inline void Channel::set_homepage_url(const ::std::string& value) {
  
  homepage_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.homepage_url)
}
#if LANG_CXX11
inline void Channel::set_homepage_url(::std::string&& value) {
  
  homepage_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.homepage_url)
}
#endif
inline void Channel::set_homepage_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  homepage_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.homepage_url)
}
inline void Channel::set_homepage_url(const char* value, size_t size) {
  
  homepage_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.homepage_url)
}
inline ::std::string* Channel::mutable_homepage_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.homepage_url)
  return homepage_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_homepage_url() {
  // @@protoc_insertion_point(field_release:pb.Channel.homepage_url)
  
  return homepage_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_homepage_url(::std::string* homepage_url) {
  if (homepage_url != NULL) {
    
  } else {
    
  }
  homepage_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), homepage_url);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.homepage_url)
}

// string cover_url = 10;
inline void Channel::clear_cover_url() {
  cover_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Channel::cover_url() const {
  // @@protoc_insertion_point(field_get:pb.Channel.cover_url)
  return cover_url_.GetNoArena();
}
inline void Channel::set_cover_url(const ::std::string& value) {
  
  cover_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Channel.cover_url)
}
#if LANG_CXX11
inline void Channel::set_cover_url(::std::string&& value) {
  
  cover_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.cover_url)
}
#endif
inline void Channel::set_cover_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  cover_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Channel.cover_url)
}
inline void Channel::set_cover_url(const char* value, size_t size) {
  
  cover_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.cover_url)
}
inline ::std::string* Channel::mutable_cover_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Channel.cover_url)
  return cover_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Channel::release_cover_url() {
  // @@protoc_insertion_point(field_release:pb.Channel.cover_url)
  
  return cover_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Channel::set_allocated_cover_url(::std::string* cover_url) {
  if (cover_url != NULL) {
    
  } else {
    
  }
  cover_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cover_url);
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.cover_url)
}

// -------------------------------------------------------------------

// Stream

// bytes sd_hash = 1;
inline void Stream::clear_sd_hash() {
  sd_hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::sd_hash() const {
  // @@protoc_insertion_point(field_get:pb.Stream.sd_hash)
  return sd_hash_.GetNoArena();
}
inline void Stream::set_sd_hash(const ::std::string& value) {
  
  sd_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.sd_hash)
}
#if LANG_CXX11
inline void Stream::set_sd_hash(::std::string&& value) {
  
  sd_hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.sd_hash)
}
#endif
inline void Stream::set_sd_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sd_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.sd_hash)
}
inline void Stream::set_sd_hash(const void* value, size_t size) {
  
  sd_hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.sd_hash)
}
inline ::std::string* Stream::mutable_sd_hash() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.sd_hash)
  return sd_hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_sd_hash() {
  // @@protoc_insertion_point(field_release:pb.Stream.sd_hash)
  
  return sd_hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_sd_hash(::std::string* sd_hash) {
  if (sd_hash != NULL) {
    
  } else {
    
  }
  sd_hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sd_hash);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.sd_hash)
}

// string title = 2;
inline void Stream::clear_title() {
  title_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::title() const {
  // @@protoc_insertion_point(field_get:pb.Stream.title)
  return title_.GetNoArena();
}
inline void Stream::set_title(const ::std::string& value) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.title)
}
#if LANG_CXX11
inline void Stream::set_title(::std::string&& value) {
  
  title_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.title)
}
#endif
inline void Stream::set_title(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.title)
}
inline void Stream::set_title(const char* value, size_t size) {
  
  title_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.title)
}
inline ::std::string* Stream::mutable_title() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.title)
  return title_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_title() {
  // @@protoc_insertion_point(field_release:pb.Stream.title)
  
  return title_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_title(::std::string* title) {
  if (title != NULL) {
    
  } else {
    
  }
  title_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), title);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.title)
}

// string description = 3;
inline void Stream::clear_description() {
  description_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::description() const {
  // @@protoc_insertion_point(field_get:pb.Stream.description)
  return description_.GetNoArena();
}
inline void Stream::set_description(const ::std::string& value) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.description)
}
#if LANG_CXX11
inline void Stream::set_description(::std::string&& value) {
  
  description_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.description)
}
#endif
inline void Stream::set_description(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.description)
}
inline void Stream::set_description(const char* value, size_t size) {
  
  description_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.description)
}
inline ::std::string* Stream::mutable_description() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.description)
  return description_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_description() {
  // @@protoc_insertion_point(field_release:pb.Stream.description)
  
  return description_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_description(::std::string* description) {
  if (description != NULL) {
    
  } else {
    
  }
  description_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), description);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.description)
}

// string thumbnail_url = 4;
inline void Stream::clear_thumbnail_url() {
  thumbnail_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:pb.Stream.thumbnail_url)
  return thumbnail_url_.GetNoArena();
}
inline void Stream::set_thumbnail_url(const ::std::string& value) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.thumbnail_url)
}
#if LANG_CXX11
inline void Stream::set_thumbnail_url(::std::string&& value) {
  
  thumbnail_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.thumbnail_url)
}
#endif
inline void Stream::set_thumbnail_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.thumbnail_url)
}
inline void Stream::set_thumbnail_url(const char* value, size_t size) {
  
  thumbnail_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.thumbnail_url)
}
inline ::std::string* Stream::mutable_thumbnail_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.thumbnail_url)
  return thumbnail_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:pb.Stream.thumbnail_url)
  
  return thumbnail_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_thumbnail_url(::std::string* thumbnail_url) {
  if (thumbnail_url != NULL) {
    
  } else {
    
  }
  thumbnail_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), thumbnail_url);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.thumbnail_url)
}

// repeated string tags = 5;
inline int Stream::tags_size() const {
  return tags_.size();
}
inline void Stream::clear_tags() {
  tags_.Clear();
}
inline const ::std::string& Stream::tags(int index) const {
  // @@protoc_insertion_point(field_get:pb.Stream.tags)
  return tags_.Get(index);
}
inline ::std::string* Stream::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Stream.tags)
  return tags_.Mutable(index);
}
inline void Stream::set_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Stream.tags)
  tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Stream::set_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.Stream.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Stream::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Stream.tags)
}
inline void Stream::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.tags)
}
inline ::std::string* Stream::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:pb.Stream.tags)
  return tags_.Add();
}
inline void Stream::add_tags(const ::std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Stream.tags)
}
#if LANG_CXX11
inline void Stream::add_tags(::std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.Stream.tags)
}
#endif
inline void Stream::add_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Stream.tags)
}
inline void Stream::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Stream.tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Stream::tags() const {
  // @@protoc_insertion_point(field_list:pb.Stream.tags)
  return tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Stream::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:pb.Stream.tags)
  return &tags_;
}

// repeated .pb.Language languages = 6;
inline int Stream::languages_size() const {
  return languages_.size();
}
inline void Stream::clear_languages() {
  languages_.Clear();
}
inline const ::pb::Language& Stream::languages(int index) const {
  // @@protoc_insertion_point(field_get:pb.Stream.languages)
  return languages_.Get(index);
}
inline ::pb::Language* Stream::mutable_languages(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Stream.languages)
  return languages_.Mutable(index);
}
inline ::pb::Language* Stream::add_languages() {
  // @@protoc_insertion_point(field_add:pb.Stream.languages)
  return languages_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Language >*
Stream::mutable_languages() {
  // @@protoc_insertion_point(field_mutable_list:pb.Stream.languages)
  return &languages_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Language >&
Stream::languages() const {
  // @@protoc_insertion_point(field_list:pb.Stream.languages)
  return languages_;
}

// repeated .pb.Location locations = 7;
inline int Stream::locations_size() const {
  return locations_.size();
}
inline void Stream::clear_locations() {
  locations_.Clear();
}
inline const ::pb::Location& Stream::locations(int index) const {
  // @@protoc_insertion_point(field_get:pb.Stream.locations)
  return locations_.Get(index);
}
inline ::pb::Location* Stream::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Stream.locations)
  return locations_.Mutable(index);
}
inline ::pb::Location* Stream::add_locations() {
  // @@protoc_insertion_point(field_add:pb.Stream.locations)
  return locations_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Location >*
Stream::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:pb.Stream.locations)
  return &locations_;
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Location >&
Stream::locations() const {
  // @@protoc_insertion_point(field_list:pb.Stream.locations)
  return locations_;
}

// string author = 8;
inline void Stream::clear_author() {
  author_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::author() const {
  // @@protoc_insertion_point(field_get:pb.Stream.author)
  return author_.GetNoArena();
}
inline void Stream::set_author(const ::std::string& value) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.author)
}
#if LANG_CXX11
inline void Stream::set_author(::std::string&& value) {
  
  author_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.author)
}
#endif
inline void Stream::set_author(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.author)
}
inline void Stream::set_author(const char* value, size_t size) {
  
  author_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.author)
}
inline ::std::string* Stream::mutable_author() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.author)
  return author_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_author() {
  // @@protoc_insertion_point(field_release:pb.Stream.author)
  
  return author_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_author(::std::string* author) {
  if (author != NULL) {
    
  } else {
    
  }
  author_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), author);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.author)
}

// string license = 9;
inline void Stream::clear_license() {
  license_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::license() const {
  // @@protoc_insertion_point(field_get:pb.Stream.license)
  return license_.GetNoArena();
}
inline void Stream::set_license(const ::std::string& value) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.license)
}
#if LANG_CXX11
inline void Stream::set_license(::std::string&& value) {
  
  license_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.license)
}
#endif
inline void Stream::set_license(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.license)
}
inline void Stream::set_license(const char* value, size_t size) {
  
  license_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.license)
}
inline ::std::string* Stream::mutable_license() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.license)
  return license_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_license() {
  // @@protoc_insertion_point(field_release:pb.Stream.license)
  
  return license_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_license(::std::string* license) {
  if (license != NULL) {
    
  } else {
    
  }
  license_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.license)
}

// string license_url = 10;
inline void Stream::clear_license_url() {
  license_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::license_url() const {
  // @@protoc_insertion_point(field_get:pb.Stream.license_url)
  return license_url_.GetNoArena();
}
inline void Stream::set_license_url(const ::std::string& value) {
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.license_url)
}
#if LANG_CXX11
inline void Stream::set_license_url(::std::string&& value) {
  
  license_url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.license_url)
}
#endif
inline void Stream::set_license_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.license_url)
}
inline void Stream::set_license_url(const char* value, size_t size) {
  
  license_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.license_url)
}
inline ::std::string* Stream::mutable_license_url() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.license_url)
  return license_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_license_url() {
  // @@protoc_insertion_point(field_release:pb.Stream.license_url)
  
  return license_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_license_url(::std::string* license_url) {
  if (license_url != NULL) {
    
  } else {
    
  }
  license_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), license_url);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.license_url)
}

// int64 release_time = 11;
inline void Stream::clear_release_time() {
  release_time_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Stream::release_time() const {
  // @@protoc_insertion_point(field_get:pb.Stream.release_time)
  return release_time_;
}
inline void Stream::set_release_time(::google::protobuf::int64 value) {
  
  release_time_ = value;
  // @@protoc_insertion_point(field_set:pb.Stream.release_time)
}

// string media_type = 13;
inline void Stream::clear_media_type() {
  media_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Stream::media_type() const {
  // @@protoc_insertion_point(field_get:pb.Stream.media_type)
  return media_type_.GetNoArena();
}
inline void Stream::set_media_type(const ::std::string& value) {
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Stream.media_type)
}
#if LANG_CXX11
inline void Stream::set_media_type(::std::string&& value) {
  
  media_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.media_type)
}
#endif
inline void Stream::set_media_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Stream.media_type)
}
inline void Stream::set_media_type(const char* value, size_t size) {
  
  media_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.media_type)
}
inline ::std::string* Stream::mutable_media_type() {
  
  // @@protoc_insertion_point(field_mutable:pb.Stream.media_type)
  return media_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Stream::release_media_type() {
  // @@protoc_insertion_point(field_release:pb.Stream.media_type)
  
  return media_type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Stream::set_allocated_media_type(::std::string* media_type) {
  if (media_type != NULL) {
    
  } else {
    
  }
  media_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), media_type);
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.media_type)
}

// .pb.File file = 14;
inline bool Stream::has_file() const {
  return this != internal_default_instance() && file_ != NULL;
}
inline void Stream::clear_file() {
  if (GetArenaNoVirtual() == NULL && file_ != NULL) {
    delete file_;
  }
  file_ = NULL;
}
inline const ::pb::File& Stream::file() const {
  const ::pb::File* p = file_;
  // @@protoc_insertion_point(field_get:pb.Stream.file)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::File*>(
      &::pb::_File_default_instance_);
}
inline ::pb::File* Stream::release_file() {
  // @@protoc_insertion_point(field_release:pb.Stream.file)
  
  ::pb::File* temp = file_;
  file_ = NULL;
  return temp;
}
inline ::pb::File* Stream::mutable_file() {
  
  if (file_ == NULL) {
    file_ = new ::pb::File;
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.file)
  return file_;
}
inline void Stream::set_allocated_file(::pb::File* file) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete file_;
  }
  if (file) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      file = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, file, submessage_arena);
    }
    
  } else {
    
  }
  file_ = file;
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.file)
}

// .pb.Fee fee = 15;
inline bool Stream::has_fee() const {
  return this != internal_default_instance() && fee_ != NULL;
}
inline void Stream::clear_fee() {
  if (GetArenaNoVirtual() == NULL && fee_ != NULL) {
    delete fee_;
  }
  fee_ = NULL;
}
inline const ::pb::Fee& Stream::fee() const {
  const ::pb::Fee* p = fee_;
  // @@protoc_insertion_point(field_get:pb.Stream.fee)
  return p != NULL ? *p : *reinterpret_cast<const ::pb::Fee*>(
      &::pb::_Fee_default_instance_);
}
inline ::pb::Fee* Stream::release_fee() {
  // @@protoc_insertion_point(field_release:pb.Stream.fee)
  
  ::pb::Fee* temp = fee_;
  fee_ = NULL;
  return temp;
}
inline ::pb::Fee* Stream::mutable_fee() {
  
  if (fee_ == NULL) {
    fee_ = new ::pb::Fee;
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.fee)
  return fee_;
}
inline void Stream::set_allocated_fee(::pb::Fee* fee) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete fee_;
  }
  if (fee) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      fee = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.fee)
}

// .pb.Image image = 16;
inline bool Stream::has_image() const {
  return type_case() == kImage;
}
inline void Stream::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Stream::clear_image() {
  if (has_image()) {
    delete type_.image_;
    clear_has_type();
  }
}
inline ::pb::Image* Stream::release_image() {
  // @@protoc_insertion_point(field_release:pb.Stream.image)
  if (has_image()) {
    clear_has_type();
      ::pb::Image* temp = type_.image_;
    type_.image_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pb::Image& Stream::image() const {
  // @@protoc_insertion_point(field_get:pb.Stream.image)
  return has_image()
      ? *type_.image_
      : *reinterpret_cast< ::pb::Image*>(&::pb::_Image_default_instance_);
}
inline ::pb::Image* Stream::mutable_image() {
  if (!has_image()) {
    clear_type();
    set_has_image();
    type_.image_ = new ::pb::Image;
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.image)
  return type_.image_;
}

// .pb.Video video = 17;
inline bool Stream::has_video() const {
  return type_case() == kVideo;
}
inline void Stream::set_has_video() {
  _oneof_case_[0] = kVideo;
}
inline void Stream::clear_video() {
  if (has_video()) {
    delete type_.video_;
    clear_has_type();
  }
}
inline ::pb::Video* Stream::release_video() {
  // @@protoc_insertion_point(field_release:pb.Stream.video)
  if (has_video()) {
    clear_has_type();
      ::pb::Video* temp = type_.video_;
    type_.video_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pb::Video& Stream::video() const {
  // @@protoc_insertion_point(field_get:pb.Stream.video)
  return has_video()
      ? *type_.video_
      : *reinterpret_cast< ::pb::Video*>(&::pb::_Video_default_instance_);
}
inline ::pb::Video* Stream::mutable_video() {
  if (!has_video()) {
    clear_type();
    set_has_video();
    type_.video_ = new ::pb::Video;
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.video)
  return type_.video_;
}

// .pb.Audio audio = 18;
inline bool Stream::has_audio() const {
  return type_case() == kAudio;
}
inline void Stream::set_has_audio() {
  _oneof_case_[0] = kAudio;
}
inline void Stream::clear_audio() {
  if (has_audio()) {
    delete type_.audio_;
    clear_has_type();
  }
}
inline ::pb::Audio* Stream::release_audio() {
  // @@protoc_insertion_point(field_release:pb.Stream.audio)
  if (has_audio()) {
    clear_has_type();
      ::pb::Audio* temp = type_.audio_;
    type_.audio_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::pb::Audio& Stream::audio() const {
  // @@protoc_insertion_point(field_get:pb.Stream.audio)
  return has_audio()
      ? *type_.audio_
      : *reinterpret_cast< ::pb::Audio*>(&::pb::_Audio_default_instance_);
}
inline ::pb::Audio* Stream::mutable_audio() {
  if (!has_audio()) {
    clear_type();
    set_has_audio();
    type_.audio_ = new ::pb::Audio;
  }
  // @@protoc_insertion_point(field_mutable:pb.Stream.audio)
  return type_.audio_;
}

inline bool Stream::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Stream::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Stream::TypeCase Stream::type_case() const {
  return Stream::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Fee

// .pb.Fee.Currency currency = 1;
inline void Fee::clear_currency() {
  currency_ = 0;
}
inline ::pb::Fee_Currency Fee::currency() const {
  // @@protoc_insertion_point(field_get:pb.Fee.currency)
  return static_cast< ::pb::Fee_Currency >(currency_);
}
inline void Fee::set_currency(::pb::Fee_Currency value) {
  
  currency_ = value;
  // @@protoc_insertion_point(field_set:pb.Fee.currency)
}

// bytes address = 2;
inline void Fee::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Fee::address() const {
  // @@protoc_insertion_point(field_get:pb.Fee.address)
  return address_.GetNoArena();
}
inline void Fee::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Fee.address)
}
#if LANG_CXX11
inline void Fee::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Fee.address)
}
#endif
inline void Fee::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Fee.address)
}
inline void Fee::set_address(const void* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Fee.address)
}
inline ::std::string* Fee::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:pb.Fee.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Fee::release_address() {
  // @@protoc_insertion_point(field_release:pb.Fee.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Fee::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:pb.Fee.address)
}

// uint64 amount = 3;
inline void Fee::clear_amount() {
  amount_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Fee::amount() const {
  // @@protoc_insertion_point(field_get:pb.Fee.amount)
  return amount_;
}
inline void Fee::set_amount(::google::protobuf::uint64 value) {
  
  amount_ = value;
  // @@protoc_insertion_point(field_set:pb.Fee.amount)
}

// -------------------------------------------------------------------

// File

// bytes hash = 3;
inline void File::clear_hash() {
  hash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::hash() const {
  // @@protoc_insertion_point(field_get:pb.File.hash)
  return hash_.GetNoArena();
}
inline void File::set_hash(const ::std::string& value) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.File.hash)
}
#if LANG_CXX11
inline void File::set_hash(::std::string&& value) {
  
  hash_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.File.hash)
}
#endif
inline void File::set_hash(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.File.hash)
}
inline void File::set_hash(const void* value, size_t size) {
  
  hash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.File.hash)
}
inline ::std::string* File::mutable_hash() {
  
  // @@protoc_insertion_point(field_mutable:pb.File.hash)
  return hash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_hash() {
  // @@protoc_insertion_point(field_release:pb.File.hash)
  
  return hash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_hash(::std::string* hash) {
  if (hash != NULL) {
    
  } else {
    
  }
  hash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hash);
  // @@protoc_insertion_point(field_set_allocated:pb.File.hash)
}

// string name = 1;
inline void File::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& File::name() const {
  // @@protoc_insertion_point(field_get:pb.File.name)
  return name_.GetNoArena();
}
inline void File::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.File.name)
}
#if LANG_CXX11
inline void File::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.File.name)
}
#endif
inline void File::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.File.name)
}
inline void File::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.File.name)
}
inline ::std::string* File::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.File.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* File::release_name() {
  // @@protoc_insertion_point(field_release:pb.File.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void File::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pb.File.name)
}

// uint64 size = 2;
inline void File::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 File::size() const {
  // @@protoc_insertion_point(field_get:pb.File.size)
  return size_;
}
inline void File::set_size(::google::protobuf::uint64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:pb.File.size)
}

// -------------------------------------------------------------------

// Image

// uint32 width = 1;
inline void Image::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:pb.Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:pb.Image.width)
}

// uint32 height = 2;
inline void Image::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:pb.Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:pb.Image.height)
}

// -------------------------------------------------------------------

// Video

// uint32 width = 1;
inline void Video::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 Video::width() const {
  // @@protoc_insertion_point(field_get:pb.Video.width)
  return width_;
}
inline void Video::set_width(::google::protobuf::uint32 value) {
  
  width_ = value;
  // @@protoc_insertion_point(field_set:pb.Video.width)
}

// uint32 height = 2;
inline void Video::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 Video::height() const {
  // @@protoc_insertion_point(field_get:pb.Video.height)
  return height_;
}
inline void Video::set_height(::google::protobuf::uint32 value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:pb.Video.height)
}

// uint32 duration = 3;
inline void Video::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Video::duration() const {
  // @@protoc_insertion_point(field_get:pb.Video.duration)
  return duration_;
}
inline void Video::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:pb.Video.duration)
}

// -------------------------------------------------------------------

// Audio

// uint32 duration = 1;
inline void Audio::clear_duration() {
  duration_ = 0u;
}
inline ::google::protobuf::uint32 Audio::duration() const {
  // @@protoc_insertion_point(field_get:pb.Audio.duration)
  return duration_;
}
inline void Audio::set_duration(::google::protobuf::uint32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:pb.Audio.duration)
}

// -------------------------------------------------------------------

// Language

// .pb.Language.Language language = 1;
inline void Language::clear_language() {
  language_ = 0;
}
inline ::pb::Language_Language Language::language() const {
  // @@protoc_insertion_point(field_get:pb.Language.language)
  return static_cast< ::pb::Language_Language >(language_);
}
inline void Language::set_language(::pb::Language_Language value) {
  
  language_ = value;
  // @@protoc_insertion_point(field_set:pb.Language.language)
}

// .pb.Language.Script script = 2;
inline void Language::clear_script() {
  script_ = 0;
}
inline ::pb::Language_Script Language::script() const {
  // @@protoc_insertion_point(field_get:pb.Language.script)
  return static_cast< ::pb::Language_Script >(script_);
}
inline void Language::set_script(::pb::Language_Script value) {
  
  script_ = value;
  // @@protoc_insertion_point(field_set:pb.Language.script)
}

// .pb.Location.Country region = 3;
inline void Language::clear_region() {
  region_ = 0;
}
inline ::pb::Location_Country Language::region() const {
  // @@protoc_insertion_point(field_get:pb.Language.region)
  return static_cast< ::pb::Location_Country >(region_);
}
inline void Language::set_region(::pb::Location_Country value) {
  
  region_ = value;
  // @@protoc_insertion_point(field_set:pb.Language.region)
}

// -------------------------------------------------------------------

// Location

// .pb.Location.Country country = 1;
inline void Location::clear_country() {
  country_ = 0;
}
inline ::pb::Location_Country Location::country() const {
  // @@protoc_insertion_point(field_get:pb.Location.country)
  return static_cast< ::pb::Location_Country >(country_);
}
inline void Location::set_country(::pb::Location_Country value) {
  
  country_ = value;
  // @@protoc_insertion_point(field_set:pb.Location.country)
}

// string state = 2;
inline void Location::clear_state() {
  state_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Location::state() const {
  // @@protoc_insertion_point(field_get:pb.Location.state)
  return state_.GetNoArena();
}
inline void Location::set_state(const ::std::string& value) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Location.state)
}
#if LANG_CXX11
inline void Location::set_state(::std::string&& value) {
  
  state_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.state)
}
#endif
inline void Location::set_state(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Location.state)
}
inline void Location::set_state(const char* value, size_t size) {
  
  state_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Location.state)
}
inline ::std::string* Location::mutable_state() {
  
  // @@protoc_insertion_point(field_mutable:pb.Location.state)
  return state_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_state() {
  // @@protoc_insertion_point(field_release:pb.Location.state)
  
  return state_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_state(::std::string* state) {
  if (state != NULL) {
    
  } else {
    
  }
  state_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), state);
  // @@protoc_insertion_point(field_set_allocated:pb.Location.state)
}

// string city = 3;
inline void Location::clear_city() {
  city_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Location::city() const {
  // @@protoc_insertion_point(field_get:pb.Location.city)
  return city_.GetNoArena();
}
inline void Location::set_city(const ::std::string& value) {
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Location.city)
}
#if LANG_CXX11
inline void Location::set_city(::std::string&& value) {
  
  city_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.city)
}
#endif
inline void Location::set_city(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Location.city)
}
inline void Location::set_city(const char* value, size_t size) {
  
  city_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Location.city)
}
inline ::std::string* Location::mutable_city() {
  
  // @@protoc_insertion_point(field_mutable:pb.Location.city)
  return city_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_city() {
  // @@protoc_insertion_point(field_release:pb.Location.city)
  
  return city_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_city(::std::string* city) {
  if (city != NULL) {
    
  } else {
    
  }
  city_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), city);
  // @@protoc_insertion_point(field_set_allocated:pb.Location.city)
}

// string code = 4;
inline void Location::clear_code() {
  code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Location::code() const {
  // @@protoc_insertion_point(field_get:pb.Location.code)
  return code_.GetNoArena();
}
inline void Location::set_code(const ::std::string& value) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Location.code)
}
#if LANG_CXX11
inline void Location::set_code(::std::string&& value) {
  
  code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.code)
}
#endif
inline void Location::set_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Location.code)
}
inline void Location::set_code(const char* value, size_t size) {
  
  code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Location.code)
}
inline ::std::string* Location::mutable_code() {
  
  // @@protoc_insertion_point(field_mutable:pb.Location.code)
  return code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Location::release_code() {
  // @@protoc_insertion_point(field_release:pb.Location.code)
  
  return code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Location::set_allocated_code(::std::string* code) {
  if (code != NULL) {
    
  } else {
    
  }
  code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), code);
  // @@protoc_insertion_point(field_set_allocated:pb.Location.code)
}

// sint32 latitude = 5;
inline void Location::clear_latitude() {
  latitude_ = 0;
}
inline ::google::protobuf::int32 Location::latitude() const {
  // @@protoc_insertion_point(field_get:pb.Location.latitude)
  return latitude_;
}
inline void Location::set_latitude(::google::protobuf::int32 value) {
  
  latitude_ = value;
  // @@protoc_insertion_point(field_set:pb.Location.latitude)
}

// sint32 longitude = 6;
inline void Location::clear_longitude() {
  longitude_ = 0;
}
inline ::google::protobuf::int32 Location::longitude() const {
  // @@protoc_insertion_point(field_get:pb.Location.longitude)
  return longitude_;
}
inline void Location::set_longitude(::google::protobuf::int32 value) {
  
  longitude_ = value;
  // @@protoc_insertion_point(field_set:pb.Location.longitude)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::Fee_Currency> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Fee_Currency>() {
  return ::pb::Fee_Currency_descriptor();
}
template <> struct is_proto_enum< ::pb::Language_Language> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Language_Language>() {
  return ::pb::Language_Language_descriptor();
}
template <> struct is_proto_enum< ::pb::Language_Script> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Language_Script>() {
  return ::pb::Language_Script_descriptor();
}
template <> struct is_proto_enum< ::pb::Location_Country> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Location_Country>() {
  return ::pb::Location_Country_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_claim_2eproto__INCLUDED
