// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: claim.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_claim_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_claim_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3015000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3015008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_claim_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_claim_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[13]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_claim_2eproto;
::PROTOBUF_NAMESPACE_ID::Metadata descriptor_table_claim_2eproto_metadata_getter(int index);
namespace pb {
class Audio;
struct AudioDefaultTypeInternal;
extern AudioDefaultTypeInternal _Audio_default_instance_;
class Channel;
struct ChannelDefaultTypeInternal;
extern ChannelDefaultTypeInternal _Channel_default_instance_;
class Claim;
struct ClaimDefaultTypeInternal;
extern ClaimDefaultTypeInternal _Claim_default_instance_;
class ClaimList;
struct ClaimListDefaultTypeInternal;
extern ClaimListDefaultTypeInternal _ClaimList_default_instance_;
class ClaimReference;
struct ClaimReferenceDefaultTypeInternal;
extern ClaimReferenceDefaultTypeInternal _ClaimReference_default_instance_;
class Fee;
struct FeeDefaultTypeInternal;
extern FeeDefaultTypeInternal _Fee_default_instance_;
class Image;
struct ImageDefaultTypeInternal;
extern ImageDefaultTypeInternal _Image_default_instance_;
class Language;
struct LanguageDefaultTypeInternal;
extern LanguageDefaultTypeInternal _Language_default_instance_;
class Location;
struct LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Software;
struct SoftwareDefaultTypeInternal;
extern SoftwareDefaultTypeInternal _Software_default_instance_;
class Source;
struct SourceDefaultTypeInternal;
extern SourceDefaultTypeInternal _Source_default_instance_;
class Stream;
struct StreamDefaultTypeInternal;
extern StreamDefaultTypeInternal _Stream_default_instance_;
class Video;
struct VideoDefaultTypeInternal;
extern VideoDefaultTypeInternal _Video_default_instance_;
}  // namespace pb
PROTOBUF_NAMESPACE_OPEN
template<> ::pb::Audio* Arena::CreateMaybeMessage<::pb::Audio>(Arena*);
template<> ::pb::Channel* Arena::CreateMaybeMessage<::pb::Channel>(Arena*);
template<> ::pb::Claim* Arena::CreateMaybeMessage<::pb::Claim>(Arena*);
template<> ::pb::ClaimList* Arena::CreateMaybeMessage<::pb::ClaimList>(Arena*);
template<> ::pb::ClaimReference* Arena::CreateMaybeMessage<::pb::ClaimReference>(Arena*);
template<> ::pb::Fee* Arena::CreateMaybeMessage<::pb::Fee>(Arena*);
template<> ::pb::Image* Arena::CreateMaybeMessage<::pb::Image>(Arena*);
template<> ::pb::Language* Arena::CreateMaybeMessage<::pb::Language>(Arena*);
template<> ::pb::Location* Arena::CreateMaybeMessage<::pb::Location>(Arena*);
template<> ::pb::Software* Arena::CreateMaybeMessage<::pb::Software>(Arena*);
template<> ::pb::Source* Arena::CreateMaybeMessage<::pb::Source>(Arena*);
template<> ::pb::Stream* Arena::CreateMaybeMessage<::pb::Stream>(Arena*);
template<> ::pb::Video* Arena::CreateMaybeMessage<::pb::Video>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pb {

enum ClaimList_ListType : int {
  ClaimList_ListType_COLLECTION = 0,
  ClaimList_ListType_DERIVATION = 2,
  ClaimList_ListType_ClaimList_ListType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ClaimList_ListType_ClaimList_ListType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ClaimList_ListType_IsValid(int value);
constexpr ClaimList_ListType ClaimList_ListType_ListType_MIN = ClaimList_ListType_COLLECTION;
constexpr ClaimList_ListType ClaimList_ListType_ListType_MAX = ClaimList_ListType_DERIVATION;
constexpr int ClaimList_ListType_ListType_ARRAYSIZE = ClaimList_ListType_ListType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ClaimList_ListType_descriptor();
template<typename T>
inline const std::string& ClaimList_ListType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ClaimList_ListType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ClaimList_ListType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ClaimList_ListType_descriptor(), enum_t_value);
}
inline bool ClaimList_ListType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ClaimList_ListType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ClaimList_ListType>(
    ClaimList_ListType_descriptor(), name, value);
}
enum Fee_Currency : int {
  Fee_Currency_UNKNOWN_CURRENCY = 0,
  Fee_Currency_LBC = 1,
  Fee_Currency_BTC = 2,
  Fee_Currency_USD = 3,
  Fee_Currency_Fee_Currency_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Fee_Currency_Fee_Currency_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Fee_Currency_IsValid(int value);
constexpr Fee_Currency Fee_Currency_Currency_MIN = Fee_Currency_UNKNOWN_CURRENCY;
constexpr Fee_Currency Fee_Currency_Currency_MAX = Fee_Currency_USD;
constexpr int Fee_Currency_Currency_ARRAYSIZE = Fee_Currency_Currency_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Fee_Currency_descriptor();
template<typename T>
inline const std::string& Fee_Currency_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Fee_Currency>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Fee_Currency_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Fee_Currency_descriptor(), enum_t_value);
}
inline bool Fee_Currency_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Fee_Currency* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Fee_Currency>(
    Fee_Currency_descriptor(), name, value);
}
enum Software_OS : int {
  Software_OS_UNKNOWN_OS = 0,
  Software_OS_ANY = 1,
  Software_OS_LINUX = 2,
  Software_OS_WINDOWS = 3,
  Software_OS_MAC = 4,
  Software_OS_ANDROID = 5,
  Software_OS_IOS = 6,
  Software_OS_Software_OS_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Software_OS_Software_OS_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Software_OS_IsValid(int value);
constexpr Software_OS Software_OS_OS_MIN = Software_OS_UNKNOWN_OS;
constexpr Software_OS Software_OS_OS_MAX = Software_OS_IOS;
constexpr int Software_OS_OS_ARRAYSIZE = Software_OS_OS_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Software_OS_descriptor();
template<typename T>
inline const std::string& Software_OS_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Software_OS>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Software_OS_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Software_OS_descriptor(), enum_t_value);
}
inline bool Software_OS_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Software_OS* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Software_OS>(
    Software_OS_descriptor(), name, value);
}
enum Language_Language : int {
  Language_Language_UNKNOWN_LANGUAGE = 0,
  Language_Language_en = 1,
  Language_Language_aa = 2,
  Language_Language_ab = 3,
  Language_Language_ae = 4,
  Language_Language_af = 5,
  Language_Language_ak = 6,
  Language_Language_am = 7,
  Language_Language_an = 8,
  Language_Language_ar = 9,
  Language_Language_as = 10,
  Language_Language_av = 11,
  Language_Language_ay = 12,
  Language_Language_az = 13,
  Language_Language_ba = 14,
  Language_Language_be = 15,
  Language_Language_bg = 16,
  Language_Language_bh = 17,
  Language_Language_bi = 18,
  Language_Language_bm = 19,
  Language_Language_bn = 20,
  Language_Language_bo = 21,
  Language_Language_br = 22,
  Language_Language_bs = 23,
  Language_Language_ca = 24,
  Language_Language_ce = 25,
  Language_Language_ch = 26,
  Language_Language_co = 27,
  Language_Language_cr = 28,
  Language_Language_cs = 29,
  Language_Language_cu = 30,
  Language_Language_cv = 31,
  Language_Language_cy = 32,
  Language_Language_da = 33,
  Language_Language_de = 34,
  Language_Language_dv = 35,
  Language_Language_dz = 36,
  Language_Language_ee = 37,
  Language_Language_el = 38,
  Language_Language_eo = 39,
  Language_Language_es = 40,
  Language_Language_et = 41,
  Language_Language_eu = 42,
  Language_Language_fa = 43,
  Language_Language_ff = 44,
  Language_Language_fi = 45,
  Language_Language_fj = 46,
  Language_Language_fo = 47,
  Language_Language_fr = 48,
  Language_Language_fy = 49,
  Language_Language_ga = 50,
  Language_Language_gd = 51,
  Language_Language_gl = 52,
  Language_Language_gn = 53,
  Language_Language_gu = 54,
  Language_Language_gv = 55,
  Language_Language_ha = 56,
  Language_Language_he = 57,
  Language_Language_hi = 58,
  Language_Language_ho = 59,
  Language_Language_hr = 60,
  Language_Language_ht = 61,
  Language_Language_hu = 62,
  Language_Language_hy = 63,
  Language_Language_hz = 64,
  Language_Language_ia = 65,
  Language_Language_id = 66,
  Language_Language_ie = 67,
  Language_Language_ig = 68,
  Language_Language_ii = 69,
  Language_Language_ik = 70,
  Language_Language_io = 71,
  Language_Language_is = 72,
  Language_Language_it = 73,
  Language_Language_iu = 74,
  Language_Language_ja = 75,
  Language_Language_jv = 76,
  Language_Language_ka = 77,
  Language_Language_kg = 78,
  Language_Language_ki = 79,
  Language_Language_kj = 80,
  Language_Language_kk = 81,
  Language_Language_kl = 82,
  Language_Language_km = 83,
  Language_Language_kn = 84,
  Language_Language_ko = 85,
  Language_Language_kr = 86,
  Language_Language_ks = 87,
  Language_Language_ku = 88,
  Language_Language_kv = 89,
  Language_Language_kw = 90,
  Language_Language_ky = 91,
  Language_Language_la = 92,
  Language_Language_lb = 93,
  Language_Language_lg = 94,
  Language_Language_li = 95,
  Language_Language_ln = 96,
  Language_Language_lo = 97,
  Language_Language_lt = 98,
  Language_Language_lu = 99,
  Language_Language_lv = 100,
  Language_Language_mg = 101,
  Language_Language_mh = 102,
  Language_Language_mi = 103,
  Language_Language_mk = 104,
  Language_Language_ml = 105,
  Language_Language_mn = 106,
  Language_Language_mr = 107,
  Language_Language_ms = 108,
  Language_Language_mt = 109,
  Language_Language_my = 110,
  Language_Language_na = 111,
  Language_Language_nb = 112,
  Language_Language_nd = 113,
  Language_Language_ne = 114,
  Language_Language_ng = 115,
  Language_Language_nl = 116,
  Language_Language_nn = 117,
  Language_Language_no = 118,
  Language_Language_nr = 119,
  Language_Language_nv = 120,
  Language_Language_ny = 121,
  Language_Language_oc = 122,
  Language_Language_oj = 123,
  Language_Language_om = 124,
  Language_Language_or_ = 125,
  Language_Language_os = 126,
  Language_Language_pa = 127,
  Language_Language_pi = 128,
  Language_Language_pl = 129,
  Language_Language_ps = 130,
  Language_Language_pt = 131,
  Language_Language_qu = 132,
  Language_Language_rm = 133,
  Language_Language_rn = 134,
  Language_Language_ro = 135,
  Language_Language_ru = 136,
  Language_Language_rw = 137,
  Language_Language_sa = 138,
  Language_Language_sc = 139,
  Language_Language_sd = 140,
  Language_Language_se = 141,
  Language_Language_sg = 142,
  Language_Language_si = 143,
  Language_Language_sk = 144,
  Language_Language_sl = 145,
  Language_Language_sm = 146,
  Language_Language_sn = 147,
  Language_Language_so = 148,
  Language_Language_sq = 149,
  Language_Language_sr = 150,
  Language_Language_ss = 151,
  Language_Language_st = 152,
  Language_Language_su = 153,
  Language_Language_sv = 154,
  Language_Language_sw = 155,
  Language_Language_ta = 156,
  Language_Language_te = 157,
  Language_Language_tg = 158,
  Language_Language_th = 159,
  Language_Language_ti = 160,
  Language_Language_tk = 161,
  Language_Language_tl = 162,
  Language_Language_tn = 163,
  Language_Language_to = 164,
  Language_Language_tr = 165,
  Language_Language_ts = 166,
  Language_Language_tt = 167,
  Language_Language_tw = 168,
  Language_Language_ty = 169,
  Language_Language_ug = 170,
  Language_Language_uk = 171,
  Language_Language_ur = 172,
  Language_Language_uz = 173,
  Language_Language_ve = 174,
  Language_Language_vi = 175,
  Language_Language_vo = 176,
  Language_Language_wa = 177,
  Language_Language_wo = 178,
  Language_Language_xh = 179,
  Language_Language_yi = 180,
  Language_Language_yo = 181,
  Language_Language_za = 182,
  Language_Language_zh = 183,
  Language_Language_zu = 184,
  Language_Language_Language_Language_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Language_Language_Language_Language_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Language_Language_IsValid(int value);
constexpr Language_Language Language_Language_Language_MIN = Language_Language_UNKNOWN_LANGUAGE;
constexpr Language_Language Language_Language_Language_MAX = Language_Language_zu;
constexpr int Language_Language_Language_ARRAYSIZE = Language_Language_Language_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_Language_descriptor();
template<typename T>
inline const std::string& Language_Language_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Language_Language>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Language_Language_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Language_Language_descriptor(), enum_t_value);
}
inline bool Language_Language_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Language_Language* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Language_Language>(
    Language_Language_descriptor(), name, value);
}
enum Language_Script : int {
  Language_Script_UNKNOWN_SCRIPT = 0,
  Language_Script_Adlm = 1,
  Language_Script_Afak = 2,
  Language_Script_Aghb = 3,
  Language_Script_Ahom = 4,
  Language_Script_Arab = 5,
  Language_Script_Aran = 6,
  Language_Script_Armi = 7,
  Language_Script_Armn = 8,
  Language_Script_Avst = 9,
  Language_Script_Bali = 10,
  Language_Script_Bamu = 11,
  Language_Script_Bass = 12,
  Language_Script_Batk = 13,
  Language_Script_Beng = 14,
  Language_Script_Bhks = 15,
  Language_Script_Blis = 16,
  Language_Script_Bopo = 17,
  Language_Script_Brah = 18,
  Language_Script_Brai = 19,
  Language_Script_Bugi = 20,
  Language_Script_Buhd = 21,
  Language_Script_Cakm = 22,
  Language_Script_Cans = 23,
  Language_Script_Cari = 24,
  Language_Script_Cham = 25,
  Language_Script_Cher = 26,
  Language_Script_Cirt = 27,
  Language_Script_Copt = 28,
  Language_Script_Cpmn = 29,
  Language_Script_Cprt = 30,
  Language_Script_Cyrl = 31,
  Language_Script_Cyrs = 32,
  Language_Script_Deva = 33,
  Language_Script_Dogr = 34,
  Language_Script_Dsrt = 35,
  Language_Script_Dupl = 36,
  Language_Script_Egyd = 37,
  Language_Script_Egyh = 38,
  Language_Script_Egyp = 39,
  Language_Script_Elba = 40,
  Language_Script_Elym = 41,
  Language_Script_Ethi = 42,
  Language_Script_Geok = 43,
  Language_Script_Geor = 44,
  Language_Script_Glag = 45,
  Language_Script_Gong = 46,
  Language_Script_Gonm = 47,
  Language_Script_Goth = 48,
  Language_Script_Gran = 49,
  Language_Script_Grek = 50,
  Language_Script_Gujr = 51,
  Language_Script_Guru = 52,
  Language_Script_Hanb = 53,
  Language_Script_Hang = 54,
  Language_Script_Hani = 55,
  Language_Script_Hano = 56,
  Language_Script_Hans = 57,
  Language_Script_Hant = 58,
  Language_Script_Hatr = 59,
  Language_Script_Hebr = 60,
  Language_Script_Hira = 61,
  Language_Script_Hluw = 62,
  Language_Script_Hmng = 63,
  Language_Script_Hmnp = 64,
  Language_Script_Hrkt = 65,
  Language_Script_Hung = 66,
  Language_Script_Inds = 67,
  Language_Script_Ital = 68,
  Language_Script_Jamo = 69,
  Language_Script_Java = 70,
  Language_Script_Jpan = 71,
  Language_Script_Jurc = 72,
  Language_Script_Kali = 73,
  Language_Script_Kana = 74,
  Language_Script_Khar = 75,
  Language_Script_Khmr = 76,
  Language_Script_Khoj = 77,
  Language_Script_Kitl = 78,
  Language_Script_Kits = 79,
  Language_Script_Knda = 80,
  Language_Script_Kore = 81,
  Language_Script_Kpel = 82,
  Language_Script_Kthi = 83,
  Language_Script_Lana = 84,
  Language_Script_Laoo = 85,
  Language_Script_Latf = 86,
  Language_Script_Latg = 87,
  Language_Script_Latn = 88,
  Language_Script_Leke = 89,
  Language_Script_Lepc = 90,
  Language_Script_Limb = 91,
  Language_Script_Lina = 92,
  Language_Script_Linb = 93,
  Language_Script_Lisu = 94,
  Language_Script_Loma = 95,
  Language_Script_Lyci = 96,
  Language_Script_Lydi = 97,
  Language_Script_Mahj = 98,
  Language_Script_Maka = 99,
  Language_Script_Mand = 100,
  Language_Script_Mani = 101,
  Language_Script_Marc = 102,
  Language_Script_Maya = 103,
  Language_Script_Medf = 104,
  Language_Script_Mend = 105,
  Language_Script_Merc = 106,
  Language_Script_Mero = 107,
  Language_Script_Mlym = 108,
  Language_Script_Modi = 109,
  Language_Script_Mong = 110,
  Language_Script_Moon = 111,
  Language_Script_Mroo = 112,
  Language_Script_Mtei = 113,
  Language_Script_Mult = 114,
  Language_Script_Mymr = 115,
  Language_Script_Nand = 116,
  Language_Script_Narb = 117,
  Language_Script_Nbat = 118,
  Language_Script_Newa = 119,
  Language_Script_Nkdb = 120,
  Language_Script_Nkgb = 121,
  Language_Script_Nkoo = 122,
  Language_Script_Nshu = 123,
  Language_Script_Ogam = 124,
  Language_Script_Olck = 125,
  Language_Script_Orkh = 126,
  Language_Script_Orya = 127,
  Language_Script_Osge = 128,
  Language_Script_Osma = 129,
  Language_Script_Palm = 130,
  Language_Script_Pauc = 131,
  Language_Script_Perm = 132,
  Language_Script_Phag = 133,
  Language_Script_Phli = 134,
  Language_Script_Phlp = 135,
  Language_Script_Phlv = 136,
  Language_Script_Phnx = 137,
  Language_Script_Plrd = 138,
  Language_Script_Piqd = 139,
  Language_Script_Prti = 140,
  Language_Script_Qaaa = 141,
  Language_Script_Qabx = 142,
  Language_Script_Rjng = 143,
  Language_Script_Rohg = 144,
  Language_Script_Roro = 145,
  Language_Script_Runr = 146,
  Language_Script_Samr = 147,
  Language_Script_Sara = 148,
  Language_Script_Sarb = 149,
  Language_Script_Saur = 150,
  Language_Script_Sgnw = 151,
  Language_Script_Shaw = 152,
  Language_Script_Shrd = 153,
  Language_Script_Shui = 154,
  Language_Script_Sidd = 155,
  Language_Script_Sind = 156,
  Language_Script_Sinh = 157,
  Language_Script_Sogd = 158,
  Language_Script_Sogo = 159,
  Language_Script_Sora = 160,
  Language_Script_Soyo = 161,
  Language_Script_Sund = 162,
  Language_Script_Sylo = 163,
  Language_Script_Syrc = 164,
  Language_Script_Syre = 165,
  Language_Script_Syrj = 166,
  Language_Script_Syrn = 167,
  Language_Script_Tagb = 168,
  Language_Script_Takr = 169,
  Language_Script_Tale = 170,
  Language_Script_Talu = 171,
  Language_Script_Taml = 172,
  Language_Script_Tang = 173,
  Language_Script_Tavt = 174,
  Language_Script_Telu = 175,
  Language_Script_Teng = 176,
  Language_Script_Tfng = 177,
  Language_Script_Tglg = 178,
  Language_Script_Thaa = 179,
  Language_Script_Thai = 180,
  Language_Script_Tibt = 181,
  Language_Script_Tirh = 182,
  Language_Script_Ugar = 183,
  Language_Script_Vaii = 184,
  Language_Script_Visp = 185,
  Language_Script_Wara = 186,
  Language_Script_Wcho = 187,
  Language_Script_Wole = 188,
  Language_Script_Xpeo = 189,
  Language_Script_Xsux = 190,
  Language_Script_Yiii = 191,
  Language_Script_Zanb = 192,
  Language_Script_Zinh = 193,
  Language_Script_Zmth = 194,
  Language_Script_Zsye = 195,
  Language_Script_Zsym = 196,
  Language_Script_Zxxx = 197,
  Language_Script_Zyyy = 198,
  Language_Script_Zzzz = 199,
  Language_Script_Language_Script_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Language_Script_Language_Script_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Language_Script_IsValid(int value);
constexpr Language_Script Language_Script_Script_MIN = Language_Script_UNKNOWN_SCRIPT;
constexpr Language_Script Language_Script_Script_MAX = Language_Script_Zzzz;
constexpr int Language_Script_Script_ARRAYSIZE = Language_Script_Script_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Language_Script_descriptor();
template<typename T>
inline const std::string& Language_Script_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Language_Script>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Language_Script_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Language_Script_descriptor(), enum_t_value);
}
inline bool Language_Script_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Language_Script* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Language_Script>(
    Language_Script_descriptor(), name, value);
}
enum Location_Country : int {
  Location_Country_UNKNOWN_COUNTRY = 0,
  Location_Country_AF = 1,
  Location_Country_AX = 2,
  Location_Country_AL = 3,
  Location_Country_DZ = 4,
  Location_Country_AS = 5,
  Location_Country_AD = 6,
  Location_Country_AO = 7,
  Location_Country_AI = 8,
  Location_Country_AQ = 9,
  Location_Country_AG = 10,
  Location_Country_AR = 11,
  Location_Country_AM = 12,
  Location_Country_AW = 13,
  Location_Country_AU = 14,
  Location_Country_AT = 15,
  Location_Country_AZ = 16,
  Location_Country_BS = 17,
  Location_Country_BH = 18,
  Location_Country_BD = 19,
  Location_Country_BB = 20,
  Location_Country_BY = 21,
  Location_Country_BE = 22,
  Location_Country_BZ = 23,
  Location_Country_BJ = 24,
  Location_Country_BM = 25,
  Location_Country_BT = 26,
  Location_Country_BO = 27,
  Location_Country_BQ = 28,
  Location_Country_BA = 29,
  Location_Country_BW = 30,
  Location_Country_BV = 31,
  Location_Country_BR = 32,
  Location_Country_IO = 33,
  Location_Country_BN = 34,
  Location_Country_BG = 35,
  Location_Country_BF = 36,
  Location_Country_BI = 37,
  Location_Country_KH = 38,
  Location_Country_CM = 39,
  Location_Country_CA = 40,
  Location_Country_CV = 41,
  Location_Country_KY = 42,
  Location_Country_CF = 43,
  Location_Country_TD = 44,
  Location_Country_CL = 45,
  Location_Country_CN = 46,
  Location_Country_CX = 47,
  Location_Country_CC = 48,
  Location_Country_CO = 49,
  Location_Country_KM = 50,
  Location_Country_CG = 51,
  Location_Country_CD = 52,
  Location_Country_CK = 53,
  Location_Country_CR = 54,
  Location_Country_CI = 55,
  Location_Country_HR = 56,
  Location_Country_CU = 57,
  Location_Country_CW = 58,
  Location_Country_CY = 59,
  Location_Country_CZ = 60,
  Location_Country_DK = 61,
  Location_Country_DJ = 62,
  Location_Country_DM = 63,
  Location_Country_DO = 64,
  Location_Country_EC = 65,
  Location_Country_EG = 66,
  Location_Country_SV = 67,
  Location_Country_GQ = 68,
  Location_Country_ER = 69,
  Location_Country_EE = 70,
  Location_Country_ET = 71,
  Location_Country_FK = 72,
  Location_Country_FO = 73,
  Location_Country_FJ = 74,
  Location_Country_FI = 75,
  Location_Country_FR = 76,
  Location_Country_GF = 77,
  Location_Country_PF = 78,
  Location_Country_TF = 79,
  Location_Country_GA = 80,
  Location_Country_GM = 81,
  Location_Country_GE = 82,
  Location_Country_DE = 83,
  Location_Country_GH = 84,
  Location_Country_GI = 85,
  Location_Country_GR = 86,
  Location_Country_GL = 87,
  Location_Country_GD = 88,
  Location_Country_GP = 89,
  Location_Country_GU = 90,
  Location_Country_GT = 91,
  Location_Country_GG = 92,
  Location_Country_GN = 93,
  Location_Country_GW = 94,
  Location_Country_GY = 95,
  Location_Country_HT = 96,
  Location_Country_HM = 97,
  Location_Country_VA = 98,
  Location_Country_HN = 99,
  Location_Country_HK = 100,
  Location_Country_HU = 101,
  Location_Country_IS = 102,
  Location_Country_IN = 103,
  Location_Country_ID = 104,
  Location_Country_IR = 105,
  Location_Country_IQ = 106,
  Location_Country_IE = 107,
  Location_Country_IM = 108,
  Location_Country_IL = 109,
  Location_Country_IT = 110,
  Location_Country_JM = 111,
  Location_Country_JP = 112,
  Location_Country_JE = 113,
  Location_Country_JO = 114,
  Location_Country_KZ = 115,
  Location_Country_KE = 116,
  Location_Country_KI = 117,
  Location_Country_KP = 118,
  Location_Country_KR = 119,
  Location_Country_KW = 120,
  Location_Country_KG = 121,
  Location_Country_LA = 122,
  Location_Country_LV = 123,
  Location_Country_LB = 124,
  Location_Country_LS = 125,
  Location_Country_LR = 126,
  Location_Country_LY = 127,
  Location_Country_LI = 128,
  Location_Country_LT = 129,
  Location_Country_LU = 130,
  Location_Country_MO = 131,
  Location_Country_MK = 132,
  Location_Country_MG = 133,
  Location_Country_MW = 134,
  Location_Country_MY = 135,
  Location_Country_MV = 136,
  Location_Country_ML = 137,
  Location_Country_MT = 138,
  Location_Country_MH = 139,
  Location_Country_MQ = 140,
  Location_Country_MR = 141,
  Location_Country_MU = 142,
  Location_Country_YT = 143,
  Location_Country_MX = 144,
  Location_Country_FM = 145,
  Location_Country_MD = 146,
  Location_Country_MC = 147,
  Location_Country_MN = 148,
  Location_Country_ME = 149,
  Location_Country_MS = 150,
  Location_Country_MA = 151,
  Location_Country_MZ = 152,
  Location_Country_MM = 153,
  Location_Country_NA = 154,
  Location_Country_NR = 155,
  Location_Country_NP = 156,
  Location_Country_NL = 157,
  Location_Country_NC = 158,
  Location_Country_NZ = 159,
  Location_Country_NI = 160,
  Location_Country_NE = 161,
  Location_Country_NG = 162,
  Location_Country_NU = 163,
  Location_Country_NF = 164,
  Location_Country_MP = 165,
  Location_Country_NO = 166,
  Location_Country_OM = 167,
  Location_Country_PK = 168,
  Location_Country_PW = 169,
  Location_Country_PS = 170,
  Location_Country_PA = 171,
  Location_Country_PG = 172,
  Location_Country_PY = 173,
  Location_Country_PE = 174,
  Location_Country_PH = 175,
  Location_Country_PN = 176,
  Location_Country_PL = 177,
  Location_Country_PT = 178,
  Location_Country_PR = 179,
  Location_Country_QA = 180,
  Location_Country_RE = 181,
  Location_Country_RO = 182,
  Location_Country_RU = 183,
  Location_Country_RW = 184,
  Location_Country_BL = 185,
  Location_Country_SH = 186,
  Location_Country_KN = 187,
  Location_Country_LC = 188,
  Location_Country_MF = 189,
  Location_Country_PM = 190,
  Location_Country_VC = 191,
  Location_Country_WS = 192,
  Location_Country_SM = 193,
  Location_Country_ST = 194,
  Location_Country_SA = 195,
  Location_Country_SN = 196,
  Location_Country_RS = 197,
  Location_Country_SC = 198,
  Location_Country_SL = 199,
  Location_Country_SG = 200,
  Location_Country_SX = 201,
  Location_Country_SK = 202,
  Location_Country_SI = 203,
  Location_Country_SB = 204,
  Location_Country_SO = 205,
  Location_Country_ZA = 206,
  Location_Country_GS = 207,
  Location_Country_SS = 208,
  Location_Country_ES = 209,
  Location_Country_LK = 210,
  Location_Country_SD = 211,
  Location_Country_SR = 212,
  Location_Country_SJ = 213,
  Location_Country_SZ = 214,
  Location_Country_SE = 215,
  Location_Country_CH = 216,
  Location_Country_SY = 217,
  Location_Country_TW = 218,
  Location_Country_TJ = 219,
  Location_Country_TZ = 220,
  Location_Country_TH = 221,
  Location_Country_TL = 222,
  Location_Country_TG = 223,
  Location_Country_TK = 224,
  Location_Country_TO = 225,
  Location_Country_TT = 226,
  Location_Country_TN = 227,
  Location_Country_TR = 228,
  Location_Country_TM = 229,
  Location_Country_TC = 230,
  Location_Country_TV = 231,
  Location_Country_UG = 232,
  Location_Country_UA = 233,
  Location_Country_AE = 234,
  Location_Country_GB = 235,
  Location_Country_US = 236,
  Location_Country_UM = 237,
  Location_Country_UY = 238,
  Location_Country_UZ = 239,
  Location_Country_VU = 240,
  Location_Country_VE = 241,
  Location_Country_VN = 242,
  Location_Country_VG = 243,
  Location_Country_VI = 244,
  Location_Country_WF = 245,
  Location_Country_EH = 246,
  Location_Country_YE = 247,
  Location_Country_ZM = 248,
  Location_Country_ZW = 249,
  Location_Country_R001 = 250,
  Location_Country_R002 = 251,
  Location_Country_R015 = 252,
  Location_Country_R012 = 253,
  Location_Country_R818 = 254,
  Location_Country_R434 = 255,
  Location_Country_R504 = 256,
  Location_Country_R729 = 257,
  Location_Country_R788 = 258,
  Location_Country_R732 = 259,
  Location_Country_R202 = 260,
  Location_Country_R014 = 261,
  Location_Country_R086 = 262,
  Location_Country_R108 = 263,
  Location_Country_R174 = 264,
  Location_Country_R262 = 265,
  Location_Country_R232 = 266,
  Location_Country_R231 = 267,
  Location_Country_R260 = 268,
  Location_Country_R404 = 269,
  Location_Country_R450 = 270,
  Location_Country_R454 = 271,
  Location_Country_R480 = 272,
  Location_Country_R175 = 273,
  Location_Country_R508 = 274,
  Location_Country_R638 = 275,
  Location_Country_R646 = 276,
  Location_Country_R690 = 277,
  Location_Country_R706 = 278,
  Location_Country_R728 = 279,
  Location_Country_R800 = 280,
  Location_Country_R834 = 281,
  Location_Country_R894 = 282,
  Location_Country_R716 = 283,
  Location_Country_R017 = 284,
  Location_Country_R024 = 285,
  Location_Country_R120 = 286,
  Location_Country_R140 = 287,
  Location_Country_R148 = 288,
  Location_Country_R178 = 289,
  Location_Country_R180 = 290,
  Location_Country_R226 = 291,
  Location_Country_R266 = 292,
  Location_Country_R678 = 293,
  Location_Country_R018 = 294,
  Location_Country_R072 = 295,
  Location_Country_R748 = 296,
  Location_Country_R426 = 297,
  Location_Country_R516 = 298,
  Location_Country_R710 = 299,
  Location_Country_R011 = 300,
  Location_Country_R204 = 301,
  Location_Country_R854 = 302,
  Location_Country_R132 = 303,
  Location_Country_R384 = 304,
  Location_Country_R270 = 305,
  Location_Country_R288 = 306,
  Location_Country_R324 = 307,
  Location_Country_R624 = 308,
  Location_Country_R430 = 309,
  Location_Country_R466 = 310,
  Location_Country_R478 = 311,
  Location_Country_R562 = 312,
  Location_Country_R566 = 313,
  Location_Country_R654 = 314,
  Location_Country_R686 = 315,
  Location_Country_R694 = 316,
  Location_Country_R768 = 317,
  Location_Country_R019 = 318,
  Location_Country_R419 = 319,
  Location_Country_R029 = 320,
  Location_Country_R660 = 321,
  Location_Country_R028 = 322,
  Location_Country_R533 = 323,
  Location_Country_R044 = 324,
  Location_Country_R052 = 325,
  Location_Country_R535 = 326,
  Location_Country_R092 = 327,
  Location_Country_R136 = 328,
  Location_Country_R192 = 329,
  Location_Country_R531 = 330,
  Location_Country_R212 = 331,
  Location_Country_R214 = 332,
  Location_Country_R308 = 333,
  Location_Country_R312 = 334,
  Location_Country_R332 = 335,
  Location_Country_R388 = 336,
  Location_Country_R474 = 337,
  Location_Country_R500 = 338,
  Location_Country_R630 = 339,
  Location_Country_R652 = 340,
  Location_Country_R659 = 341,
  Location_Country_R662 = 342,
  Location_Country_R663 = 343,
  Location_Country_R670 = 344,
  Location_Country_R534 = 345,
  Location_Country_R780 = 346,
  Location_Country_R796 = 347,
  Location_Country_R850 = 348,
  Location_Country_R013 = 349,
  Location_Country_R084 = 350,
  Location_Country_R188 = 351,
  Location_Country_R222 = 352,
  Location_Country_R320 = 353,
  Location_Country_R340 = 354,
  Location_Country_R484 = 355,
  Location_Country_R558 = 356,
  Location_Country_R591 = 357,
  Location_Country_R005 = 358,
  Location_Country_R032 = 359,
  Location_Country_R068 = 360,
  Location_Country_R074 = 361,
  Location_Country_R076 = 362,
  Location_Country_R152 = 363,
  Location_Country_R170 = 364,
  Location_Country_R218 = 365,
  Location_Country_R238 = 366,
  Location_Country_R254 = 367,
  Location_Country_R328 = 368,
  Location_Country_R600 = 369,
  Location_Country_R604 = 370,
  Location_Country_R239 = 371,
  Location_Country_R740 = 372,
  Location_Country_R858 = 373,
  Location_Country_R862 = 374,
  Location_Country_R021 = 375,
  Location_Country_R060 = 376,
  Location_Country_R124 = 377,
  Location_Country_R304 = 378,
  Location_Country_R666 = 379,
  Location_Country_R840 = 380,
  Location_Country_R010 = 381,
  Location_Country_R142 = 382,
  Location_Country_R143 = 383,
  Location_Country_R398 = 384,
  Location_Country_R417 = 385,
  Location_Country_R762 = 386,
  Location_Country_R795 = 387,
  Location_Country_R860 = 388,
  Location_Country_R030 = 389,
  Location_Country_R156 = 390,
  Location_Country_R344 = 391,
  Location_Country_R446 = 392,
  Location_Country_R408 = 393,
  Location_Country_R392 = 394,
  Location_Country_R496 = 395,
  Location_Country_R410 = 396,
  Location_Country_R035 = 397,
  Location_Country_R096 = 398,
  Location_Country_R116 = 399,
  Location_Country_R360 = 400,
  Location_Country_R418 = 401,
  Location_Country_R458 = 402,
  Location_Country_R104 = 403,
  Location_Country_R608 = 404,
  Location_Country_R702 = 405,
  Location_Country_R764 = 406,
  Location_Country_R626 = 407,
  Location_Country_R704 = 408,
  Location_Country_R034 = 409,
  Location_Country_R004 = 410,
  Location_Country_R050 = 411,
  Location_Country_R064 = 412,
  Location_Country_R356 = 413,
  Location_Country_R364 = 414,
  Location_Country_R462 = 415,
  Location_Country_R524 = 416,
  Location_Country_R586 = 417,
  Location_Country_R144 = 418,
  Location_Country_R145 = 419,
  Location_Country_R051 = 420,
  Location_Country_R031 = 421,
  Location_Country_R048 = 422,
  Location_Country_R196 = 423,
  Location_Country_R268 = 424,
  Location_Country_R368 = 425,
  Location_Country_R376 = 426,
  Location_Country_R400 = 427,
  Location_Country_R414 = 428,
  Location_Country_R422 = 429,
  Location_Country_R512 = 430,
  Location_Country_R634 = 431,
  Location_Country_R682 = 432,
  Location_Country_R275 = 433,
  Location_Country_R760 = 434,
  Location_Country_R792 = 435,
  Location_Country_R784 = 436,
  Location_Country_R887 = 437,
  Location_Country_R150 = 438,
  Location_Country_R151 = 439,
  Location_Country_R112 = 440,
  Location_Country_R100 = 441,
  Location_Country_R203 = 442,
  Location_Country_R348 = 443,
  Location_Country_R616 = 444,
  Location_Country_R498 = 445,
  Location_Country_R642 = 446,
  Location_Country_R643 = 447,
  Location_Country_R703 = 448,
  Location_Country_R804 = 449,
  Location_Country_R154 = 450,
  Location_Country_R248 = 451,
  Location_Country_R830 = 452,
  Location_Country_R831 = 453,
  Location_Country_R832 = 454,
  Location_Country_R680 = 455,
  Location_Country_R208 = 456,
  Location_Country_R233 = 457,
  Location_Country_R234 = 458,
  Location_Country_R246 = 459,
  Location_Country_R352 = 460,
  Location_Country_R372 = 461,
  Location_Country_R833 = 462,
  Location_Country_R428 = 463,
  Location_Country_R440 = 464,
  Location_Country_R578 = 465,
  Location_Country_R744 = 466,
  Location_Country_R752 = 467,
  Location_Country_R826 = 468,
  Location_Country_R039 = 469,
  Location_Country_R008 = 470,
  Location_Country_R020 = 471,
  Location_Country_R070 = 472,
  Location_Country_R191 = 473,
  Location_Country_R292 = 474,
  Location_Country_R300 = 475,
  Location_Country_R336 = 476,
  Location_Country_R380 = 477,
  Location_Country_R470 = 478,
  Location_Country_R499 = 479,
  Location_Country_R807 = 480,
  Location_Country_R620 = 481,
  Location_Country_R674 = 482,
  Location_Country_R688 = 483,
  Location_Country_R705 = 484,
  Location_Country_R724 = 485,
  Location_Country_R155 = 486,
  Location_Country_R040 = 487,
  Location_Country_R056 = 488,
  Location_Country_R250 = 489,
  Location_Country_R276 = 490,
  Location_Country_R438 = 491,
  Location_Country_R442 = 492,
  Location_Country_R492 = 493,
  Location_Country_R528 = 494,
  Location_Country_R756 = 495,
  Location_Country_R009 = 496,
  Location_Country_R053 = 497,
  Location_Country_R036 = 498,
  Location_Country_R162 = 499,
  Location_Country_R166 = 500,
  Location_Country_R334 = 501,
  Location_Country_R554 = 502,
  Location_Country_R574 = 503,
  Location_Country_R054 = 504,
  Location_Country_R242 = 505,
  Location_Country_R540 = 506,
  Location_Country_R598 = 507,
  Location_Country_R090 = 508,
  Location_Country_R548 = 509,
  Location_Country_R057 = 510,
  Location_Country_R316 = 511,
  Location_Country_R296 = 512,
  Location_Country_R584 = 513,
  Location_Country_R583 = 514,
  Location_Country_R520 = 515,
  Location_Country_R580 = 516,
  Location_Country_R585 = 517,
  Location_Country_R581 = 518,
  Location_Country_R061 = 519,
  Location_Country_R016 = 520,
  Location_Country_R184 = 521,
  Location_Country_R258 = 522,
  Location_Country_R570 = 523,
  Location_Country_R612 = 524,
  Location_Country_R882 = 525,
  Location_Country_R772 = 526,
  Location_Country_R776 = 527,
  Location_Country_R798 = 528,
  Location_Country_R876 = 529,
  Location_Country_Location_Country_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  Location_Country_Location_Country_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool Location_Country_IsValid(int value);
constexpr Location_Country Location_Country_Country_MIN = Location_Country_UNKNOWN_COUNTRY;
constexpr Location_Country Location_Country_Country_MAX = Location_Country_R876;
constexpr int Location_Country_Country_ARRAYSIZE = Location_Country_Country_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Location_Country_descriptor();
template<typename T>
inline const std::string& Location_Country_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Location_Country>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Location_Country_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Location_Country_descriptor(), enum_t_value);
}
inline bool Location_Country_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, Location_Country* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Location_Country>(
    Location_Country_descriptor(), name, value);
}
// ===================================================================

class Claim PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Claim) */ {
 public:
  inline Claim() : Claim(nullptr) {}
  virtual ~Claim();
  explicit constexpr Claim(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Claim(const Claim& from);
  Claim(Claim&& from) noexcept
    : Claim() {
    *this = ::std::move(from);
  }

  inline Claim& operator=(const Claim& from) {
    CopyFrom(from);
    return *this;
  }
  inline Claim& operator=(Claim&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Claim& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kStream = 1,
    kChannel = 2,
    kCollection = 3,
    kRepost = 4,
    TYPE_NOT_SET = 0,
  };

  static inline const Claim* internal_default_instance() {
    return reinterpret_cast<const Claim*>(
               &_Claim_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Claim& a, Claim& b) {
    a.Swap(&b);
  }
  inline void Swap(Claim* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Claim* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Claim* New() const final {
    return CreateMaybeMessage<Claim>(nullptr);
  }

  Claim* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Claim>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Claim& from);
  void MergeFrom(const Claim& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Claim* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Claim";
  }
  protected:
  explicit Claim(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagsFieldNumber = 11,
    kLanguagesFieldNumber = 12,
    kLocationsFieldNumber = 13,
    kTitleFieldNumber = 8,
    kDescriptionFieldNumber = 9,
    kThumbnailFieldNumber = 10,
    kStreamFieldNumber = 1,
    kChannelFieldNumber = 2,
    kCollectionFieldNumber = 3,
    kRepostFieldNumber = 4,
  };
  // repeated string tags = 11;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  const std::string& tags(int index) const;
  std::string* mutable_tags(int index);
  void set_tags(int index, const std::string& value);
  void set_tags(int index, std::string&& value);
  void set_tags(int index, const char* value);
  void set_tags(int index, const char* value, size_t size);
  std::string* add_tags();
  void add_tags(const std::string& value);
  void add_tags(std::string&& value);
  void add_tags(const char* value);
  void add_tags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& tags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_tags();
  private:
  const std::string& _internal_tags(int index) const;
  std::string* _internal_add_tags();
  public:

  // repeated .pb.Language languages = 12;
  int languages_size() const;
  private:
  int _internal_languages_size() const;
  public:
  void clear_languages();
  ::pb::Language* mutable_languages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Language >*
      mutable_languages();
  private:
  const ::pb::Language& _internal_languages(int index) const;
  ::pb::Language* _internal_add_languages();
  public:
  const ::pb::Language& languages(int index) const;
  ::pb::Language* add_languages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Language >&
      languages() const;

  // repeated .pb.Location locations = 13;
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  ::pb::Location* mutable_locations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Location >*
      mutable_locations();
  private:
  const ::pb::Location& _internal_locations(int index) const;
  ::pb::Location* _internal_add_locations();
  public:
  const ::pb::Location& locations(int index) const;
  ::pb::Location* add_locations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Location >&
      locations() const;

  // string title = 8;
  void clear_title();
  const std::string& title() const;
  void set_title(const std::string& value);
  void set_title(std::string&& value);
  void set_title(const char* value);
  void set_title(const char* value, size_t size);
  std::string* mutable_title();
  std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // string description = 9;
  void clear_description();
  const std::string& description() const;
  void set_description(const std::string& value);
  void set_description(std::string&& value);
  void set_description(const char* value);
  void set_description(const char* value, size_t size);
  std::string* mutable_description();
  std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // .pb.Source thumbnail = 10;
  bool has_thumbnail() const;
  private:
  bool _internal_has_thumbnail() const;
  public:
  void clear_thumbnail();
  const ::pb::Source& thumbnail() const;
  ::pb::Source* release_thumbnail();
  ::pb::Source* mutable_thumbnail();
  void set_allocated_thumbnail(::pb::Source* thumbnail);
  private:
  const ::pb::Source& _internal_thumbnail() const;
  ::pb::Source* _internal_mutable_thumbnail();
  public:
  void unsafe_arena_set_allocated_thumbnail(
      ::pb::Source* thumbnail);
  ::pb::Source* unsafe_arena_release_thumbnail();

  // .pb.Stream stream = 1;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::pb::Stream& stream() const;
  ::pb::Stream* release_stream();
  ::pb::Stream* mutable_stream();
  void set_allocated_stream(::pb::Stream* stream);
  private:
  const ::pb::Stream& _internal_stream() const;
  ::pb::Stream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::pb::Stream* stream);
  ::pb::Stream* unsafe_arena_release_stream();

  // .pb.Channel channel = 2;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  const ::pb::Channel& channel() const;
  ::pb::Channel* release_channel();
  ::pb::Channel* mutable_channel();
  void set_allocated_channel(::pb::Channel* channel);
  private:
  const ::pb::Channel& _internal_channel() const;
  ::pb::Channel* _internal_mutable_channel();
  public:
  void unsafe_arena_set_allocated_channel(
      ::pb::Channel* channel);
  ::pb::Channel* unsafe_arena_release_channel();

  // .pb.ClaimList collection = 3;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::pb::ClaimList& collection() const;
  ::pb::ClaimList* release_collection();
  ::pb::ClaimList* mutable_collection();
  void set_allocated_collection(::pb::ClaimList* collection);
  private:
  const ::pb::ClaimList& _internal_collection() const;
  ::pb::ClaimList* _internal_mutable_collection();
  public:
  void unsafe_arena_set_allocated_collection(
      ::pb::ClaimList* collection);
  ::pb::ClaimList* unsafe_arena_release_collection();

  // .pb.ClaimReference repost = 4;
  bool has_repost() const;
  private:
  bool _internal_has_repost() const;
  public:
  void clear_repost();
  const ::pb::ClaimReference& repost() const;
  ::pb::ClaimReference* release_repost();
  ::pb::ClaimReference* mutable_repost();
  void set_allocated_repost(::pb::ClaimReference* repost);
  private:
  const ::pb::ClaimReference& _internal_repost() const;
  ::pb::ClaimReference* _internal_mutable_repost();
  public:
  void unsafe_arena_set_allocated_repost(
      ::pb::ClaimReference* repost);
  ::pb::ClaimReference* unsafe_arena_release_repost();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:pb.Claim)
 private:
  class _Internal;
  void set_has_stream();
  void set_has_channel();
  void set_has_collection();
  void set_has_repost();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Language > languages_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Location > locations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::pb::Source* thumbnail_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::pb::Stream* stream_;
    ::pb::Channel* channel_;
    ::pb::ClaimList* collection_;
    ::pb::ClaimReference* repost_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Stream PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Stream) */ {
 public:
  inline Stream() : Stream(nullptr) {}
  virtual ~Stream();
  explicit constexpr Stream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Stream(const Stream& from);
  Stream(Stream&& from) noexcept
    : Stream() {
    *this = ::std::move(from);
  }

  inline Stream& operator=(const Stream& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stream& operator=(Stream&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Stream& default_instance() {
    return *internal_default_instance();
  }
  enum TypeCase {
    kImage = 10,
    kVideo = 11,
    kAudio = 12,
    kSoftware = 13,
    TYPE_NOT_SET = 0,
  };

  static inline const Stream* internal_default_instance() {
    return reinterpret_cast<const Stream*>(
               &_Stream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Stream& a, Stream& b) {
    a.Swap(&b);
  }
  inline void Swap(Stream* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Stream* New() const final {
    return CreateMaybeMessage<Stream>(nullptr);
  }

  Stream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Stream>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Stream& from);
  void MergeFrom(const Stream& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stream* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Stream";
  }
  protected:
  explicit Stream(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthorFieldNumber = 2,
    kLicenseFieldNumber = 3,
    kLicenseUrlFieldNumber = 4,
    kSourceFieldNumber = 1,
    kFeeFieldNumber = 6,
    kReleaseTimeFieldNumber = 5,
    kImageFieldNumber = 10,
    kVideoFieldNumber = 11,
    kAudioFieldNumber = 12,
    kSoftwareFieldNumber = 13,
  };
  // string author = 2;
  void clear_author();
  const std::string& author() const;
  void set_author(const std::string& value);
  void set_author(std::string&& value);
  void set_author(const char* value);
  void set_author(const char* value, size_t size);
  std::string* mutable_author();
  std::string* release_author();
  void set_allocated_author(std::string* author);
  private:
  const std::string& _internal_author() const;
  void _internal_set_author(const std::string& value);
  std::string* _internal_mutable_author();
  public:

  // string license = 3;
  void clear_license();
  const std::string& license() const;
  void set_license(const std::string& value);
  void set_license(std::string&& value);
  void set_license(const char* value);
  void set_license(const char* value, size_t size);
  std::string* mutable_license();
  std::string* release_license();
  void set_allocated_license(std::string* license);
  private:
  const std::string& _internal_license() const;
  void _internal_set_license(const std::string& value);
  std::string* _internal_mutable_license();
  public:

  // string license_url = 4;
  void clear_license_url();
  const std::string& license_url() const;
  void set_license_url(const std::string& value);
  void set_license_url(std::string&& value);
  void set_license_url(const char* value);
  void set_license_url(const char* value, size_t size);
  std::string* mutable_license_url();
  std::string* release_license_url();
  void set_allocated_license_url(std::string* license_url);
  private:
  const std::string& _internal_license_url() const;
  void _internal_set_license_url(const std::string& value);
  std::string* _internal_mutable_license_url();
  public:

  // .pb.Source source = 1;
  bool has_source() const;
  private:
  bool _internal_has_source() const;
  public:
  void clear_source();
  const ::pb::Source& source() const;
  ::pb::Source* release_source();
  ::pb::Source* mutable_source();
  void set_allocated_source(::pb::Source* source);
  private:
  const ::pb::Source& _internal_source() const;
  ::pb::Source* _internal_mutable_source();
  public:
  void unsafe_arena_set_allocated_source(
      ::pb::Source* source);
  ::pb::Source* unsafe_arena_release_source();

  // .pb.Fee fee = 6;
  bool has_fee() const;
  private:
  bool _internal_has_fee() const;
  public:
  void clear_fee();
  const ::pb::Fee& fee() const;
  ::pb::Fee* release_fee();
  ::pb::Fee* mutable_fee();
  void set_allocated_fee(::pb::Fee* fee);
  private:
  const ::pb::Fee& _internal_fee() const;
  ::pb::Fee* _internal_mutable_fee();
  public:
  void unsafe_arena_set_allocated_fee(
      ::pb::Fee* fee);
  ::pb::Fee* unsafe_arena_release_fee();

  // int64 release_time = 5;
  void clear_release_time();
  ::PROTOBUF_NAMESPACE_ID::int64 release_time() const;
  void set_release_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_release_time() const;
  void _internal_set_release_time(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .pb.Image image = 10;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const ::pb::Image& image() const;
  ::pb::Image* release_image();
  ::pb::Image* mutable_image();
  void set_allocated_image(::pb::Image* image);
  private:
  const ::pb::Image& _internal_image() const;
  ::pb::Image* _internal_mutable_image();
  public:
  void unsafe_arena_set_allocated_image(
      ::pb::Image* image);
  ::pb::Image* unsafe_arena_release_image();

  // .pb.Video video = 11;
  bool has_video() const;
  private:
  bool _internal_has_video() const;
  public:
  void clear_video();
  const ::pb::Video& video() const;
  ::pb::Video* release_video();
  ::pb::Video* mutable_video();
  void set_allocated_video(::pb::Video* video);
  private:
  const ::pb::Video& _internal_video() const;
  ::pb::Video* _internal_mutable_video();
  public:
  void unsafe_arena_set_allocated_video(
      ::pb::Video* video);
  ::pb::Video* unsafe_arena_release_video();

  // .pb.Audio audio = 12;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::pb::Audio& audio() const;
  ::pb::Audio* release_audio();
  ::pb::Audio* mutable_audio();
  void set_allocated_audio(::pb::Audio* audio);
  private:
  const ::pb::Audio& _internal_audio() const;
  ::pb::Audio* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::pb::Audio* audio);
  ::pb::Audio* unsafe_arena_release_audio();

  // .pb.Software software = 13;
  bool has_software() const;
  private:
  bool _internal_has_software() const;
  public:
  void clear_software();
  const ::pb::Software& software() const;
  ::pb::Software* release_software();
  ::pb::Software* mutable_software();
  void set_allocated_software(::pb::Software* software);
  private:
  const ::pb::Software& _internal_software() const;
  ::pb::Software* _internal_mutable_software();
  public:
  void unsafe_arena_set_allocated_software(
      ::pb::Software* software);
  ::pb::Software* unsafe_arena_release_software();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:pb.Stream)
 private:
  class _Internal;
  void set_has_image();
  void set_has_video();
  void set_has_audio();
  void set_has_software();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr author_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr license_url_;
  ::pb::Source* source_;
  ::pb::Fee* fee_;
  ::PROTOBUF_NAMESPACE_ID::int64 release_time_;
  union TypeUnion {
    constexpr TypeUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::pb::Image* image_;
    ::pb::Video* video_;
    ::pb::Audio* audio_;
    ::pb::Software* software_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Channel PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Channel) */ {
 public:
  inline Channel() : Channel(nullptr) {}
  virtual ~Channel();
  explicit constexpr Channel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Channel(const Channel& from);
  Channel(Channel&& from) noexcept
    : Channel() {
    *this = ::std::move(from);
  }

  inline Channel& operator=(const Channel& from) {
    CopyFrom(from);
    return *this;
  }
  inline Channel& operator=(Channel&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Channel& default_instance() {
    return *internal_default_instance();
  }
  static inline const Channel* internal_default_instance() {
    return reinterpret_cast<const Channel*>(
               &_Channel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Channel& a, Channel& b) {
    a.Swap(&b);
  }
  inline void Swap(Channel* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Channel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Channel* New() const final {
    return CreateMaybeMessage<Channel>(nullptr);
  }

  Channel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Channel>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Channel& from);
  void MergeFrom(const Channel& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Channel* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Channel";
  }
  protected:
  explicit Channel(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 1,
    kEmailFieldNumber = 2,
    kWebsiteUrlFieldNumber = 3,
    kCoverFieldNumber = 4,
    kFeaturedFieldNumber = 5,
  };
  // bytes public_key = 1;
  void clear_public_key();
  const std::string& public_key() const;
  void set_public_key(const std::string& value);
  void set_public_key(std::string&& value);
  void set_public_key(const char* value);
  void set_public_key(const void* value, size_t size);
  std::string* mutable_public_key();
  std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // string email = 2;
  void clear_email();
  const std::string& email() const;
  void set_email(const std::string& value);
  void set_email(std::string&& value);
  void set_email(const char* value);
  void set_email(const char* value, size_t size);
  std::string* mutable_email();
  std::string* release_email();
  void set_allocated_email(std::string* email);
  private:
  const std::string& _internal_email() const;
  void _internal_set_email(const std::string& value);
  std::string* _internal_mutable_email();
  public:

  // string website_url = 3;
  void clear_website_url();
  const std::string& website_url() const;
  void set_website_url(const std::string& value);
  void set_website_url(std::string&& value);
  void set_website_url(const char* value);
  void set_website_url(const char* value, size_t size);
  std::string* mutable_website_url();
  std::string* release_website_url();
  void set_allocated_website_url(std::string* website_url);
  private:
  const std::string& _internal_website_url() const;
  void _internal_set_website_url(const std::string& value);
  std::string* _internal_mutable_website_url();
  public:

  // .pb.Source cover = 4;
  bool has_cover() const;
  private:
  bool _internal_has_cover() const;
  public:
  void clear_cover();
  const ::pb::Source& cover() const;
  ::pb::Source* release_cover();
  ::pb::Source* mutable_cover();
  void set_allocated_cover(::pb::Source* cover);
  private:
  const ::pb::Source& _internal_cover() const;
  ::pb::Source* _internal_mutable_cover();
  public:
  void unsafe_arena_set_allocated_cover(
      ::pb::Source* cover);
  ::pb::Source* unsafe_arena_release_cover();

  // .pb.ClaimList featured = 5;
  bool has_featured() const;
  private:
  bool _internal_has_featured() const;
  public:
  void clear_featured();
  const ::pb::ClaimList& featured() const;
  ::pb::ClaimList* release_featured();
  ::pb::ClaimList* mutable_featured();
  void set_allocated_featured(::pb::ClaimList* featured);
  private:
  const ::pb::ClaimList& _internal_featured() const;
  ::pb::ClaimList* _internal_mutable_featured();
  public:
  void unsafe_arena_set_allocated_featured(
      ::pb::ClaimList* featured);
  ::pb::ClaimList* unsafe_arena_release_featured();

  // @@protoc_insertion_point(class_scope:pb.Channel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr email_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_url_;
  ::pb::Source* cover_;
  ::pb::ClaimList* featured_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class ClaimReference PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ClaimReference) */ {
 public:
  inline ClaimReference() : ClaimReference(nullptr) {}
  virtual ~ClaimReference();
  explicit constexpr ClaimReference(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClaimReference(const ClaimReference& from);
  ClaimReference(ClaimReference&& from) noexcept
    : ClaimReference() {
    *this = ::std::move(from);
  }

  inline ClaimReference& operator=(const ClaimReference& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClaimReference& operator=(ClaimReference&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClaimReference& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClaimReference* internal_default_instance() {
    return reinterpret_cast<const ClaimReference*>(
               &_ClaimReference_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ClaimReference& a, ClaimReference& b) {
    a.Swap(&b);
  }
  inline void Swap(ClaimReference* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClaimReference* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClaimReference* New() const final {
    return CreateMaybeMessage<ClaimReference>(nullptr);
  }

  ClaimReference* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClaimReference>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClaimReference& from);
  void MergeFrom(const ClaimReference& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClaimReference* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ClaimReference";
  }
  protected:
  explicit ClaimReference(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClaimHashFieldNumber = 1,
  };
  // bytes claim_hash = 1;
  void clear_claim_hash();
  const std::string& claim_hash() const;
  void set_claim_hash(const std::string& value);
  void set_claim_hash(std::string&& value);
  void set_claim_hash(const char* value);
  void set_claim_hash(const void* value, size_t size);
  std::string* mutable_claim_hash();
  std::string* release_claim_hash();
  void set_allocated_claim_hash(std::string* claim_hash);
  private:
  const std::string& _internal_claim_hash() const;
  void _internal_set_claim_hash(const std::string& value);
  std::string* _internal_mutable_claim_hash();
  public:

  // @@protoc_insertion_point(class_scope:pb.ClaimReference)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr claim_hash_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class ClaimList PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.ClaimList) */ {
 public:
  inline ClaimList() : ClaimList(nullptr) {}
  virtual ~ClaimList();
  explicit constexpr ClaimList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClaimList(const ClaimList& from);
  ClaimList(ClaimList&& from) noexcept
    : ClaimList() {
    *this = ::std::move(from);
  }

  inline ClaimList& operator=(const ClaimList& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClaimList& operator=(ClaimList&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ClaimList& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClaimList* internal_default_instance() {
    return reinterpret_cast<const ClaimList*>(
               &_ClaimList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ClaimList& a, ClaimList& b) {
    a.Swap(&b);
  }
  inline void Swap(ClaimList* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClaimList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ClaimList* New() const final {
    return CreateMaybeMessage<ClaimList>(nullptr);
  }

  ClaimList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ClaimList>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ClaimList& from);
  void MergeFrom(const ClaimList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClaimList* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.ClaimList";
  }
  protected:
  explicit ClaimList(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef ClaimList_ListType ListType;
  static constexpr ListType COLLECTION =
    ClaimList_ListType_COLLECTION;
  static constexpr ListType DERIVATION =
    ClaimList_ListType_DERIVATION;
  static inline bool ListType_IsValid(int value) {
    return ClaimList_ListType_IsValid(value);
  }
  static constexpr ListType ListType_MIN =
    ClaimList_ListType_ListType_MIN;
  static constexpr ListType ListType_MAX =
    ClaimList_ListType_ListType_MAX;
  static constexpr int ListType_ARRAYSIZE =
    ClaimList_ListType_ListType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ListType_descriptor() {
    return ClaimList_ListType_descriptor();
  }
  template<typename T>
  static inline const std::string& ListType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ListType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ListType_Name.");
    return ClaimList_ListType_Name(enum_t_value);
  }
  static inline bool ListType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ListType* value) {
    return ClaimList_ListType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kClaimReferencesFieldNumber = 2,
    kListTypeFieldNumber = 1,
  };
  // repeated .pb.ClaimReference claim_references = 2;
  int claim_references_size() const;
  private:
  int _internal_claim_references_size() const;
  public:
  void clear_claim_references();
  ::pb::ClaimReference* mutable_claim_references(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ClaimReference >*
      mutable_claim_references();
  private:
  const ::pb::ClaimReference& _internal_claim_references(int index) const;
  ::pb::ClaimReference* _internal_add_claim_references();
  public:
  const ::pb::ClaimReference& claim_references(int index) const;
  ::pb::ClaimReference* add_claim_references();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ClaimReference >&
      claim_references() const;

  // .pb.ClaimList.ListType list_type = 1;
  void clear_list_type();
  ::pb::ClaimList_ListType list_type() const;
  void set_list_type(::pb::ClaimList_ListType value);
  private:
  ::pb::ClaimList_ListType _internal_list_type() const;
  void _internal_set_list_type(::pb::ClaimList_ListType value);
  public:

  // @@protoc_insertion_point(class_scope:pb.ClaimList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ClaimReference > claim_references_;
  int list_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Source PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Source) */ {
 public:
  inline Source() : Source(nullptr) {}
  virtual ~Source();
  explicit constexpr Source(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Source(const Source& from);
  Source(Source&& from) noexcept
    : Source() {
    *this = ::std::move(from);
  }

  inline Source& operator=(const Source& from) {
    CopyFrom(from);
    return *this;
  }
  inline Source& operator=(Source&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Source& default_instance() {
    return *internal_default_instance();
  }
  static inline const Source* internal_default_instance() {
    return reinterpret_cast<const Source*>(
               &_Source_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Source& a, Source& b) {
    a.Swap(&b);
  }
  inline void Swap(Source* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Source* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Source* New() const final {
    return CreateMaybeMessage<Source>(nullptr);
  }

  Source* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Source>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Source& from);
  void MergeFrom(const Source& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Source* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Source";
  }
  protected:
  explicit Source(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
    kNameFieldNumber = 2,
    kMediaTypeFieldNumber = 4,
    kUrlFieldNumber = 5,
    kSdHashFieldNumber = 6,
    kBtInfohashFieldNumber = 7,
    kSizeFieldNumber = 3,
  };
  // bytes hash = 1;
  void clear_hash();
  const std::string& hash() const;
  void set_hash(const std::string& value);
  void set_hash(std::string&& value);
  void set_hash(const char* value);
  void set_hash(const void* value, size_t size);
  std::string* mutable_hash();
  std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string media_type = 4;
  void clear_media_type();
  const std::string& media_type() const;
  void set_media_type(const std::string& value);
  void set_media_type(std::string&& value);
  void set_media_type(const char* value);
  void set_media_type(const char* value, size_t size);
  std::string* mutable_media_type();
  std::string* release_media_type();
  void set_allocated_media_type(std::string* media_type);
  private:
  const std::string& _internal_media_type() const;
  void _internal_set_media_type(const std::string& value);
  std::string* _internal_mutable_media_type();
  public:

  // string url = 5;
  void clear_url();
  const std::string& url() const;
  void set_url(const std::string& value);
  void set_url(std::string&& value);
  void set_url(const char* value);
  void set_url(const char* value, size_t size);
  std::string* mutable_url();
  std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bytes sd_hash = 6;
  void clear_sd_hash();
  const std::string& sd_hash() const;
  void set_sd_hash(const std::string& value);
  void set_sd_hash(std::string&& value);
  void set_sd_hash(const char* value);
  void set_sd_hash(const void* value, size_t size);
  std::string* mutable_sd_hash();
  std::string* release_sd_hash();
  void set_allocated_sd_hash(std::string* sd_hash);
  private:
  const std::string& _internal_sd_hash() const;
  void _internal_set_sd_hash(const std::string& value);
  std::string* _internal_mutable_sd_hash();
  public:

  // bytes bt_infohash = 7;
  void clear_bt_infohash();
  const std::string& bt_infohash() const;
  void set_bt_infohash(const std::string& value);
  void set_bt_infohash(std::string&& value);
  void set_bt_infohash(const char* value);
  void set_bt_infohash(const void* value, size_t size);
  std::string* mutable_bt_infohash();
  std::string* release_bt_infohash();
  void set_allocated_bt_infohash(std::string* bt_infohash);
  private:
  const std::string& _internal_bt_infohash() const;
  void _internal_set_bt_infohash(const std::string& value);
  std::string* _internal_mutable_bt_infohash();
  public:

  // uint64 size = 3;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Source)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr media_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sd_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bt_infohash_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Fee PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Fee) */ {
 public:
  inline Fee() : Fee(nullptr) {}
  virtual ~Fee();
  explicit constexpr Fee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Fee(const Fee& from);
  Fee(Fee&& from) noexcept
    : Fee() {
    *this = ::std::move(from);
  }

  inline Fee& operator=(const Fee& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fee& operator=(Fee&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fee& default_instance() {
    return *internal_default_instance();
  }
  static inline const Fee* internal_default_instance() {
    return reinterpret_cast<const Fee*>(
               &_Fee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Fee& a, Fee& b) {
    a.Swap(&b);
  }
  inline void Swap(Fee* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fee* New() const final {
    return CreateMaybeMessage<Fee>(nullptr);
  }

  Fee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fee>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fee& from);
  void MergeFrom(const Fee& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fee* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Fee";
  }
  protected:
  explicit Fee(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef Fee_Currency Currency;
  static constexpr Currency UNKNOWN_CURRENCY =
    Fee_Currency_UNKNOWN_CURRENCY;
  static constexpr Currency LBC =
    Fee_Currency_LBC;
  static constexpr Currency BTC =
    Fee_Currency_BTC;
  static constexpr Currency USD =
    Fee_Currency_USD;
  static inline bool Currency_IsValid(int value) {
    return Fee_Currency_IsValid(value);
  }
  static constexpr Currency Currency_MIN =
    Fee_Currency_Currency_MIN;
  static constexpr Currency Currency_MAX =
    Fee_Currency_Currency_MAX;
  static constexpr int Currency_ARRAYSIZE =
    Fee_Currency_Currency_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Currency_descriptor() {
    return Fee_Currency_descriptor();
  }
  template<typename T>
  static inline const std::string& Currency_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Currency>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Currency_Name.");
    return Fee_Currency_Name(enum_t_value);
  }
  static inline bool Currency_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Currency* value) {
    return Fee_Currency_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kAmountFieldNumber = 3,
    kCurrencyFieldNumber = 1,
  };
  // bytes address = 2;
  void clear_address();
  const std::string& address() const;
  void set_address(const std::string& value);
  void set_address(std::string&& value);
  void set_address(const char* value);
  void set_address(const void* value, size_t size);
  std::string* mutable_address();
  std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 amount = 3;
  void clear_amount();
  ::PROTOBUF_NAMESPACE_ID::uint64 amount() const;
  void set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_amount() const;
  void _internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // .pb.Fee.Currency currency = 1;
  void clear_currency();
  ::pb::Fee_Currency currency() const;
  void set_currency(::pb::Fee_Currency value);
  private:
  ::pb::Fee_Currency _internal_currency() const;
  void _internal_set_currency(::pb::Fee_Currency value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Fee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 amount_;
  int currency_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Image PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Image) */ {
 public:
  inline Image() : Image(nullptr) {}
  virtual ~Image();
  explicit constexpr Image(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Image(const Image& from);
  Image(Image&& from) noexcept
    : Image() {
    *this = ::std::move(from);
  }

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }
  inline Image& operator=(Image&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Image& default_instance() {
    return *internal_default_instance();
  }
  static inline const Image* internal_default_instance() {
    return reinterpret_cast<const Image*>(
               &_Image_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Image& a, Image& b) {
    a.Swap(&b);
  }
  inline void Swap(Image* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Image* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Image* New() const final {
    return CreateMaybeMessage<Image>(nullptr);
  }

  Image* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Image>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Image* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Image";
  }
  protected:
  explicit Image(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // uint32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Image)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Video PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Video) */ {
 public:
  inline Video() : Video(nullptr) {}
  virtual ~Video();
  explicit constexpr Video(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Video(const Video& from);
  Video(Video&& from) noexcept
    : Video() {
    *this = ::std::move(from);
  }

  inline Video& operator=(const Video& from) {
    CopyFrom(from);
    return *this;
  }
  inline Video& operator=(Video&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Video& default_instance() {
    return *internal_default_instance();
  }
  static inline const Video* internal_default_instance() {
    return reinterpret_cast<const Video*>(
               &_Video_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Video& a, Video& b) {
    a.Swap(&b);
  }
  inline void Swap(Video* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Video* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Video* New() const final {
    return CreateMaybeMessage<Video>(nullptr);
  }

  Video* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Video>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Video& from);
  void MergeFrom(const Video& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Video* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Video";
  }
  protected:
  explicit Video(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAudioFieldNumber = 15,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kDurationFieldNumber = 3,
  };
  // .pb.Audio audio = 15;
  bool has_audio() const;
  private:
  bool _internal_has_audio() const;
  public:
  void clear_audio();
  const ::pb::Audio& audio() const;
  ::pb::Audio* release_audio();
  ::pb::Audio* mutable_audio();
  void set_allocated_audio(::pb::Audio* audio);
  private:
  const ::pb::Audio& _internal_audio() const;
  ::pb::Audio* _internal_mutable_audio();
  public:
  void unsafe_arena_set_allocated_audio(
      ::pb::Audio* audio);
  ::pb::Audio* unsafe_arena_release_audio();

  // uint32 width = 1;
  void clear_width();
  ::PROTOBUF_NAMESPACE_ID::uint32 width() const;
  void set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_width() const;
  void _internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 height = 2;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint32 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 duration = 3;
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::uint32 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Video)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::pb::Audio* audio_;
  ::PROTOBUF_NAMESPACE_ID::uint32 width_;
  ::PROTOBUF_NAMESPACE_ID::uint32 height_;
  ::PROTOBUF_NAMESPACE_ID::uint32 duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Audio PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Audio) */ {
 public:
  inline Audio() : Audio(nullptr) {}
  virtual ~Audio();
  explicit constexpr Audio(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Audio(const Audio& from);
  Audio(Audio&& from) noexcept
    : Audio() {
    *this = ::std::move(from);
  }

  inline Audio& operator=(const Audio& from) {
    CopyFrom(from);
    return *this;
  }
  inline Audio& operator=(Audio&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Audio& default_instance() {
    return *internal_default_instance();
  }
  static inline const Audio* internal_default_instance() {
    return reinterpret_cast<const Audio*>(
               &_Audio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Audio& a, Audio& b) {
    a.Swap(&b);
  }
  inline void Swap(Audio* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Audio* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Audio* New() const final {
    return CreateMaybeMessage<Audio>(nullptr);
  }

  Audio* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Audio>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Audio& from);
  void MergeFrom(const Audio& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Audio* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Audio";
  }
  protected:
  explicit Audio(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDurationFieldNumber = 1,
  };
  // uint32 duration = 1;
  void clear_duration();
  ::PROTOBUF_NAMESPACE_ID::uint32 duration() const;
  void set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_duration() const;
  void _internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Audio)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint32 duration_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Software PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Software) */ {
 public:
  inline Software() : Software(nullptr) {}
  virtual ~Software();
  explicit constexpr Software(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Software(const Software& from);
  Software(Software&& from) noexcept
    : Software() {
    *this = ::std::move(from);
  }

  inline Software& operator=(const Software& from) {
    CopyFrom(from);
    return *this;
  }
  inline Software& operator=(Software&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Software& default_instance() {
    return *internal_default_instance();
  }
  static inline const Software* internal_default_instance() {
    return reinterpret_cast<const Software*>(
               &_Software_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Software& a, Software& b) {
    a.Swap(&b);
  }
  inline void Swap(Software* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Software* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Software* New() const final {
    return CreateMaybeMessage<Software>(nullptr);
  }

  Software* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Software>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Software& from);
  void MergeFrom(const Software& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Software* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Software";
  }
  protected:
  explicit Software(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef Software_OS OS;
  static constexpr OS UNKNOWN_OS =
    Software_OS_UNKNOWN_OS;
  static constexpr OS ANY =
    Software_OS_ANY;
  static constexpr OS LINUX =
    Software_OS_LINUX;
  static constexpr OS WINDOWS =
    Software_OS_WINDOWS;
  static constexpr OS MAC =
    Software_OS_MAC;
  static constexpr OS ANDROID =
    Software_OS_ANDROID;
  static constexpr OS IOS =
    Software_OS_IOS;
  static inline bool OS_IsValid(int value) {
    return Software_OS_IsValid(value);
  }
  static constexpr OS OS_MIN =
    Software_OS_OS_MIN;
  static constexpr OS OS_MAX =
    Software_OS_OS_MAX;
  static constexpr int OS_ARRAYSIZE =
    Software_OS_OS_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  OS_descriptor() {
    return Software_OS_descriptor();
  }
  template<typename T>
  static inline const std::string& OS_Name(T enum_t_value) {
    static_assert(::std::is_same<T, OS>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function OS_Name.");
    return Software_OS_Name(enum_t_value);
  }
  static inline bool OS_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      OS* value) {
    return Software_OS_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOsFieldNumber = 1,
  };
  // string os = 1;
  void clear_os();
  const std::string& os() const;
  void set_os(const std::string& value);
  void set_os(std::string&& value);
  void set_os(const char* value);
  void set_os(const char* value, size_t size);
  std::string* mutable_os();
  std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // @@protoc_insertion_point(class_scope:pb.Software)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Language PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Language) */ {
 public:
  inline Language() : Language(nullptr) {}
  virtual ~Language();
  explicit constexpr Language(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Language(const Language& from);
  Language(Language&& from) noexcept
    : Language() {
    *this = ::std::move(from);
  }

  inline Language& operator=(const Language& from) {
    CopyFrom(from);
    return *this;
  }
  inline Language& operator=(Language&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Language& default_instance() {
    return *internal_default_instance();
  }
  static inline const Language* internal_default_instance() {
    return reinterpret_cast<const Language*>(
               &_Language_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Language& a, Language& b) {
    a.Swap(&b);
  }
  inline void Swap(Language* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Language* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Language* New() const final {
    return CreateMaybeMessage<Language>(nullptr);
  }

  Language* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Language>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Language& from);
  void MergeFrom(const Language& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Language* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Language";
  }
  protected:
  explicit Language(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef Language_Language Language;
  static constexpr Language UNKNOWN_LANGUAGE =
    Language_Language_UNKNOWN_LANGUAGE;
  static constexpr Language en =
    Language_Language_en;
  static constexpr Language aa =
    Language_Language_aa;
  static constexpr Language ab =
    Language_Language_ab;
  static constexpr Language ae =
    Language_Language_ae;
  static constexpr Language af =
    Language_Language_af;
  static constexpr Language ak =
    Language_Language_ak;
  static constexpr Language am =
    Language_Language_am;
  static constexpr Language an =
    Language_Language_an;
  static constexpr Language ar =
    Language_Language_ar;
  static constexpr Language as =
    Language_Language_as;
  static constexpr Language av =
    Language_Language_av;
  static constexpr Language ay =
    Language_Language_ay;
  static constexpr Language az =
    Language_Language_az;
  static constexpr Language ba =
    Language_Language_ba;
  static constexpr Language be =
    Language_Language_be;
  static constexpr Language bg =
    Language_Language_bg;
  static constexpr Language bh =
    Language_Language_bh;
  static constexpr Language bi =
    Language_Language_bi;
  static constexpr Language bm =
    Language_Language_bm;
  static constexpr Language bn =
    Language_Language_bn;
  static constexpr Language bo =
    Language_Language_bo;
  static constexpr Language br =
    Language_Language_br;
  static constexpr Language bs =
    Language_Language_bs;
  static constexpr Language ca =
    Language_Language_ca;
  static constexpr Language ce =
    Language_Language_ce;
  static constexpr Language ch =
    Language_Language_ch;
  static constexpr Language co =
    Language_Language_co;
  static constexpr Language cr =
    Language_Language_cr;
  static constexpr Language cs =
    Language_Language_cs;
  static constexpr Language cu =
    Language_Language_cu;
  static constexpr Language cv =
    Language_Language_cv;
  static constexpr Language cy =
    Language_Language_cy;
  static constexpr Language da =
    Language_Language_da;
  static constexpr Language de =
    Language_Language_de;
  static constexpr Language dv =
    Language_Language_dv;
  static constexpr Language dz =
    Language_Language_dz;
  static constexpr Language ee =
    Language_Language_ee;
  static constexpr Language el =
    Language_Language_el;
  static constexpr Language eo =
    Language_Language_eo;
  static constexpr Language es =
    Language_Language_es;
  static constexpr Language et =
    Language_Language_et;
  static constexpr Language eu =
    Language_Language_eu;
  static constexpr Language fa =
    Language_Language_fa;
  static constexpr Language ff =
    Language_Language_ff;
  static constexpr Language fi =
    Language_Language_fi;
  static constexpr Language fj =
    Language_Language_fj;
  static constexpr Language fo =
    Language_Language_fo;
  static constexpr Language fr =
    Language_Language_fr;
  static constexpr Language fy =
    Language_Language_fy;
  static constexpr Language ga =
    Language_Language_ga;
  static constexpr Language gd =
    Language_Language_gd;
  static constexpr Language gl =
    Language_Language_gl;
  static constexpr Language gn =
    Language_Language_gn;
  static constexpr Language gu =
    Language_Language_gu;
  static constexpr Language gv =
    Language_Language_gv;
  static constexpr Language ha =
    Language_Language_ha;
  static constexpr Language he =
    Language_Language_he;
  static constexpr Language hi =
    Language_Language_hi;
  static constexpr Language ho =
    Language_Language_ho;
  static constexpr Language hr =
    Language_Language_hr;
  static constexpr Language ht =
    Language_Language_ht;
  static constexpr Language hu =
    Language_Language_hu;
  static constexpr Language hy =
    Language_Language_hy;
  static constexpr Language hz =
    Language_Language_hz;
  static constexpr Language ia =
    Language_Language_ia;
  static constexpr Language id =
    Language_Language_id;
  static constexpr Language ie =
    Language_Language_ie;
  static constexpr Language ig =
    Language_Language_ig;
  static constexpr Language ii =
    Language_Language_ii;
  static constexpr Language ik =
    Language_Language_ik;
  static constexpr Language io =
    Language_Language_io;
  static constexpr Language is =
    Language_Language_is;
  static constexpr Language it =
    Language_Language_it;
  static constexpr Language iu =
    Language_Language_iu;
  static constexpr Language ja =
    Language_Language_ja;
  static constexpr Language jv =
    Language_Language_jv;
  static constexpr Language ka =
    Language_Language_ka;
  static constexpr Language kg =
    Language_Language_kg;
  static constexpr Language ki =
    Language_Language_ki;
  static constexpr Language kj =
    Language_Language_kj;
  static constexpr Language kk =
    Language_Language_kk;
  static constexpr Language kl =
    Language_Language_kl;
  static constexpr Language km =
    Language_Language_km;
  static constexpr Language kn =
    Language_Language_kn;
  static constexpr Language ko =
    Language_Language_ko;
  static constexpr Language kr =
    Language_Language_kr;
  static constexpr Language ks =
    Language_Language_ks;
  static constexpr Language ku =
    Language_Language_ku;
  static constexpr Language kv =
    Language_Language_kv;
  static constexpr Language kw =
    Language_Language_kw;
  static constexpr Language ky =
    Language_Language_ky;
  static constexpr Language la =
    Language_Language_la;
  static constexpr Language lb =
    Language_Language_lb;
  static constexpr Language lg =
    Language_Language_lg;
  static constexpr Language li =
    Language_Language_li;
  static constexpr Language ln =
    Language_Language_ln;
  static constexpr Language lo =
    Language_Language_lo;
  static constexpr Language lt =
    Language_Language_lt;
  static constexpr Language lu =
    Language_Language_lu;
  static constexpr Language lv =
    Language_Language_lv;
  static constexpr Language mg =
    Language_Language_mg;
  static constexpr Language mh =
    Language_Language_mh;
  static constexpr Language mi =
    Language_Language_mi;
  static constexpr Language mk =
    Language_Language_mk;
  static constexpr Language ml =
    Language_Language_ml;
  static constexpr Language mn =
    Language_Language_mn;
  static constexpr Language mr =
    Language_Language_mr;
  static constexpr Language ms =
    Language_Language_ms;
  static constexpr Language mt =
    Language_Language_mt;
  static constexpr Language my =
    Language_Language_my;
  static constexpr Language na =
    Language_Language_na;
  static constexpr Language nb =
    Language_Language_nb;
  static constexpr Language nd =
    Language_Language_nd;
  static constexpr Language ne =
    Language_Language_ne;
  static constexpr Language ng =
    Language_Language_ng;
  static constexpr Language nl =
    Language_Language_nl;
  static constexpr Language nn =
    Language_Language_nn;
  static constexpr Language no =
    Language_Language_no;
  static constexpr Language nr =
    Language_Language_nr;
  static constexpr Language nv =
    Language_Language_nv;
  static constexpr Language ny =
    Language_Language_ny;
  static constexpr Language oc =
    Language_Language_oc;
  static constexpr Language oj =
    Language_Language_oj;
  static constexpr Language om =
    Language_Language_om;
  static constexpr Language or_ =
    Language_Language_or_;
  static constexpr Language os =
    Language_Language_os;
  static constexpr Language pa =
    Language_Language_pa;
  static constexpr Language pi =
    Language_Language_pi;
  static constexpr Language pl =
    Language_Language_pl;
  static constexpr Language ps =
    Language_Language_ps;
  static constexpr Language pt =
    Language_Language_pt;
  static constexpr Language qu =
    Language_Language_qu;
  static constexpr Language rm =
    Language_Language_rm;
  static constexpr Language rn =
    Language_Language_rn;
  static constexpr Language ro =
    Language_Language_ro;
  static constexpr Language ru =
    Language_Language_ru;
  static constexpr Language rw =
    Language_Language_rw;
  static constexpr Language sa =
    Language_Language_sa;
  static constexpr Language sc =
    Language_Language_sc;
  static constexpr Language sd =
    Language_Language_sd;
  static constexpr Language se =
    Language_Language_se;
  static constexpr Language sg =
    Language_Language_sg;
  static constexpr Language si =
    Language_Language_si;
  static constexpr Language sk =
    Language_Language_sk;
  static constexpr Language sl =
    Language_Language_sl;
  static constexpr Language sm =
    Language_Language_sm;
  static constexpr Language sn =
    Language_Language_sn;
  static constexpr Language so =
    Language_Language_so;
  static constexpr Language sq =
    Language_Language_sq;
  static constexpr Language sr =
    Language_Language_sr;
  static constexpr Language ss =
    Language_Language_ss;
  static constexpr Language st =
    Language_Language_st;
  static constexpr Language su =
    Language_Language_su;
  static constexpr Language sv =
    Language_Language_sv;
  static constexpr Language sw =
    Language_Language_sw;
  static constexpr Language ta =
    Language_Language_ta;
  static constexpr Language te =
    Language_Language_te;
  static constexpr Language tg =
    Language_Language_tg;
  static constexpr Language th =
    Language_Language_th;
  static constexpr Language ti =
    Language_Language_ti;
  static constexpr Language tk =
    Language_Language_tk;
  static constexpr Language tl =
    Language_Language_tl;
  static constexpr Language tn =
    Language_Language_tn;
  static constexpr Language to =
    Language_Language_to;
  static constexpr Language tr =
    Language_Language_tr;
  static constexpr Language ts =
    Language_Language_ts;
  static constexpr Language tt =
    Language_Language_tt;
  static constexpr Language tw =
    Language_Language_tw;
  static constexpr Language ty =
    Language_Language_ty;
  static constexpr Language ug =
    Language_Language_ug;
  static constexpr Language uk =
    Language_Language_uk;
  static constexpr Language ur =
    Language_Language_ur;
  static constexpr Language uz =
    Language_Language_uz;
  static constexpr Language ve =
    Language_Language_ve;
  static constexpr Language vi =
    Language_Language_vi;
  static constexpr Language vo =
    Language_Language_vo;
  static constexpr Language wa =
    Language_Language_wa;
  static constexpr Language wo =
    Language_Language_wo;
  static constexpr Language xh =
    Language_Language_xh;
  static constexpr Language yi =
    Language_Language_yi;
  static constexpr Language yo =
    Language_Language_yo;
  static constexpr Language za =
    Language_Language_za;
  static constexpr Language zh =
    Language_Language_zh;
  static constexpr Language zu =
    Language_Language_zu;
  static inline bool Language_IsValid(int value) {
    return Language_Language_IsValid(value);
  }
  static constexpr Language Language_MIN =
    Language_Language_Language_MIN;
  static constexpr Language Language_MAX =
    Language_Language_Language_MAX;
  static constexpr int Language_ARRAYSIZE =
    Language_Language_Language_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Language_descriptor() {
    return Language_Language_descriptor();
  }
  template<typename T>
  static inline const std::string& Language_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Language>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Language_Name.");
    return Language_Language_Name(enum_t_value);
  }
  static inline bool Language_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Language* value) {
    return Language_Language_Parse(name, value);
  }

  typedef Language_Script Script;
  static constexpr Script UNKNOWN_SCRIPT =
    Language_Script_UNKNOWN_SCRIPT;
  static constexpr Script Adlm =
    Language_Script_Adlm;
  static constexpr Script Afak =
    Language_Script_Afak;
  static constexpr Script Aghb =
    Language_Script_Aghb;
  static constexpr Script Ahom =
    Language_Script_Ahom;
  static constexpr Script Arab =
    Language_Script_Arab;
  static constexpr Script Aran =
    Language_Script_Aran;
  static constexpr Script Armi =
    Language_Script_Armi;
  static constexpr Script Armn =
    Language_Script_Armn;
  static constexpr Script Avst =
    Language_Script_Avst;
  static constexpr Script Bali =
    Language_Script_Bali;
  static constexpr Script Bamu =
    Language_Script_Bamu;
  static constexpr Script Bass =
    Language_Script_Bass;
  static constexpr Script Batk =
    Language_Script_Batk;
  static constexpr Script Beng =
    Language_Script_Beng;
  static constexpr Script Bhks =
    Language_Script_Bhks;
  static constexpr Script Blis =
    Language_Script_Blis;
  static constexpr Script Bopo =
    Language_Script_Bopo;
  static constexpr Script Brah =
    Language_Script_Brah;
  static constexpr Script Brai =
    Language_Script_Brai;
  static constexpr Script Bugi =
    Language_Script_Bugi;
  static constexpr Script Buhd =
    Language_Script_Buhd;
  static constexpr Script Cakm =
    Language_Script_Cakm;
  static constexpr Script Cans =
    Language_Script_Cans;
  static constexpr Script Cari =
    Language_Script_Cari;
  static constexpr Script Cham =
    Language_Script_Cham;
  static constexpr Script Cher =
    Language_Script_Cher;
  static constexpr Script Cirt =
    Language_Script_Cirt;
  static constexpr Script Copt =
    Language_Script_Copt;
  static constexpr Script Cpmn =
    Language_Script_Cpmn;
  static constexpr Script Cprt =
    Language_Script_Cprt;
  static constexpr Script Cyrl =
    Language_Script_Cyrl;
  static constexpr Script Cyrs =
    Language_Script_Cyrs;
  static constexpr Script Deva =
    Language_Script_Deva;
  static constexpr Script Dogr =
    Language_Script_Dogr;
  static constexpr Script Dsrt =
    Language_Script_Dsrt;
  static constexpr Script Dupl =
    Language_Script_Dupl;
  static constexpr Script Egyd =
    Language_Script_Egyd;
  static constexpr Script Egyh =
    Language_Script_Egyh;
  static constexpr Script Egyp =
    Language_Script_Egyp;
  static constexpr Script Elba =
    Language_Script_Elba;
  static constexpr Script Elym =
    Language_Script_Elym;
  static constexpr Script Ethi =
    Language_Script_Ethi;
  static constexpr Script Geok =
    Language_Script_Geok;
  static constexpr Script Geor =
    Language_Script_Geor;
  static constexpr Script Glag =
    Language_Script_Glag;
  static constexpr Script Gong =
    Language_Script_Gong;
  static constexpr Script Gonm =
    Language_Script_Gonm;
  static constexpr Script Goth =
    Language_Script_Goth;
  static constexpr Script Gran =
    Language_Script_Gran;
  static constexpr Script Grek =
    Language_Script_Grek;
  static constexpr Script Gujr =
    Language_Script_Gujr;
  static constexpr Script Guru =
    Language_Script_Guru;
  static constexpr Script Hanb =
    Language_Script_Hanb;
  static constexpr Script Hang =
    Language_Script_Hang;
  static constexpr Script Hani =
    Language_Script_Hani;
  static constexpr Script Hano =
    Language_Script_Hano;
  static constexpr Script Hans =
    Language_Script_Hans;
  static constexpr Script Hant =
    Language_Script_Hant;
  static constexpr Script Hatr =
    Language_Script_Hatr;
  static constexpr Script Hebr =
    Language_Script_Hebr;
  static constexpr Script Hira =
    Language_Script_Hira;
  static constexpr Script Hluw =
    Language_Script_Hluw;
  static constexpr Script Hmng =
    Language_Script_Hmng;
  static constexpr Script Hmnp =
    Language_Script_Hmnp;
  static constexpr Script Hrkt =
    Language_Script_Hrkt;
  static constexpr Script Hung =
    Language_Script_Hung;
  static constexpr Script Inds =
    Language_Script_Inds;
  static constexpr Script Ital =
    Language_Script_Ital;
  static constexpr Script Jamo =
    Language_Script_Jamo;
  static constexpr Script Java =
    Language_Script_Java;
  static constexpr Script Jpan =
    Language_Script_Jpan;
  static constexpr Script Jurc =
    Language_Script_Jurc;
  static constexpr Script Kali =
    Language_Script_Kali;
  static constexpr Script Kana =
    Language_Script_Kana;
  static constexpr Script Khar =
    Language_Script_Khar;
  static constexpr Script Khmr =
    Language_Script_Khmr;
  static constexpr Script Khoj =
    Language_Script_Khoj;
  static constexpr Script Kitl =
    Language_Script_Kitl;
  static constexpr Script Kits =
    Language_Script_Kits;
  static constexpr Script Knda =
    Language_Script_Knda;
  static constexpr Script Kore =
    Language_Script_Kore;
  static constexpr Script Kpel =
    Language_Script_Kpel;
  static constexpr Script Kthi =
    Language_Script_Kthi;
  static constexpr Script Lana =
    Language_Script_Lana;
  static constexpr Script Laoo =
    Language_Script_Laoo;
  static constexpr Script Latf =
    Language_Script_Latf;
  static constexpr Script Latg =
    Language_Script_Latg;
  static constexpr Script Latn =
    Language_Script_Latn;
  static constexpr Script Leke =
    Language_Script_Leke;
  static constexpr Script Lepc =
    Language_Script_Lepc;
  static constexpr Script Limb =
    Language_Script_Limb;
  static constexpr Script Lina =
    Language_Script_Lina;
  static constexpr Script Linb =
    Language_Script_Linb;
  static constexpr Script Lisu =
    Language_Script_Lisu;
  static constexpr Script Loma =
    Language_Script_Loma;
  static constexpr Script Lyci =
    Language_Script_Lyci;
  static constexpr Script Lydi =
    Language_Script_Lydi;
  static constexpr Script Mahj =
    Language_Script_Mahj;
  static constexpr Script Maka =
    Language_Script_Maka;
  static constexpr Script Mand =
    Language_Script_Mand;
  static constexpr Script Mani =
    Language_Script_Mani;
  static constexpr Script Marc =
    Language_Script_Marc;
  static constexpr Script Maya =
    Language_Script_Maya;
  static constexpr Script Medf =
    Language_Script_Medf;
  static constexpr Script Mend =
    Language_Script_Mend;
  static constexpr Script Merc =
    Language_Script_Merc;
  static constexpr Script Mero =
    Language_Script_Mero;
  static constexpr Script Mlym =
    Language_Script_Mlym;
  static constexpr Script Modi =
    Language_Script_Modi;
  static constexpr Script Mong =
    Language_Script_Mong;
  static constexpr Script Moon =
    Language_Script_Moon;
  static constexpr Script Mroo =
    Language_Script_Mroo;
  static constexpr Script Mtei =
    Language_Script_Mtei;
  static constexpr Script Mult =
    Language_Script_Mult;
  static constexpr Script Mymr =
    Language_Script_Mymr;
  static constexpr Script Nand =
    Language_Script_Nand;
  static constexpr Script Narb =
    Language_Script_Narb;
  static constexpr Script Nbat =
    Language_Script_Nbat;
  static constexpr Script Newa =
    Language_Script_Newa;
  static constexpr Script Nkdb =
    Language_Script_Nkdb;
  static constexpr Script Nkgb =
    Language_Script_Nkgb;
  static constexpr Script Nkoo =
    Language_Script_Nkoo;
  static constexpr Script Nshu =
    Language_Script_Nshu;
  static constexpr Script Ogam =
    Language_Script_Ogam;
  static constexpr Script Olck =
    Language_Script_Olck;
  static constexpr Script Orkh =
    Language_Script_Orkh;
  static constexpr Script Orya =
    Language_Script_Orya;
  static constexpr Script Osge =
    Language_Script_Osge;
  static constexpr Script Osma =
    Language_Script_Osma;
  static constexpr Script Palm =
    Language_Script_Palm;
  static constexpr Script Pauc =
    Language_Script_Pauc;
  static constexpr Script Perm =
    Language_Script_Perm;
  static constexpr Script Phag =
    Language_Script_Phag;
  static constexpr Script Phli =
    Language_Script_Phli;
  static constexpr Script Phlp =
    Language_Script_Phlp;
  static constexpr Script Phlv =
    Language_Script_Phlv;
  static constexpr Script Phnx =
    Language_Script_Phnx;
  static constexpr Script Plrd =
    Language_Script_Plrd;
  static constexpr Script Piqd =
    Language_Script_Piqd;
  static constexpr Script Prti =
    Language_Script_Prti;
  static constexpr Script Qaaa =
    Language_Script_Qaaa;
  static constexpr Script Qabx =
    Language_Script_Qabx;
  static constexpr Script Rjng =
    Language_Script_Rjng;
  static constexpr Script Rohg =
    Language_Script_Rohg;
  static constexpr Script Roro =
    Language_Script_Roro;
  static constexpr Script Runr =
    Language_Script_Runr;
  static constexpr Script Samr =
    Language_Script_Samr;
  static constexpr Script Sara =
    Language_Script_Sara;
  static constexpr Script Sarb =
    Language_Script_Sarb;
  static constexpr Script Saur =
    Language_Script_Saur;
  static constexpr Script Sgnw =
    Language_Script_Sgnw;
  static constexpr Script Shaw =
    Language_Script_Shaw;
  static constexpr Script Shrd =
    Language_Script_Shrd;
  static constexpr Script Shui =
    Language_Script_Shui;
  static constexpr Script Sidd =
    Language_Script_Sidd;
  static constexpr Script Sind =
    Language_Script_Sind;
  static constexpr Script Sinh =
    Language_Script_Sinh;
  static constexpr Script Sogd =
    Language_Script_Sogd;
  static constexpr Script Sogo =
    Language_Script_Sogo;
  static constexpr Script Sora =
    Language_Script_Sora;
  static constexpr Script Soyo =
    Language_Script_Soyo;
  static constexpr Script Sund =
    Language_Script_Sund;
  static constexpr Script Sylo =
    Language_Script_Sylo;
  static constexpr Script Syrc =
    Language_Script_Syrc;
  static constexpr Script Syre =
    Language_Script_Syre;
  static constexpr Script Syrj =
    Language_Script_Syrj;
  static constexpr Script Syrn =
    Language_Script_Syrn;
  static constexpr Script Tagb =
    Language_Script_Tagb;
  static constexpr Script Takr =
    Language_Script_Takr;
  static constexpr Script Tale =
    Language_Script_Tale;
  static constexpr Script Talu =
    Language_Script_Talu;
  static constexpr Script Taml =
    Language_Script_Taml;
  static constexpr Script Tang =
    Language_Script_Tang;
  static constexpr Script Tavt =
    Language_Script_Tavt;
  static constexpr Script Telu =
    Language_Script_Telu;
  static constexpr Script Teng =
    Language_Script_Teng;
  static constexpr Script Tfng =
    Language_Script_Tfng;
  static constexpr Script Tglg =
    Language_Script_Tglg;
  static constexpr Script Thaa =
    Language_Script_Thaa;
  static constexpr Script Thai =
    Language_Script_Thai;
  static constexpr Script Tibt =
    Language_Script_Tibt;
  static constexpr Script Tirh =
    Language_Script_Tirh;
  static constexpr Script Ugar =
    Language_Script_Ugar;
  static constexpr Script Vaii =
    Language_Script_Vaii;
  static constexpr Script Visp =
    Language_Script_Visp;
  static constexpr Script Wara =
    Language_Script_Wara;
  static constexpr Script Wcho =
    Language_Script_Wcho;
  static constexpr Script Wole =
    Language_Script_Wole;
  static constexpr Script Xpeo =
    Language_Script_Xpeo;
  static constexpr Script Xsux =
    Language_Script_Xsux;
  static constexpr Script Yiii =
    Language_Script_Yiii;
  static constexpr Script Zanb =
    Language_Script_Zanb;
  static constexpr Script Zinh =
    Language_Script_Zinh;
  static constexpr Script Zmth =
    Language_Script_Zmth;
  static constexpr Script Zsye =
    Language_Script_Zsye;
  static constexpr Script Zsym =
    Language_Script_Zsym;
  static constexpr Script Zxxx =
    Language_Script_Zxxx;
  static constexpr Script Zyyy =
    Language_Script_Zyyy;
  static constexpr Script Zzzz =
    Language_Script_Zzzz;
  static inline bool Script_IsValid(int value) {
    return Language_Script_IsValid(value);
  }
  static constexpr Script Script_MIN =
    Language_Script_Script_MIN;
  static constexpr Script Script_MAX =
    Language_Script_Script_MAX;
  static constexpr int Script_ARRAYSIZE =
    Language_Script_Script_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Script_descriptor() {
    return Language_Script_descriptor();
  }
  template<typename T>
  static inline const std::string& Script_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Script>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Script_Name.");
    return Language_Script_Name(enum_t_value);
  }
  static inline bool Script_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Script* value) {
    return Language_Script_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kScriptFieldNumber = 2,
    kRegionFieldNumber = 3,
  };
  // .pb.Language.Language language = 1;
  void clear_language();
  ::pb::Language_Language language() const;
  void set_language(::pb::Language_Language value);
  private:
  ::pb::Language_Language _internal_language() const;
  void _internal_set_language(::pb::Language_Language value);
  public:

  // .pb.Language.Script script = 2;
  void clear_script();
  ::pb::Language_Script script() const;
  void set_script(::pb::Language_Script value);
  private:
  ::pb::Language_Script _internal_script() const;
  void _internal_set_script(::pb::Language_Script value);
  public:

  // .pb.Location.Country region = 3;
  void clear_region();
  ::pb::Location_Country region() const;
  void set_region(::pb::Location_Country value);
  private:
  ::pb::Location_Country _internal_region() const;
  void _internal_set_region(::pb::Location_Country value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Language)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int language_;
  int script_;
  int region_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// -------------------------------------------------------------------

class Location PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pb.Location) */ {
 public:
  inline Location() : Location(nullptr) {}
  virtual ~Location();
  explicit constexpr Location(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Location(const Location& from);
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  inline Location& operator=(Location&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Location& default_instance() {
    return *internal_default_instance();
  }
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }
  inline void Swap(Location* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Location* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(nullptr);
  }

  Location* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pb.Location";
  }
  protected:
  explicit Location(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    return ::descriptor_table_claim_2eproto_metadata_getter(kIndexInFileMessages);
  }

  public:

  // nested types ----------------------------------------------------

  typedef Location_Country Country;
  static constexpr Country UNKNOWN_COUNTRY =
    Location_Country_UNKNOWN_COUNTRY;
  static constexpr Country AF =
    Location_Country_AF;
  static constexpr Country AX =
    Location_Country_AX;
  static constexpr Country AL =
    Location_Country_AL;
  static constexpr Country DZ =
    Location_Country_DZ;
  static constexpr Country AS =
    Location_Country_AS;
  static constexpr Country AD =
    Location_Country_AD;
  static constexpr Country AO =
    Location_Country_AO;
  static constexpr Country AI =
    Location_Country_AI;
  static constexpr Country AQ =
    Location_Country_AQ;
  static constexpr Country AG =
    Location_Country_AG;
  static constexpr Country AR =
    Location_Country_AR;
  static constexpr Country AM =
    Location_Country_AM;
  static constexpr Country AW =
    Location_Country_AW;
  static constexpr Country AU =
    Location_Country_AU;
  static constexpr Country AT =
    Location_Country_AT;
  static constexpr Country AZ =
    Location_Country_AZ;
  static constexpr Country BS =
    Location_Country_BS;
  static constexpr Country BH =
    Location_Country_BH;
  static constexpr Country BD =
    Location_Country_BD;
  static constexpr Country BB =
    Location_Country_BB;
  static constexpr Country BY =
    Location_Country_BY;
  static constexpr Country BE =
    Location_Country_BE;
  static constexpr Country BZ =
    Location_Country_BZ;
  static constexpr Country BJ =
    Location_Country_BJ;
  static constexpr Country BM =
    Location_Country_BM;
  static constexpr Country BT =
    Location_Country_BT;
  static constexpr Country BO =
    Location_Country_BO;
  static constexpr Country BQ =
    Location_Country_BQ;
  static constexpr Country BA =
    Location_Country_BA;
  static constexpr Country BW =
    Location_Country_BW;
  static constexpr Country BV =
    Location_Country_BV;
  static constexpr Country BR =
    Location_Country_BR;
  static constexpr Country IO =
    Location_Country_IO;
  static constexpr Country BN =
    Location_Country_BN;
  static constexpr Country BG =
    Location_Country_BG;
  static constexpr Country BF =
    Location_Country_BF;
  static constexpr Country BI =
    Location_Country_BI;
  static constexpr Country KH =
    Location_Country_KH;
  static constexpr Country CM =
    Location_Country_CM;
  static constexpr Country CA =
    Location_Country_CA;
  static constexpr Country CV =
    Location_Country_CV;
  static constexpr Country KY =
    Location_Country_KY;
  static constexpr Country CF =
    Location_Country_CF;
  static constexpr Country TD =
    Location_Country_TD;
  static constexpr Country CL =
    Location_Country_CL;
  static constexpr Country CN =
    Location_Country_CN;
  static constexpr Country CX =
    Location_Country_CX;
  static constexpr Country CC =
    Location_Country_CC;
  static constexpr Country CO =
    Location_Country_CO;
  static constexpr Country KM =
    Location_Country_KM;
  static constexpr Country CG =
    Location_Country_CG;
  static constexpr Country CD =
    Location_Country_CD;
  static constexpr Country CK =
    Location_Country_CK;
  static constexpr Country CR =
    Location_Country_CR;
  static constexpr Country CI =
    Location_Country_CI;
  static constexpr Country HR =
    Location_Country_HR;
  static constexpr Country CU =
    Location_Country_CU;
  static constexpr Country CW =
    Location_Country_CW;
  static constexpr Country CY =
    Location_Country_CY;
  static constexpr Country CZ =
    Location_Country_CZ;
  static constexpr Country DK =
    Location_Country_DK;
  static constexpr Country DJ =
    Location_Country_DJ;
  static constexpr Country DM =
    Location_Country_DM;
  static constexpr Country DO =
    Location_Country_DO;
  static constexpr Country EC =
    Location_Country_EC;
  static constexpr Country EG =
    Location_Country_EG;
  static constexpr Country SV =
    Location_Country_SV;
  static constexpr Country GQ =
    Location_Country_GQ;
  static constexpr Country ER =
    Location_Country_ER;
  static constexpr Country EE =
    Location_Country_EE;
  static constexpr Country ET =
    Location_Country_ET;
  static constexpr Country FK =
    Location_Country_FK;
  static constexpr Country FO =
    Location_Country_FO;
  static constexpr Country FJ =
    Location_Country_FJ;
  static constexpr Country FI =
    Location_Country_FI;
  static constexpr Country FR =
    Location_Country_FR;
  static constexpr Country GF =
    Location_Country_GF;
  static constexpr Country PF =
    Location_Country_PF;
  static constexpr Country TF =
    Location_Country_TF;
  static constexpr Country GA =
    Location_Country_GA;
  static constexpr Country GM =
    Location_Country_GM;
  static constexpr Country GE =
    Location_Country_GE;
  static constexpr Country DE =
    Location_Country_DE;
  static constexpr Country GH =
    Location_Country_GH;
  static constexpr Country GI =
    Location_Country_GI;
  static constexpr Country GR =
    Location_Country_GR;
  static constexpr Country GL =
    Location_Country_GL;
  static constexpr Country GD =
    Location_Country_GD;
  static constexpr Country GP =
    Location_Country_GP;
  static constexpr Country GU =
    Location_Country_GU;
  static constexpr Country GT =
    Location_Country_GT;
  static constexpr Country GG =
    Location_Country_GG;
  static constexpr Country GN =
    Location_Country_GN;
  static constexpr Country GW =
    Location_Country_GW;
  static constexpr Country GY =
    Location_Country_GY;
  static constexpr Country HT =
    Location_Country_HT;
  static constexpr Country HM =
    Location_Country_HM;
  static constexpr Country VA =
    Location_Country_VA;
  static constexpr Country HN =
    Location_Country_HN;
  static constexpr Country HK =
    Location_Country_HK;
  static constexpr Country HU =
    Location_Country_HU;
  static constexpr Country IS =
    Location_Country_IS;
  static constexpr Country IN =
    Location_Country_IN;
  static constexpr Country ID =
    Location_Country_ID;
  static constexpr Country IR =
    Location_Country_IR;
  static constexpr Country IQ =
    Location_Country_IQ;
  static constexpr Country IE =
    Location_Country_IE;
  static constexpr Country IM =
    Location_Country_IM;
  static constexpr Country IL =
    Location_Country_IL;
  static constexpr Country IT =
    Location_Country_IT;
  static constexpr Country JM =
    Location_Country_JM;
  static constexpr Country JP =
    Location_Country_JP;
  static constexpr Country JE =
    Location_Country_JE;
  static constexpr Country JO =
    Location_Country_JO;
  static constexpr Country KZ =
    Location_Country_KZ;
  static constexpr Country KE =
    Location_Country_KE;
  static constexpr Country KI =
    Location_Country_KI;
  static constexpr Country KP =
    Location_Country_KP;
  static constexpr Country KR =
    Location_Country_KR;
  static constexpr Country KW =
    Location_Country_KW;
  static constexpr Country KG =
    Location_Country_KG;
  static constexpr Country LA =
    Location_Country_LA;
  static constexpr Country LV =
    Location_Country_LV;
  static constexpr Country LB =
    Location_Country_LB;
  static constexpr Country LS =
    Location_Country_LS;
  static constexpr Country LR =
    Location_Country_LR;
  static constexpr Country LY =
    Location_Country_LY;
  static constexpr Country LI =
    Location_Country_LI;
  static constexpr Country LT =
    Location_Country_LT;
  static constexpr Country LU =
    Location_Country_LU;
  static constexpr Country MO =
    Location_Country_MO;
  static constexpr Country MK =
    Location_Country_MK;
  static constexpr Country MG =
    Location_Country_MG;
  static constexpr Country MW =
    Location_Country_MW;
  static constexpr Country MY =
    Location_Country_MY;
  static constexpr Country MV =
    Location_Country_MV;
  static constexpr Country ML =
    Location_Country_ML;
  static constexpr Country MT =
    Location_Country_MT;
  static constexpr Country MH =
    Location_Country_MH;
  static constexpr Country MQ =
    Location_Country_MQ;
  static constexpr Country MR =
    Location_Country_MR;
  static constexpr Country MU =
    Location_Country_MU;
  static constexpr Country YT =
    Location_Country_YT;
  static constexpr Country MX =
    Location_Country_MX;
  static constexpr Country FM =
    Location_Country_FM;
  static constexpr Country MD =
    Location_Country_MD;
  static constexpr Country MC =
    Location_Country_MC;
  static constexpr Country MN =
    Location_Country_MN;
  static constexpr Country ME =
    Location_Country_ME;
  static constexpr Country MS =
    Location_Country_MS;
  static constexpr Country MA =
    Location_Country_MA;
  static constexpr Country MZ =
    Location_Country_MZ;
  static constexpr Country MM =
    Location_Country_MM;
  static constexpr Country NA =
    Location_Country_NA;
  static constexpr Country NR =
    Location_Country_NR;
  static constexpr Country NP =
    Location_Country_NP;
  static constexpr Country NL =
    Location_Country_NL;
  static constexpr Country NC =
    Location_Country_NC;
  static constexpr Country NZ =
    Location_Country_NZ;
  static constexpr Country NI =
    Location_Country_NI;
  static constexpr Country NE =
    Location_Country_NE;
  static constexpr Country NG =
    Location_Country_NG;
  static constexpr Country NU =
    Location_Country_NU;
  static constexpr Country NF =
    Location_Country_NF;
  static constexpr Country MP =
    Location_Country_MP;
  static constexpr Country NO =
    Location_Country_NO;
  static constexpr Country OM =
    Location_Country_OM;
  static constexpr Country PK =
    Location_Country_PK;
  static constexpr Country PW =
    Location_Country_PW;
  static constexpr Country PS =
    Location_Country_PS;
  static constexpr Country PA =
    Location_Country_PA;
  static constexpr Country PG =
    Location_Country_PG;
  static constexpr Country PY =
    Location_Country_PY;
  static constexpr Country PE =
    Location_Country_PE;
  static constexpr Country PH =
    Location_Country_PH;
  static constexpr Country PN =
    Location_Country_PN;
  static constexpr Country PL =
    Location_Country_PL;
  static constexpr Country PT =
    Location_Country_PT;
  static constexpr Country PR =
    Location_Country_PR;
  static constexpr Country QA =
    Location_Country_QA;
  static constexpr Country RE =
    Location_Country_RE;
  static constexpr Country RO =
    Location_Country_RO;
  static constexpr Country RU =
    Location_Country_RU;
  static constexpr Country RW =
    Location_Country_RW;
  static constexpr Country BL =
    Location_Country_BL;
  static constexpr Country SH =
    Location_Country_SH;
  static constexpr Country KN =
    Location_Country_KN;
  static constexpr Country LC =
    Location_Country_LC;
  static constexpr Country MF =
    Location_Country_MF;
  static constexpr Country PM =
    Location_Country_PM;
  static constexpr Country VC =
    Location_Country_VC;
  static constexpr Country WS =
    Location_Country_WS;
  static constexpr Country SM =
    Location_Country_SM;
  static constexpr Country ST =
    Location_Country_ST;
  static constexpr Country SA =
    Location_Country_SA;
  static constexpr Country SN =
    Location_Country_SN;
  static constexpr Country RS =
    Location_Country_RS;
  static constexpr Country SC =
    Location_Country_SC;
  static constexpr Country SL =
    Location_Country_SL;
  static constexpr Country SG =
    Location_Country_SG;
  static constexpr Country SX =
    Location_Country_SX;
  static constexpr Country SK =
    Location_Country_SK;
  static constexpr Country SI =
    Location_Country_SI;
  static constexpr Country SB =
    Location_Country_SB;
  static constexpr Country SO =
    Location_Country_SO;
  static constexpr Country ZA =
    Location_Country_ZA;
  static constexpr Country GS =
    Location_Country_GS;
  static constexpr Country SS =
    Location_Country_SS;
  static constexpr Country ES =
    Location_Country_ES;
  static constexpr Country LK =
    Location_Country_LK;
  static constexpr Country SD =
    Location_Country_SD;
  static constexpr Country SR =
    Location_Country_SR;
  static constexpr Country SJ =
    Location_Country_SJ;
  static constexpr Country SZ =
    Location_Country_SZ;
  static constexpr Country SE =
    Location_Country_SE;
  static constexpr Country CH =
    Location_Country_CH;
  static constexpr Country SY =
    Location_Country_SY;
  static constexpr Country TW =
    Location_Country_TW;
  static constexpr Country TJ =
    Location_Country_TJ;
  static constexpr Country TZ =
    Location_Country_TZ;
  static constexpr Country TH =
    Location_Country_TH;
  static constexpr Country TL =
    Location_Country_TL;
  static constexpr Country TG =
    Location_Country_TG;
  static constexpr Country TK =
    Location_Country_TK;
  static constexpr Country TO =
    Location_Country_TO;
  static constexpr Country TT =
    Location_Country_TT;
  static constexpr Country TN =
    Location_Country_TN;
  static constexpr Country TR =
    Location_Country_TR;
  static constexpr Country TM =
    Location_Country_TM;
  static constexpr Country TC =
    Location_Country_TC;
  static constexpr Country TV =
    Location_Country_TV;
  static constexpr Country UG =
    Location_Country_UG;
  static constexpr Country UA =
    Location_Country_UA;
  static constexpr Country AE =
    Location_Country_AE;
  static constexpr Country GB =
    Location_Country_GB;
  static constexpr Country US =
    Location_Country_US;
  static constexpr Country UM =
    Location_Country_UM;
  static constexpr Country UY =
    Location_Country_UY;
  static constexpr Country UZ =
    Location_Country_UZ;
  static constexpr Country VU =
    Location_Country_VU;
  static constexpr Country VE =
    Location_Country_VE;
  static constexpr Country VN =
    Location_Country_VN;
  static constexpr Country VG =
    Location_Country_VG;
  static constexpr Country VI =
    Location_Country_VI;
  static constexpr Country WF =
    Location_Country_WF;
  static constexpr Country EH =
    Location_Country_EH;
  static constexpr Country YE =
    Location_Country_YE;
  static constexpr Country ZM =
    Location_Country_ZM;
  static constexpr Country ZW =
    Location_Country_ZW;
  static constexpr Country R001 =
    Location_Country_R001;
  static constexpr Country R002 =
    Location_Country_R002;
  static constexpr Country R015 =
    Location_Country_R015;
  static constexpr Country R012 =
    Location_Country_R012;
  static constexpr Country R818 =
    Location_Country_R818;
  static constexpr Country R434 =
    Location_Country_R434;
  static constexpr Country R504 =
    Location_Country_R504;
  static constexpr Country R729 =
    Location_Country_R729;
  static constexpr Country R788 =
    Location_Country_R788;
  static constexpr Country R732 =
    Location_Country_R732;
  static constexpr Country R202 =
    Location_Country_R202;
  static constexpr Country R014 =
    Location_Country_R014;
  static constexpr Country R086 =
    Location_Country_R086;
  static constexpr Country R108 =
    Location_Country_R108;
  static constexpr Country R174 =
    Location_Country_R174;
  static constexpr Country R262 =
    Location_Country_R262;
  static constexpr Country R232 =
    Location_Country_R232;
  static constexpr Country R231 =
    Location_Country_R231;
  static constexpr Country R260 =
    Location_Country_R260;
  static constexpr Country R404 =
    Location_Country_R404;
  static constexpr Country R450 =
    Location_Country_R450;
  static constexpr Country R454 =
    Location_Country_R454;
  static constexpr Country R480 =
    Location_Country_R480;
  static constexpr Country R175 =
    Location_Country_R175;
  static constexpr Country R508 =
    Location_Country_R508;
  static constexpr Country R638 =
    Location_Country_R638;
  static constexpr Country R646 =
    Location_Country_R646;
  static constexpr Country R690 =
    Location_Country_R690;
  static constexpr Country R706 =
    Location_Country_R706;
  static constexpr Country R728 =
    Location_Country_R728;
  static constexpr Country R800 =
    Location_Country_R800;
  static constexpr Country R834 =
    Location_Country_R834;
  static constexpr Country R894 =
    Location_Country_R894;
  static constexpr Country R716 =
    Location_Country_R716;
  static constexpr Country R017 =
    Location_Country_R017;
  static constexpr Country R024 =
    Location_Country_R024;
  static constexpr Country R120 =
    Location_Country_R120;
  static constexpr Country R140 =
    Location_Country_R140;
  static constexpr Country R148 =
    Location_Country_R148;
  static constexpr Country R178 =
    Location_Country_R178;
  static constexpr Country R180 =
    Location_Country_R180;
  static constexpr Country R226 =
    Location_Country_R226;
  static constexpr Country R266 =
    Location_Country_R266;
  static constexpr Country R678 =
    Location_Country_R678;
  static constexpr Country R018 =
    Location_Country_R018;
  static constexpr Country R072 =
    Location_Country_R072;
  static constexpr Country R748 =
    Location_Country_R748;
  static constexpr Country R426 =
    Location_Country_R426;
  static constexpr Country R516 =
    Location_Country_R516;
  static constexpr Country R710 =
    Location_Country_R710;
  static constexpr Country R011 =
    Location_Country_R011;
  static constexpr Country R204 =
    Location_Country_R204;
  static constexpr Country R854 =
    Location_Country_R854;
  static constexpr Country R132 =
    Location_Country_R132;
  static constexpr Country R384 =
    Location_Country_R384;
  static constexpr Country R270 =
    Location_Country_R270;
  static constexpr Country R288 =
    Location_Country_R288;
  static constexpr Country R324 =
    Location_Country_R324;
  static constexpr Country R624 =
    Location_Country_R624;
  static constexpr Country R430 =
    Location_Country_R430;
  static constexpr Country R466 =
    Location_Country_R466;
  static constexpr Country R478 =
    Location_Country_R478;
  static constexpr Country R562 =
    Location_Country_R562;
  static constexpr Country R566 =
    Location_Country_R566;
  static constexpr Country R654 =
    Location_Country_R654;
  static constexpr Country R686 =
    Location_Country_R686;
  static constexpr Country R694 =
    Location_Country_R694;
  static constexpr Country R768 =
    Location_Country_R768;
  static constexpr Country R019 =
    Location_Country_R019;
  static constexpr Country R419 =
    Location_Country_R419;
  static constexpr Country R029 =
    Location_Country_R029;
  static constexpr Country R660 =
    Location_Country_R660;
  static constexpr Country R028 =
    Location_Country_R028;
  static constexpr Country R533 =
    Location_Country_R533;
  static constexpr Country R044 =
    Location_Country_R044;
  static constexpr Country R052 =
    Location_Country_R052;
  static constexpr Country R535 =
    Location_Country_R535;
  static constexpr Country R092 =
    Location_Country_R092;
  static constexpr Country R136 =
    Location_Country_R136;
  static constexpr Country R192 =
    Location_Country_R192;
  static constexpr Country R531 =
    Location_Country_R531;
  static constexpr Country R212 =
    Location_Country_R212;
  static constexpr Country R214 =
    Location_Country_R214;
  static constexpr Country R308 =
    Location_Country_R308;
  static constexpr Country R312 =
    Location_Country_R312;
  static constexpr Country R332 =
    Location_Country_R332;
  static constexpr Country R388 =
    Location_Country_R388;
  static constexpr Country R474 =
    Location_Country_R474;
  static constexpr Country R500 =
    Location_Country_R500;
  static constexpr Country R630 =
    Location_Country_R630;
  static constexpr Country R652 =
    Location_Country_R652;
  static constexpr Country R659 =
    Location_Country_R659;
  static constexpr Country R662 =
    Location_Country_R662;
  static constexpr Country R663 =
    Location_Country_R663;
  static constexpr Country R670 =
    Location_Country_R670;
  static constexpr Country R534 =
    Location_Country_R534;
  static constexpr Country R780 =
    Location_Country_R780;
  static constexpr Country R796 =
    Location_Country_R796;
  static constexpr Country R850 =
    Location_Country_R850;
  static constexpr Country R013 =
    Location_Country_R013;
  static constexpr Country R084 =
    Location_Country_R084;
  static constexpr Country R188 =
    Location_Country_R188;
  static constexpr Country R222 =
    Location_Country_R222;
  static constexpr Country R320 =
    Location_Country_R320;
  static constexpr Country R340 =
    Location_Country_R340;
  static constexpr Country R484 =
    Location_Country_R484;
  static constexpr Country R558 =
    Location_Country_R558;
  static constexpr Country R591 =
    Location_Country_R591;
  static constexpr Country R005 =
    Location_Country_R005;
  static constexpr Country R032 =
    Location_Country_R032;
  static constexpr Country R068 =
    Location_Country_R068;
  static constexpr Country R074 =
    Location_Country_R074;
  static constexpr Country R076 =
    Location_Country_R076;
  static constexpr Country R152 =
    Location_Country_R152;
  static constexpr Country R170 =
    Location_Country_R170;
  static constexpr Country R218 =
    Location_Country_R218;
  static constexpr Country R238 =
    Location_Country_R238;
  static constexpr Country R254 =
    Location_Country_R254;
  static constexpr Country R328 =
    Location_Country_R328;
  static constexpr Country R600 =
    Location_Country_R600;
  static constexpr Country R604 =
    Location_Country_R604;
  static constexpr Country R239 =
    Location_Country_R239;
  static constexpr Country R740 =
    Location_Country_R740;
  static constexpr Country R858 =
    Location_Country_R858;
  static constexpr Country R862 =
    Location_Country_R862;
  static constexpr Country R021 =
    Location_Country_R021;
  static constexpr Country R060 =
    Location_Country_R060;
  static constexpr Country R124 =
    Location_Country_R124;
  static constexpr Country R304 =
    Location_Country_R304;
  static constexpr Country R666 =
    Location_Country_R666;
  static constexpr Country R840 =
    Location_Country_R840;
  static constexpr Country R010 =
    Location_Country_R010;
  static constexpr Country R142 =
    Location_Country_R142;
  static constexpr Country R143 =
    Location_Country_R143;
  static constexpr Country R398 =
    Location_Country_R398;
  static constexpr Country R417 =
    Location_Country_R417;
  static constexpr Country R762 =
    Location_Country_R762;
  static constexpr Country R795 =
    Location_Country_R795;
  static constexpr Country R860 =
    Location_Country_R860;
  static constexpr Country R030 =
    Location_Country_R030;
  static constexpr Country R156 =
    Location_Country_R156;
  static constexpr Country R344 =
    Location_Country_R344;
  static constexpr Country R446 =
    Location_Country_R446;
  static constexpr Country R408 =
    Location_Country_R408;
  static constexpr Country R392 =
    Location_Country_R392;
  static constexpr Country R496 =
    Location_Country_R496;
  static constexpr Country R410 =
    Location_Country_R410;
  static constexpr Country R035 =
    Location_Country_R035;
  static constexpr Country R096 =
    Location_Country_R096;
  static constexpr Country R116 =
    Location_Country_R116;
  static constexpr Country R360 =
    Location_Country_R360;
  static constexpr Country R418 =
    Location_Country_R418;
  static constexpr Country R458 =
    Location_Country_R458;
  static constexpr Country R104 =
    Location_Country_R104;
  static constexpr Country R608 =
    Location_Country_R608;
  static constexpr Country R702 =
    Location_Country_R702;
  static constexpr Country R764 =
    Location_Country_R764;
  static constexpr Country R626 =
    Location_Country_R626;
  static constexpr Country R704 =
    Location_Country_R704;
  static constexpr Country R034 =
    Location_Country_R034;
  static constexpr Country R004 =
    Location_Country_R004;
  static constexpr Country R050 =
    Location_Country_R050;
  static constexpr Country R064 =
    Location_Country_R064;
  static constexpr Country R356 =
    Location_Country_R356;
  static constexpr Country R364 =
    Location_Country_R364;
  static constexpr Country R462 =
    Location_Country_R462;
  static constexpr Country R524 =
    Location_Country_R524;
  static constexpr Country R586 =
    Location_Country_R586;
  static constexpr Country R144 =
    Location_Country_R144;
  static constexpr Country R145 =
    Location_Country_R145;
  static constexpr Country R051 =
    Location_Country_R051;
  static constexpr Country R031 =
    Location_Country_R031;
  static constexpr Country R048 =
    Location_Country_R048;
  static constexpr Country R196 =
    Location_Country_R196;
  static constexpr Country R268 =
    Location_Country_R268;
  static constexpr Country R368 =
    Location_Country_R368;
  static constexpr Country R376 =
    Location_Country_R376;
  static constexpr Country R400 =
    Location_Country_R400;
  static constexpr Country R414 =
    Location_Country_R414;
  static constexpr Country R422 =
    Location_Country_R422;
  static constexpr Country R512 =
    Location_Country_R512;
  static constexpr Country R634 =
    Location_Country_R634;
  static constexpr Country R682 =
    Location_Country_R682;
  static constexpr Country R275 =
    Location_Country_R275;
  static constexpr Country R760 =
    Location_Country_R760;
  static constexpr Country R792 =
    Location_Country_R792;
  static constexpr Country R784 =
    Location_Country_R784;
  static constexpr Country R887 =
    Location_Country_R887;
  static constexpr Country R150 =
    Location_Country_R150;
  static constexpr Country R151 =
    Location_Country_R151;
  static constexpr Country R112 =
    Location_Country_R112;
  static constexpr Country R100 =
    Location_Country_R100;
  static constexpr Country R203 =
    Location_Country_R203;
  static constexpr Country R348 =
    Location_Country_R348;
  static constexpr Country R616 =
    Location_Country_R616;
  static constexpr Country R498 =
    Location_Country_R498;
  static constexpr Country R642 =
    Location_Country_R642;
  static constexpr Country R643 =
    Location_Country_R643;
  static constexpr Country R703 =
    Location_Country_R703;
  static constexpr Country R804 =
    Location_Country_R804;
  static constexpr Country R154 =
    Location_Country_R154;
  static constexpr Country R248 =
    Location_Country_R248;
  static constexpr Country R830 =
    Location_Country_R830;
  static constexpr Country R831 =
    Location_Country_R831;
  static constexpr Country R832 =
    Location_Country_R832;
  static constexpr Country R680 =
    Location_Country_R680;
  static constexpr Country R208 =
    Location_Country_R208;
  static constexpr Country R233 =
    Location_Country_R233;
  static constexpr Country R234 =
    Location_Country_R234;
  static constexpr Country R246 =
    Location_Country_R246;
  static constexpr Country R352 =
    Location_Country_R352;
  static constexpr Country R372 =
    Location_Country_R372;
  static constexpr Country R833 =
    Location_Country_R833;
  static constexpr Country R428 =
    Location_Country_R428;
  static constexpr Country R440 =
    Location_Country_R440;
  static constexpr Country R578 =
    Location_Country_R578;
  static constexpr Country R744 =
    Location_Country_R744;
  static constexpr Country R752 =
    Location_Country_R752;
  static constexpr Country R826 =
    Location_Country_R826;
  static constexpr Country R039 =
    Location_Country_R039;
  static constexpr Country R008 =
    Location_Country_R008;
  static constexpr Country R020 =
    Location_Country_R020;
  static constexpr Country R070 =
    Location_Country_R070;
  static constexpr Country R191 =
    Location_Country_R191;
  static constexpr Country R292 =
    Location_Country_R292;
  static constexpr Country R300 =
    Location_Country_R300;
  static constexpr Country R336 =
    Location_Country_R336;
  static constexpr Country R380 =
    Location_Country_R380;
  static constexpr Country R470 =
    Location_Country_R470;
  static constexpr Country R499 =
    Location_Country_R499;
  static constexpr Country R807 =
    Location_Country_R807;
  static constexpr Country R620 =
    Location_Country_R620;
  static constexpr Country R674 =
    Location_Country_R674;
  static constexpr Country R688 =
    Location_Country_R688;
  static constexpr Country R705 =
    Location_Country_R705;
  static constexpr Country R724 =
    Location_Country_R724;
  static constexpr Country R155 =
    Location_Country_R155;
  static constexpr Country R040 =
    Location_Country_R040;
  static constexpr Country R056 =
    Location_Country_R056;
  static constexpr Country R250 =
    Location_Country_R250;
  static constexpr Country R276 =
    Location_Country_R276;
  static constexpr Country R438 =
    Location_Country_R438;
  static constexpr Country R442 =
    Location_Country_R442;
  static constexpr Country R492 =
    Location_Country_R492;
  static constexpr Country R528 =
    Location_Country_R528;
  static constexpr Country R756 =
    Location_Country_R756;
  static constexpr Country R009 =
    Location_Country_R009;
  static constexpr Country R053 =
    Location_Country_R053;
  static constexpr Country R036 =
    Location_Country_R036;
  static constexpr Country R162 =
    Location_Country_R162;
  static constexpr Country R166 =
    Location_Country_R166;
  static constexpr Country R334 =
    Location_Country_R334;
  static constexpr Country R554 =
    Location_Country_R554;
  static constexpr Country R574 =
    Location_Country_R574;
  static constexpr Country R054 =
    Location_Country_R054;
  static constexpr Country R242 =
    Location_Country_R242;
  static constexpr Country R540 =
    Location_Country_R540;
  static constexpr Country R598 =
    Location_Country_R598;
  static constexpr Country R090 =
    Location_Country_R090;
  static constexpr Country R548 =
    Location_Country_R548;
  static constexpr Country R057 =
    Location_Country_R057;
  static constexpr Country R316 =
    Location_Country_R316;
  static constexpr Country R296 =
    Location_Country_R296;
  static constexpr Country R584 =
    Location_Country_R584;
  static constexpr Country R583 =
    Location_Country_R583;
  static constexpr Country R520 =
    Location_Country_R520;
  static constexpr Country R580 =
    Location_Country_R580;
  static constexpr Country R585 =
    Location_Country_R585;
  static constexpr Country R581 =
    Location_Country_R581;
  static constexpr Country R061 =
    Location_Country_R061;
  static constexpr Country R016 =
    Location_Country_R016;
  static constexpr Country R184 =
    Location_Country_R184;
  static constexpr Country R258 =
    Location_Country_R258;
  static constexpr Country R570 =
    Location_Country_R570;
  static constexpr Country R612 =
    Location_Country_R612;
  static constexpr Country R882 =
    Location_Country_R882;
  static constexpr Country R772 =
    Location_Country_R772;
  static constexpr Country R776 =
    Location_Country_R776;
  static constexpr Country R798 =
    Location_Country_R798;
  static constexpr Country R876 =
    Location_Country_R876;
  static inline bool Country_IsValid(int value) {
    return Location_Country_IsValid(value);
  }
  static constexpr Country Country_MIN =
    Location_Country_Country_MIN;
  static constexpr Country Country_MAX =
    Location_Country_Country_MAX;
  static constexpr int Country_ARRAYSIZE =
    Location_Country_Country_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Country_descriptor() {
    return Location_Country_descriptor();
  }
  template<typename T>
  static inline const std::string& Country_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Country>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Country_Name.");
    return Location_Country_Name(enum_t_value);
  }
  static inline bool Country_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Country* value) {
    return Location_Country_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 2,
    kCityFieldNumber = 3,
    kCodeFieldNumber = 4,
    kCountryFieldNumber = 1,
    kLatitudeFieldNumber = 5,
    kLongitudeFieldNumber = 6,
  };
  // string state = 2;
  void clear_state();
  const std::string& state() const;
  void set_state(const std::string& value);
  void set_state(std::string&& value);
  void set_state(const char* value);
  void set_state(const char* value, size_t size);
  std::string* mutable_state();
  std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // string city = 3;
  void clear_city();
  const std::string& city() const;
  void set_city(const std::string& value);
  void set_city(std::string&& value);
  void set_city(const char* value);
  void set_city(const char* value, size_t size);
  std::string* mutable_city();
  std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // string code = 4;
  void clear_code();
  const std::string& code() const;
  void set_code(const std::string& value);
  void set_code(std::string&& value);
  void set_code(const char* value);
  void set_code(const char* value, size_t size);
  std::string* mutable_code();
  std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // .pb.Location.Country country = 1;
  void clear_country();
  ::pb::Location_Country country() const;
  void set_country(::pb::Location_Country value);
  private:
  ::pb::Location_Country _internal_country() const;
  void _internal_set_country(::pb::Location_Country value);
  public:

  // sint32 latitude = 5;
  void clear_latitude();
  ::PROTOBUF_NAMESPACE_ID::int32 latitude() const;
  void set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_latitude() const;
  void _internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // sint32 longitude = 6;
  void clear_longitude();
  ::PROTOBUF_NAMESPACE_ID::int32 longitude() const;
  void set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_longitude() const;
  void _internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:pb.Location)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  int country_;
  ::PROTOBUF_NAMESPACE_ID::int32 latitude_;
  ::PROTOBUF_NAMESPACE_ID::int32 longitude_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_claim_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Claim

// .pb.Stream stream = 1;
inline bool Claim::_internal_has_stream() const {
  return type_case() == kStream;
}
inline bool Claim::has_stream() const {
  return _internal_has_stream();
}
inline void Claim::set_has_stream() {
  _oneof_case_[0] = kStream;
}
inline void Claim::clear_stream() {
  if (_internal_has_stream()) {
    if (GetArena() == nullptr) {
      delete type_.stream_;
    }
    clear_has_type();
  }
}
inline ::pb::Stream* Claim::release_stream() {
  // @@protoc_insertion_point(field_release:pb.Claim.stream)
  if (_internal_has_stream()) {
    clear_has_type();
      ::pb::Stream* temp = type_.stream_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Stream& Claim::_internal_stream() const {
  return _internal_has_stream()
      ? *type_.stream_
      : reinterpret_cast< ::pb::Stream&>(::pb::_Stream_default_instance_);
}
inline const ::pb::Stream& Claim::stream() const {
  // @@protoc_insertion_point(field_get:pb.Claim.stream)
  return _internal_stream();
}
inline ::pb::Stream* Claim::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Claim.stream)
  if (_internal_has_stream()) {
    clear_has_type();
    ::pb::Stream* temp = type_.stream_;
    type_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Claim::unsafe_arena_set_allocated_stream(::pb::Stream* stream) {
  clear_type();
  if (stream) {
    set_has_stream();
    type_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Claim.stream)
}
inline ::pb::Stream* Claim::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_type();
    set_has_stream();
    type_.stream_ = CreateMaybeMessage< ::pb::Stream >(GetArena());
  }
  return type_.stream_;
}
inline ::pb::Stream* Claim::mutable_stream() {
  // @@protoc_insertion_point(field_mutable:pb.Claim.stream)
  return _internal_mutable_stream();
}

// .pb.Channel channel = 2;
inline bool Claim::_internal_has_channel() const {
  return type_case() == kChannel;
}
inline bool Claim::has_channel() const {
  return _internal_has_channel();
}
inline void Claim::set_has_channel() {
  _oneof_case_[0] = kChannel;
}
inline void Claim::clear_channel() {
  if (_internal_has_channel()) {
    if (GetArena() == nullptr) {
      delete type_.channel_;
    }
    clear_has_type();
  }
}
inline ::pb::Channel* Claim::release_channel() {
  // @@protoc_insertion_point(field_release:pb.Claim.channel)
  if (_internal_has_channel()) {
    clear_has_type();
      ::pb::Channel* temp = type_.channel_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Channel& Claim::_internal_channel() const {
  return _internal_has_channel()
      ? *type_.channel_
      : reinterpret_cast< ::pb::Channel&>(::pb::_Channel_default_instance_);
}
inline const ::pb::Channel& Claim::channel() const {
  // @@protoc_insertion_point(field_get:pb.Claim.channel)
  return _internal_channel();
}
inline ::pb::Channel* Claim::unsafe_arena_release_channel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Claim.channel)
  if (_internal_has_channel()) {
    clear_has_type();
    ::pb::Channel* temp = type_.channel_;
    type_.channel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Claim::unsafe_arena_set_allocated_channel(::pb::Channel* channel) {
  clear_type();
  if (channel) {
    set_has_channel();
    type_.channel_ = channel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Claim.channel)
}
inline ::pb::Channel* Claim::_internal_mutable_channel() {
  if (!_internal_has_channel()) {
    clear_type();
    set_has_channel();
    type_.channel_ = CreateMaybeMessage< ::pb::Channel >(GetArena());
  }
  return type_.channel_;
}
inline ::pb::Channel* Claim::mutable_channel() {
  // @@protoc_insertion_point(field_mutable:pb.Claim.channel)
  return _internal_mutable_channel();
}

// .pb.ClaimList collection = 3;
inline bool Claim::_internal_has_collection() const {
  return type_case() == kCollection;
}
inline bool Claim::has_collection() const {
  return _internal_has_collection();
}
inline void Claim::set_has_collection() {
  _oneof_case_[0] = kCollection;
}
inline void Claim::clear_collection() {
  if (_internal_has_collection()) {
    if (GetArena() == nullptr) {
      delete type_.collection_;
    }
    clear_has_type();
  }
}
inline ::pb::ClaimList* Claim::release_collection() {
  // @@protoc_insertion_point(field_release:pb.Claim.collection)
  if (_internal_has_collection()) {
    clear_has_type();
      ::pb::ClaimList* temp = type_.collection_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::ClaimList& Claim::_internal_collection() const {
  return _internal_has_collection()
      ? *type_.collection_
      : reinterpret_cast< ::pb::ClaimList&>(::pb::_ClaimList_default_instance_);
}
inline const ::pb::ClaimList& Claim::collection() const {
  // @@protoc_insertion_point(field_get:pb.Claim.collection)
  return _internal_collection();
}
inline ::pb::ClaimList* Claim::unsafe_arena_release_collection() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Claim.collection)
  if (_internal_has_collection()) {
    clear_has_type();
    ::pb::ClaimList* temp = type_.collection_;
    type_.collection_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Claim::unsafe_arena_set_allocated_collection(::pb::ClaimList* collection) {
  clear_type();
  if (collection) {
    set_has_collection();
    type_.collection_ = collection;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Claim.collection)
}
inline ::pb::ClaimList* Claim::_internal_mutable_collection() {
  if (!_internal_has_collection()) {
    clear_type();
    set_has_collection();
    type_.collection_ = CreateMaybeMessage< ::pb::ClaimList >(GetArena());
  }
  return type_.collection_;
}
inline ::pb::ClaimList* Claim::mutable_collection() {
  // @@protoc_insertion_point(field_mutable:pb.Claim.collection)
  return _internal_mutable_collection();
}

// .pb.ClaimReference repost = 4;
inline bool Claim::_internal_has_repost() const {
  return type_case() == kRepost;
}
inline bool Claim::has_repost() const {
  return _internal_has_repost();
}
inline void Claim::set_has_repost() {
  _oneof_case_[0] = kRepost;
}
inline void Claim::clear_repost() {
  if (_internal_has_repost()) {
    if (GetArena() == nullptr) {
      delete type_.repost_;
    }
    clear_has_type();
  }
}
inline ::pb::ClaimReference* Claim::release_repost() {
  // @@protoc_insertion_point(field_release:pb.Claim.repost)
  if (_internal_has_repost()) {
    clear_has_type();
      ::pb::ClaimReference* temp = type_.repost_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.repost_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::ClaimReference& Claim::_internal_repost() const {
  return _internal_has_repost()
      ? *type_.repost_
      : reinterpret_cast< ::pb::ClaimReference&>(::pb::_ClaimReference_default_instance_);
}
inline const ::pb::ClaimReference& Claim::repost() const {
  // @@protoc_insertion_point(field_get:pb.Claim.repost)
  return _internal_repost();
}
inline ::pb::ClaimReference* Claim::unsafe_arena_release_repost() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Claim.repost)
  if (_internal_has_repost()) {
    clear_has_type();
    ::pb::ClaimReference* temp = type_.repost_;
    type_.repost_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Claim::unsafe_arena_set_allocated_repost(::pb::ClaimReference* repost) {
  clear_type();
  if (repost) {
    set_has_repost();
    type_.repost_ = repost;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Claim.repost)
}
inline ::pb::ClaimReference* Claim::_internal_mutable_repost() {
  if (!_internal_has_repost()) {
    clear_type();
    set_has_repost();
    type_.repost_ = CreateMaybeMessage< ::pb::ClaimReference >(GetArena());
  }
  return type_.repost_;
}
inline ::pb::ClaimReference* Claim::mutable_repost() {
  // @@protoc_insertion_point(field_mutable:pb.Claim.repost)
  return _internal_mutable_repost();
}

// string title = 8;
inline void Claim::clear_title() {
  title_.ClearToEmpty();
}
inline const std::string& Claim::title() const {
  // @@protoc_insertion_point(field_get:pb.Claim.title)
  return _internal_title();
}
inline void Claim::set_title(const std::string& value) {
  _internal_set_title(value);
  // @@protoc_insertion_point(field_set:pb.Claim.title)
}
inline std::string* Claim::mutable_title() {
  // @@protoc_insertion_point(field_mutable:pb.Claim.title)
  return _internal_mutable_title();
}
inline const std::string& Claim::_internal_title() const {
  return title_.Get();
}
inline void Claim::_internal_set_title(const std::string& value) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Claim::set_title(std::string&& value) {
  
  title_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Claim.title)
}
inline void Claim::set_title(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Claim.title)
}
inline void Claim::set_title(const char* value,
    size_t size) {
  
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Claim.title)
}
inline std::string* Claim::_internal_mutable_title() {
  
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Claim::release_title() {
  // @@protoc_insertion_point(field_release:pb.Claim.title)
  return title_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Claim::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    
  } else {
    
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Claim.title)
}

// string description = 9;
inline void Claim::clear_description() {
  description_.ClearToEmpty();
}
inline const std::string& Claim::description() const {
  // @@protoc_insertion_point(field_get:pb.Claim.description)
  return _internal_description();
}
inline void Claim::set_description(const std::string& value) {
  _internal_set_description(value);
  // @@protoc_insertion_point(field_set:pb.Claim.description)
}
inline std::string* Claim::mutable_description() {
  // @@protoc_insertion_point(field_mutable:pb.Claim.description)
  return _internal_mutable_description();
}
inline const std::string& Claim::_internal_description() const {
  return description_.Get();
}
inline void Claim::_internal_set_description(const std::string& value) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Claim::set_description(std::string&& value) {
  
  description_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Claim.description)
}
inline void Claim::set_description(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Claim.description)
}
inline void Claim::set_description(const char* value,
    size_t size) {
  
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Claim.description)
}
inline std::string* Claim::_internal_mutable_description() {
  
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Claim::release_description() {
  // @@protoc_insertion_point(field_release:pb.Claim.description)
  return description_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Claim::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    
  } else {
    
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Claim.description)
}

// .pb.Source thumbnail = 10;
inline bool Claim::_internal_has_thumbnail() const {
  return this != internal_default_instance() && thumbnail_ != nullptr;
}
inline bool Claim::has_thumbnail() const {
  return _internal_has_thumbnail();
}
inline void Claim::clear_thumbnail() {
  if (GetArena() == nullptr && thumbnail_ != nullptr) {
    delete thumbnail_;
  }
  thumbnail_ = nullptr;
}
inline const ::pb::Source& Claim::_internal_thumbnail() const {
  const ::pb::Source* p = thumbnail_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Source&>(
      ::pb::_Source_default_instance_);
}
inline const ::pb::Source& Claim::thumbnail() const {
  // @@protoc_insertion_point(field_get:pb.Claim.thumbnail)
  return _internal_thumbnail();
}
inline void Claim::unsafe_arena_set_allocated_thumbnail(
    ::pb::Source* thumbnail) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(thumbnail_);
  }
  thumbnail_ = thumbnail;
  if (thumbnail) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Claim.thumbnail)
}
inline ::pb::Source* Claim::release_thumbnail() {
  
  ::pb::Source* temp = thumbnail_;
  thumbnail_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::Source* Claim::unsafe_arena_release_thumbnail() {
  // @@protoc_insertion_point(field_release:pb.Claim.thumbnail)
  
  ::pb::Source* temp = thumbnail_;
  thumbnail_ = nullptr;
  return temp;
}
inline ::pb::Source* Claim::_internal_mutable_thumbnail() {
  
  if (thumbnail_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Source>(GetArena());
    thumbnail_ = p;
  }
  return thumbnail_;
}
inline ::pb::Source* Claim::mutable_thumbnail() {
  // @@protoc_insertion_point(field_mutable:pb.Claim.thumbnail)
  return _internal_mutable_thumbnail();
}
inline void Claim::set_allocated_thumbnail(::pb::Source* thumbnail) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete thumbnail_;
  }
  if (thumbnail) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(thumbnail);
    if (message_arena != submessage_arena) {
      thumbnail = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, thumbnail, submessage_arena);
    }
    
  } else {
    
  }
  thumbnail_ = thumbnail;
  // @@protoc_insertion_point(field_set_allocated:pb.Claim.thumbnail)
}

// repeated string tags = 11;
inline int Claim::_internal_tags_size() const {
  return tags_.size();
}
inline int Claim::tags_size() const {
  return _internal_tags_size();
}
inline void Claim::clear_tags() {
  tags_.Clear();
}
inline std::string* Claim::add_tags() {
  // @@protoc_insertion_point(field_add_mutable:pb.Claim.tags)
  return _internal_add_tags();
}
inline const std::string& Claim::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const std::string& Claim::tags(int index) const {
  // @@protoc_insertion_point(field_get:pb.Claim.tags)
  return _internal_tags(index);
}
inline std::string* Claim::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Claim.tags)
  return tags_.Mutable(index);
}
inline void Claim::set_tags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Claim.tags)
  tags_.Mutable(index)->assign(value);
}
inline void Claim::set_tags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.Claim.tags)
  tags_.Mutable(index)->assign(std::move(value));
}
inline void Claim::set_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Claim.tags)
}
inline void Claim::set_tags(int index, const char* value, size_t size) {
  tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Claim.tags)
}
inline std::string* Claim::_internal_add_tags() {
  return tags_.Add();
}
inline void Claim::add_tags(const std::string& value) {
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Claim.tags)
}
inline void Claim::add_tags(std::string&& value) {
  tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.Claim.tags)
}
inline void Claim::add_tags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Claim.tags)
}
inline void Claim::add_tags(const char* value, size_t size) {
  tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Claim.tags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Claim::tags() const {
  // @@protoc_insertion_point(field_list:pb.Claim.tags)
  return tags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Claim::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:pb.Claim.tags)
  return &tags_;
}

// repeated .pb.Language languages = 12;
inline int Claim::_internal_languages_size() const {
  return languages_.size();
}
inline int Claim::languages_size() const {
  return _internal_languages_size();
}
inline void Claim::clear_languages() {
  languages_.Clear();
}
inline ::pb::Language* Claim::mutable_languages(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Claim.languages)
  return languages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Language >*
Claim::mutable_languages() {
  // @@protoc_insertion_point(field_mutable_list:pb.Claim.languages)
  return &languages_;
}
inline const ::pb::Language& Claim::_internal_languages(int index) const {
  return languages_.Get(index);
}
inline const ::pb::Language& Claim::languages(int index) const {
  // @@protoc_insertion_point(field_get:pb.Claim.languages)
  return _internal_languages(index);
}
inline ::pb::Language* Claim::_internal_add_languages() {
  return languages_.Add();
}
inline ::pb::Language* Claim::add_languages() {
  // @@protoc_insertion_point(field_add:pb.Claim.languages)
  return _internal_add_languages();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Language >&
Claim::languages() const {
  // @@protoc_insertion_point(field_list:pb.Claim.languages)
  return languages_;
}

// repeated .pb.Location locations = 13;
inline int Claim::_internal_locations_size() const {
  return locations_.size();
}
inline int Claim::locations_size() const {
  return _internal_locations_size();
}
inline void Claim::clear_locations() {
  locations_.Clear();
}
inline ::pb::Location* Claim::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Claim.locations)
  return locations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Location >*
Claim::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:pb.Claim.locations)
  return &locations_;
}
inline const ::pb::Location& Claim::_internal_locations(int index) const {
  return locations_.Get(index);
}
inline const ::pb::Location& Claim::locations(int index) const {
  // @@protoc_insertion_point(field_get:pb.Claim.locations)
  return _internal_locations(index);
}
inline ::pb::Location* Claim::_internal_add_locations() {
  return locations_.Add();
}
inline ::pb::Location* Claim::add_locations() {
  // @@protoc_insertion_point(field_add:pb.Claim.locations)
  return _internal_add_locations();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::Location >&
Claim::locations() const {
  // @@protoc_insertion_point(field_list:pb.Claim.locations)
  return locations_;
}

inline bool Claim::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Claim::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Claim::TypeCase Claim::type_case() const {
  return Claim::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Stream

// .pb.Source source = 1;
inline bool Stream::_internal_has_source() const {
  return this != internal_default_instance() && source_ != nullptr;
}
inline bool Stream::has_source() const {
  return _internal_has_source();
}
inline void Stream::clear_source() {
  if (GetArena() == nullptr && source_ != nullptr) {
    delete source_;
  }
  source_ = nullptr;
}
inline const ::pb::Source& Stream::_internal_source() const {
  const ::pb::Source* p = source_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Source&>(
      ::pb::_Source_default_instance_);
}
inline const ::pb::Source& Stream::source() const {
  // @@protoc_insertion_point(field_get:pb.Stream.source)
  return _internal_source();
}
inline void Stream::unsafe_arena_set_allocated_source(
    ::pb::Source* source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(source_);
  }
  source_ = source;
  if (source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Stream.source)
}
inline ::pb::Source* Stream::release_source() {
  
  ::pb::Source* temp = source_;
  source_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::Source* Stream::unsafe_arena_release_source() {
  // @@protoc_insertion_point(field_release:pb.Stream.source)
  
  ::pb::Source* temp = source_;
  source_ = nullptr;
  return temp;
}
inline ::pb::Source* Stream::_internal_mutable_source() {
  
  if (source_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Source>(GetArena());
    source_ = p;
  }
  return source_;
}
inline ::pb::Source* Stream::mutable_source() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.source)
  return _internal_mutable_source();
}
inline void Stream::set_allocated_source(::pb::Source* source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete source_;
  }
  if (source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(source);
    if (message_arena != submessage_arena) {
      source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, source, submessage_arena);
    }
    
  } else {
    
  }
  source_ = source;
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.source)
}

// string author = 2;
inline void Stream::clear_author() {
  author_.ClearToEmpty();
}
inline const std::string& Stream::author() const {
  // @@protoc_insertion_point(field_get:pb.Stream.author)
  return _internal_author();
}
inline void Stream::set_author(const std::string& value) {
  _internal_set_author(value);
  // @@protoc_insertion_point(field_set:pb.Stream.author)
}
inline std::string* Stream::mutable_author() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.author)
  return _internal_mutable_author();
}
inline const std::string& Stream::_internal_author() const {
  return author_.Get();
}
inline void Stream::_internal_set_author(const std::string& value) {
  
  author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stream::set_author(std::string&& value) {
  
  author_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.author)
}
inline void Stream::set_author(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Stream.author)
}
inline void Stream::set_author(const char* value,
    size_t size) {
  
  author_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.author)
}
inline std::string* Stream::_internal_mutable_author() {
  
  return author_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stream::release_author() {
  // @@protoc_insertion_point(field_release:pb.Stream.author)
  return author_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stream::set_allocated_author(std::string* author) {
  if (author != nullptr) {
    
  } else {
    
  }
  author_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), author,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.author)
}

// string license = 3;
inline void Stream::clear_license() {
  license_.ClearToEmpty();
}
inline const std::string& Stream::license() const {
  // @@protoc_insertion_point(field_get:pb.Stream.license)
  return _internal_license();
}
inline void Stream::set_license(const std::string& value) {
  _internal_set_license(value);
  // @@protoc_insertion_point(field_set:pb.Stream.license)
}
inline std::string* Stream::mutable_license() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.license)
  return _internal_mutable_license();
}
inline const std::string& Stream::_internal_license() const {
  return license_.Get();
}
inline void Stream::_internal_set_license(const std::string& value) {
  
  license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stream::set_license(std::string&& value) {
  
  license_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.license)
}
inline void Stream::set_license(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Stream.license)
}
inline void Stream::set_license(const char* value,
    size_t size) {
  
  license_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.license)
}
inline std::string* Stream::_internal_mutable_license() {
  
  return license_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stream::release_license() {
  // @@protoc_insertion_point(field_release:pb.Stream.license)
  return license_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stream::set_allocated_license(std::string* license) {
  if (license != nullptr) {
    
  } else {
    
  }
  license_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), license,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.license)
}

// string license_url = 4;
inline void Stream::clear_license_url() {
  license_url_.ClearToEmpty();
}
inline const std::string& Stream::license_url() const {
  // @@protoc_insertion_point(field_get:pb.Stream.license_url)
  return _internal_license_url();
}
inline void Stream::set_license_url(const std::string& value) {
  _internal_set_license_url(value);
  // @@protoc_insertion_point(field_set:pb.Stream.license_url)
}
inline std::string* Stream::mutable_license_url() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.license_url)
  return _internal_mutable_license_url();
}
inline const std::string& Stream::_internal_license_url() const {
  return license_url_.Get();
}
inline void Stream::_internal_set_license_url(const std::string& value) {
  
  license_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Stream::set_license_url(std::string&& value) {
  
  license_url_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Stream.license_url)
}
inline void Stream::set_license_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  license_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Stream.license_url)
}
inline void Stream::set_license_url(const char* value,
    size_t size) {
  
  license_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Stream.license_url)
}
inline std::string* Stream::_internal_mutable_license_url() {
  
  return license_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Stream::release_license_url() {
  // @@protoc_insertion_point(field_release:pb.Stream.license_url)
  return license_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Stream::set_allocated_license_url(std::string* license_url) {
  if (license_url != nullptr) {
    
  } else {
    
  }
  license_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), license_url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.license_url)
}

// int64 release_time = 5;
inline void Stream::clear_release_time() {
  release_time_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Stream::_internal_release_time() const {
  return release_time_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Stream::release_time() const {
  // @@protoc_insertion_point(field_get:pb.Stream.release_time)
  return _internal_release_time();
}
inline void Stream::_internal_set_release_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  release_time_ = value;
}
inline void Stream::set_release_time(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_release_time(value);
  // @@protoc_insertion_point(field_set:pb.Stream.release_time)
}

// .pb.Fee fee = 6;
inline bool Stream::_internal_has_fee() const {
  return this != internal_default_instance() && fee_ != nullptr;
}
inline bool Stream::has_fee() const {
  return _internal_has_fee();
}
inline void Stream::clear_fee() {
  if (GetArena() == nullptr && fee_ != nullptr) {
    delete fee_;
  }
  fee_ = nullptr;
}
inline const ::pb::Fee& Stream::_internal_fee() const {
  const ::pb::Fee* p = fee_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Fee&>(
      ::pb::_Fee_default_instance_);
}
inline const ::pb::Fee& Stream::fee() const {
  // @@protoc_insertion_point(field_get:pb.Stream.fee)
  return _internal_fee();
}
inline void Stream::unsafe_arena_set_allocated_fee(
    ::pb::Fee* fee) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fee_);
  }
  fee_ = fee;
  if (fee) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Stream.fee)
}
inline ::pb::Fee* Stream::release_fee() {
  
  ::pb::Fee* temp = fee_;
  fee_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::Fee* Stream::unsafe_arena_release_fee() {
  // @@protoc_insertion_point(field_release:pb.Stream.fee)
  
  ::pb::Fee* temp = fee_;
  fee_ = nullptr;
  return temp;
}
inline ::pb::Fee* Stream::_internal_mutable_fee() {
  
  if (fee_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Fee>(GetArena());
    fee_ = p;
  }
  return fee_;
}
inline ::pb::Fee* Stream::mutable_fee() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.fee)
  return _internal_mutable_fee();
}
inline void Stream::set_allocated_fee(::pb::Fee* fee) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fee_;
  }
  if (fee) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fee);
    if (message_arena != submessage_arena) {
      fee = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fee, submessage_arena);
    }
    
  } else {
    
  }
  fee_ = fee;
  // @@protoc_insertion_point(field_set_allocated:pb.Stream.fee)
}

// .pb.Image image = 10;
inline bool Stream::_internal_has_image() const {
  return type_case() == kImage;
}
inline bool Stream::has_image() const {
  return _internal_has_image();
}
inline void Stream::set_has_image() {
  _oneof_case_[0] = kImage;
}
inline void Stream::clear_image() {
  if (_internal_has_image()) {
    if (GetArena() == nullptr) {
      delete type_.image_;
    }
    clear_has_type();
  }
}
inline ::pb::Image* Stream::release_image() {
  // @@protoc_insertion_point(field_release:pb.Stream.image)
  if (_internal_has_image()) {
    clear_has_type();
      ::pb::Image* temp = type_.image_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Image& Stream::_internal_image() const {
  return _internal_has_image()
      ? *type_.image_
      : reinterpret_cast< ::pb::Image&>(::pb::_Image_default_instance_);
}
inline const ::pb::Image& Stream::image() const {
  // @@protoc_insertion_point(field_get:pb.Stream.image)
  return _internal_image();
}
inline ::pb::Image* Stream::unsafe_arena_release_image() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Stream.image)
  if (_internal_has_image()) {
    clear_has_type();
    ::pb::Image* temp = type_.image_;
    type_.image_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_image(::pb::Image* image) {
  clear_type();
  if (image) {
    set_has_image();
    type_.image_ = image;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Stream.image)
}
inline ::pb::Image* Stream::_internal_mutable_image() {
  if (!_internal_has_image()) {
    clear_type();
    set_has_image();
    type_.image_ = CreateMaybeMessage< ::pb::Image >(GetArena());
  }
  return type_.image_;
}
inline ::pb::Image* Stream::mutable_image() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.image)
  return _internal_mutable_image();
}

// .pb.Video video = 11;
inline bool Stream::_internal_has_video() const {
  return type_case() == kVideo;
}
inline bool Stream::has_video() const {
  return _internal_has_video();
}
inline void Stream::set_has_video() {
  _oneof_case_[0] = kVideo;
}
inline void Stream::clear_video() {
  if (_internal_has_video()) {
    if (GetArena() == nullptr) {
      delete type_.video_;
    }
    clear_has_type();
  }
}
inline ::pb::Video* Stream::release_video() {
  // @@protoc_insertion_point(field_release:pb.Stream.video)
  if (_internal_has_video()) {
    clear_has_type();
      ::pb::Video* temp = type_.video_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.video_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Video& Stream::_internal_video() const {
  return _internal_has_video()
      ? *type_.video_
      : reinterpret_cast< ::pb::Video&>(::pb::_Video_default_instance_);
}
inline const ::pb::Video& Stream::video() const {
  // @@protoc_insertion_point(field_get:pb.Stream.video)
  return _internal_video();
}
inline ::pb::Video* Stream::unsafe_arena_release_video() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Stream.video)
  if (_internal_has_video()) {
    clear_has_type();
    ::pb::Video* temp = type_.video_;
    type_.video_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_video(::pb::Video* video) {
  clear_type();
  if (video) {
    set_has_video();
    type_.video_ = video;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Stream.video)
}
inline ::pb::Video* Stream::_internal_mutable_video() {
  if (!_internal_has_video()) {
    clear_type();
    set_has_video();
    type_.video_ = CreateMaybeMessage< ::pb::Video >(GetArena());
  }
  return type_.video_;
}
inline ::pb::Video* Stream::mutable_video() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.video)
  return _internal_mutable_video();
}

// .pb.Audio audio = 12;
inline bool Stream::_internal_has_audio() const {
  return type_case() == kAudio;
}
inline bool Stream::has_audio() const {
  return _internal_has_audio();
}
inline void Stream::set_has_audio() {
  _oneof_case_[0] = kAudio;
}
inline void Stream::clear_audio() {
  if (_internal_has_audio()) {
    if (GetArena() == nullptr) {
      delete type_.audio_;
    }
    clear_has_type();
  }
}
inline ::pb::Audio* Stream::release_audio() {
  // @@protoc_insertion_point(field_release:pb.Stream.audio)
  if (_internal_has_audio()) {
    clear_has_type();
      ::pb::Audio* temp = type_.audio_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Audio& Stream::_internal_audio() const {
  return _internal_has_audio()
      ? *type_.audio_
      : reinterpret_cast< ::pb::Audio&>(::pb::_Audio_default_instance_);
}
inline const ::pb::Audio& Stream::audio() const {
  // @@protoc_insertion_point(field_get:pb.Stream.audio)
  return _internal_audio();
}
inline ::pb::Audio* Stream::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Stream.audio)
  if (_internal_has_audio()) {
    clear_has_type();
    ::pb::Audio* temp = type_.audio_;
    type_.audio_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_audio(::pb::Audio* audio) {
  clear_type();
  if (audio) {
    set_has_audio();
    type_.audio_ = audio;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Stream.audio)
}
inline ::pb::Audio* Stream::_internal_mutable_audio() {
  if (!_internal_has_audio()) {
    clear_type();
    set_has_audio();
    type_.audio_ = CreateMaybeMessage< ::pb::Audio >(GetArena());
  }
  return type_.audio_;
}
inline ::pb::Audio* Stream::mutable_audio() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.audio)
  return _internal_mutable_audio();
}

// .pb.Software software = 13;
inline bool Stream::_internal_has_software() const {
  return type_case() == kSoftware;
}
inline bool Stream::has_software() const {
  return _internal_has_software();
}
inline void Stream::set_has_software() {
  _oneof_case_[0] = kSoftware;
}
inline void Stream::clear_software() {
  if (_internal_has_software()) {
    if (GetArena() == nullptr) {
      delete type_.software_;
    }
    clear_has_type();
  }
}
inline ::pb::Software* Stream::release_software() {
  // @@protoc_insertion_point(field_release:pb.Stream.software)
  if (_internal_has_software()) {
    clear_has_type();
      ::pb::Software* temp = type_.software_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.software_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::pb::Software& Stream::_internal_software() const {
  return _internal_has_software()
      ? *type_.software_
      : reinterpret_cast< ::pb::Software&>(::pb::_Software_default_instance_);
}
inline const ::pb::Software& Stream::software() const {
  // @@protoc_insertion_point(field_get:pb.Stream.software)
  return _internal_software();
}
inline ::pb::Software* Stream::unsafe_arena_release_software() {
  // @@protoc_insertion_point(field_unsafe_arena_release:pb.Stream.software)
  if (_internal_has_software()) {
    clear_has_type();
    ::pb::Software* temp = type_.software_;
    type_.software_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Stream::unsafe_arena_set_allocated_software(::pb::Software* software) {
  clear_type();
  if (software) {
    set_has_software();
    type_.software_ = software;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Stream.software)
}
inline ::pb::Software* Stream::_internal_mutable_software() {
  if (!_internal_has_software()) {
    clear_type();
    set_has_software();
    type_.software_ = CreateMaybeMessage< ::pb::Software >(GetArena());
  }
  return type_.software_;
}
inline ::pb::Software* Stream::mutable_software() {
  // @@protoc_insertion_point(field_mutable:pb.Stream.software)
  return _internal_mutable_software();
}

inline bool Stream::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Stream::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Stream::TypeCase Stream::type_case() const {
  return Stream::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Channel

// bytes public_key = 1;
inline void Channel::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& Channel::public_key() const {
  // @@protoc_insertion_point(field_get:pb.Channel.public_key)
  return _internal_public_key();
}
inline void Channel::set_public_key(const std::string& value) {
  _internal_set_public_key(value);
  // @@protoc_insertion_point(field_set:pb.Channel.public_key)
}
inline std::string* Channel::mutable_public_key() {
  // @@protoc_insertion_point(field_mutable:pb.Channel.public_key)
  return _internal_mutable_public_key();
}
inline const std::string& Channel::_internal_public_key() const {
  return public_key_.Get();
}
inline void Channel::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_public_key(std::string&& value) {
  
  public_key_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.public_key)
}
inline void Channel::set_public_key(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Channel.public_key)
}
inline void Channel::set_public_key(const void* value,
    size_t size) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.public_key)
}
inline std::string* Channel::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_public_key() {
  // @@protoc_insertion_point(field_release:pb.Channel.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.public_key)
}

// string email = 2;
inline void Channel::clear_email() {
  email_.ClearToEmpty();
}
inline const std::string& Channel::email() const {
  // @@protoc_insertion_point(field_get:pb.Channel.email)
  return _internal_email();
}
inline void Channel::set_email(const std::string& value) {
  _internal_set_email(value);
  // @@protoc_insertion_point(field_set:pb.Channel.email)
}
inline std::string* Channel::mutable_email() {
  // @@protoc_insertion_point(field_mutable:pb.Channel.email)
  return _internal_mutable_email();
}
inline const std::string& Channel::_internal_email() const {
  return email_.Get();
}
inline void Channel::_internal_set_email(const std::string& value) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_email(std::string&& value) {
  
  email_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.email)
}
inline void Channel::set_email(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Channel.email)
}
inline void Channel::set_email(const char* value,
    size_t size) {
  
  email_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.email)
}
inline std::string* Channel::_internal_mutable_email() {
  
  return email_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_email() {
  // @@protoc_insertion_point(field_release:pb.Channel.email)
  return email_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_email(std::string* email) {
  if (email != nullptr) {
    
  } else {
    
  }
  email_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), email,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.email)
}

// string website_url = 3;
inline void Channel::clear_website_url() {
  website_url_.ClearToEmpty();
}
inline const std::string& Channel::website_url() const {
  // @@protoc_insertion_point(field_get:pb.Channel.website_url)
  return _internal_website_url();
}
inline void Channel::set_website_url(const std::string& value) {
  _internal_set_website_url(value);
  // @@protoc_insertion_point(field_set:pb.Channel.website_url)
}
inline std::string* Channel::mutable_website_url() {
  // @@protoc_insertion_point(field_mutable:pb.Channel.website_url)
  return _internal_mutable_website_url();
}
inline const std::string& Channel::_internal_website_url() const {
  return website_url_.Get();
}
inline void Channel::_internal_set_website_url(const std::string& value) {
  
  website_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Channel::set_website_url(std::string&& value) {
  
  website_url_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Channel.website_url)
}
inline void Channel::set_website_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  website_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Channel.website_url)
}
inline void Channel::set_website_url(const char* value,
    size_t size) {
  
  website_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Channel.website_url)
}
inline std::string* Channel::_internal_mutable_website_url() {
  
  return website_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Channel::release_website_url() {
  // @@protoc_insertion_point(field_release:pb.Channel.website_url)
  return website_url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Channel::set_allocated_website_url(std::string* website_url) {
  if (website_url != nullptr) {
    
  } else {
    
  }
  website_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), website_url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.website_url)
}

// .pb.Source cover = 4;
inline bool Channel::_internal_has_cover() const {
  return this != internal_default_instance() && cover_ != nullptr;
}
inline bool Channel::has_cover() const {
  return _internal_has_cover();
}
inline void Channel::clear_cover() {
  if (GetArena() == nullptr && cover_ != nullptr) {
    delete cover_;
  }
  cover_ = nullptr;
}
inline const ::pb::Source& Channel::_internal_cover() const {
  const ::pb::Source* p = cover_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Source&>(
      ::pb::_Source_default_instance_);
}
inline const ::pb::Source& Channel::cover() const {
  // @@protoc_insertion_point(field_get:pb.Channel.cover)
  return _internal_cover();
}
inline void Channel::unsafe_arena_set_allocated_cover(
    ::pb::Source* cover) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cover_);
  }
  cover_ = cover;
  if (cover) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Channel.cover)
}
inline ::pb::Source* Channel::release_cover() {
  
  ::pb::Source* temp = cover_;
  cover_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::Source* Channel::unsafe_arena_release_cover() {
  // @@protoc_insertion_point(field_release:pb.Channel.cover)
  
  ::pb::Source* temp = cover_;
  cover_ = nullptr;
  return temp;
}
inline ::pb::Source* Channel::_internal_mutable_cover() {
  
  if (cover_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Source>(GetArena());
    cover_ = p;
  }
  return cover_;
}
inline ::pb::Source* Channel::mutable_cover() {
  // @@protoc_insertion_point(field_mutable:pb.Channel.cover)
  return _internal_mutable_cover();
}
inline void Channel::set_allocated_cover(::pb::Source* cover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cover_;
  }
  if (cover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cover);
    if (message_arena != submessage_arena) {
      cover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cover, submessage_arena);
    }
    
  } else {
    
  }
  cover_ = cover;
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.cover)
}

// .pb.ClaimList featured = 5;
inline bool Channel::_internal_has_featured() const {
  return this != internal_default_instance() && featured_ != nullptr;
}
inline bool Channel::has_featured() const {
  return _internal_has_featured();
}
inline void Channel::clear_featured() {
  if (GetArena() == nullptr && featured_ != nullptr) {
    delete featured_;
  }
  featured_ = nullptr;
}
inline const ::pb::ClaimList& Channel::_internal_featured() const {
  const ::pb::ClaimList* p = featured_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::ClaimList&>(
      ::pb::_ClaimList_default_instance_);
}
inline const ::pb::ClaimList& Channel::featured() const {
  // @@protoc_insertion_point(field_get:pb.Channel.featured)
  return _internal_featured();
}
inline void Channel::unsafe_arena_set_allocated_featured(
    ::pb::ClaimList* featured) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(featured_);
  }
  featured_ = featured;
  if (featured) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Channel.featured)
}
inline ::pb::ClaimList* Channel::release_featured() {
  
  ::pb::ClaimList* temp = featured_;
  featured_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::ClaimList* Channel::unsafe_arena_release_featured() {
  // @@protoc_insertion_point(field_release:pb.Channel.featured)
  
  ::pb::ClaimList* temp = featured_;
  featured_ = nullptr;
  return temp;
}
inline ::pb::ClaimList* Channel::_internal_mutable_featured() {
  
  if (featured_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::ClaimList>(GetArena());
    featured_ = p;
  }
  return featured_;
}
inline ::pb::ClaimList* Channel::mutable_featured() {
  // @@protoc_insertion_point(field_mutable:pb.Channel.featured)
  return _internal_mutable_featured();
}
inline void Channel::set_allocated_featured(::pb::ClaimList* featured) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete featured_;
  }
  if (featured) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(featured);
    if (message_arena != submessage_arena) {
      featured = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, featured, submessage_arena);
    }
    
  } else {
    
  }
  featured_ = featured;
  // @@protoc_insertion_point(field_set_allocated:pb.Channel.featured)
}

// -------------------------------------------------------------------

// ClaimReference

// bytes claim_hash = 1;
inline void ClaimReference::clear_claim_hash() {
  claim_hash_.ClearToEmpty();
}
inline const std::string& ClaimReference::claim_hash() const {
  // @@protoc_insertion_point(field_get:pb.ClaimReference.claim_hash)
  return _internal_claim_hash();
}
inline void ClaimReference::set_claim_hash(const std::string& value) {
  _internal_set_claim_hash(value);
  // @@protoc_insertion_point(field_set:pb.ClaimReference.claim_hash)
}
inline std::string* ClaimReference::mutable_claim_hash() {
  // @@protoc_insertion_point(field_mutable:pb.ClaimReference.claim_hash)
  return _internal_mutable_claim_hash();
}
inline const std::string& ClaimReference::_internal_claim_hash() const {
  return claim_hash_.Get();
}
inline void ClaimReference::_internal_set_claim_hash(const std::string& value) {
  
  claim_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void ClaimReference::set_claim_hash(std::string&& value) {
  
  claim_hash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.ClaimReference.claim_hash)
}
inline void ClaimReference::set_claim_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  claim_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.ClaimReference.claim_hash)
}
inline void ClaimReference::set_claim_hash(const void* value,
    size_t size) {
  
  claim_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.ClaimReference.claim_hash)
}
inline std::string* ClaimReference::_internal_mutable_claim_hash() {
  
  return claim_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* ClaimReference::release_claim_hash() {
  // @@protoc_insertion_point(field_release:pb.ClaimReference.claim_hash)
  return claim_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ClaimReference::set_allocated_claim_hash(std::string* claim_hash) {
  if (claim_hash != nullptr) {
    
  } else {
    
  }
  claim_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), claim_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.ClaimReference.claim_hash)
}

// -------------------------------------------------------------------

// ClaimList

// .pb.ClaimList.ListType list_type = 1;
inline void ClaimList::clear_list_type() {
  list_type_ = 0;
}
inline ::pb::ClaimList_ListType ClaimList::_internal_list_type() const {
  return static_cast< ::pb::ClaimList_ListType >(list_type_);
}
inline ::pb::ClaimList_ListType ClaimList::list_type() const {
  // @@protoc_insertion_point(field_get:pb.ClaimList.list_type)
  return _internal_list_type();
}
inline void ClaimList::_internal_set_list_type(::pb::ClaimList_ListType value) {
  
  list_type_ = value;
}
inline void ClaimList::set_list_type(::pb::ClaimList_ListType value) {
  _internal_set_list_type(value);
  // @@protoc_insertion_point(field_set:pb.ClaimList.list_type)
}

// repeated .pb.ClaimReference claim_references = 2;
inline int ClaimList::_internal_claim_references_size() const {
  return claim_references_.size();
}
inline int ClaimList::claim_references_size() const {
  return _internal_claim_references_size();
}
inline void ClaimList::clear_claim_references() {
  claim_references_.Clear();
}
inline ::pb::ClaimReference* ClaimList::mutable_claim_references(int index) {
  // @@protoc_insertion_point(field_mutable:pb.ClaimList.claim_references)
  return claim_references_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ClaimReference >*
ClaimList::mutable_claim_references() {
  // @@protoc_insertion_point(field_mutable_list:pb.ClaimList.claim_references)
  return &claim_references_;
}
inline const ::pb::ClaimReference& ClaimList::_internal_claim_references(int index) const {
  return claim_references_.Get(index);
}
inline const ::pb::ClaimReference& ClaimList::claim_references(int index) const {
  // @@protoc_insertion_point(field_get:pb.ClaimList.claim_references)
  return _internal_claim_references(index);
}
inline ::pb::ClaimReference* ClaimList::_internal_add_claim_references() {
  return claim_references_.Add();
}
inline ::pb::ClaimReference* ClaimList::add_claim_references() {
  // @@protoc_insertion_point(field_add:pb.ClaimList.claim_references)
  return _internal_add_claim_references();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pb::ClaimReference >&
ClaimList::claim_references() const {
  // @@protoc_insertion_point(field_list:pb.ClaimList.claim_references)
  return claim_references_;
}

// -------------------------------------------------------------------

// Source

// bytes hash = 1;
inline void Source::clear_hash() {
  hash_.ClearToEmpty();
}
inline const std::string& Source::hash() const {
  // @@protoc_insertion_point(field_get:pb.Source.hash)
  return _internal_hash();
}
inline void Source::set_hash(const std::string& value) {
  _internal_set_hash(value);
  // @@protoc_insertion_point(field_set:pb.Source.hash)
}
inline std::string* Source::mutable_hash() {
  // @@protoc_insertion_point(field_mutable:pb.Source.hash)
  return _internal_mutable_hash();
}
inline const std::string& Source::_internal_hash() const {
  return hash_.Get();
}
inline void Source::_internal_set_hash(const std::string& value) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Source::set_hash(std::string&& value) {
  
  hash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.hash)
}
inline void Source::set_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Source.hash)
}
inline void Source::set_hash(const void* value,
    size_t size) {
  
  hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Source.hash)
}
inline std::string* Source::_internal_mutable_hash() {
  
  return hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Source::release_hash() {
  // @@protoc_insertion_point(field_release:pb.Source.hash)
  return hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Source::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Source.hash)
}

// string name = 2;
inline void Source::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& Source::name() const {
  // @@protoc_insertion_point(field_get:pb.Source.name)
  return _internal_name();
}
inline void Source::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:pb.Source.name)
}
inline std::string* Source::mutable_name() {
  // @@protoc_insertion_point(field_mutable:pb.Source.name)
  return _internal_mutable_name();
}
inline const std::string& Source::_internal_name() const {
  return name_.Get();
}
inline void Source::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Source::set_name(std::string&& value) {
  
  name_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.name)
}
inline void Source::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Source.name)
}
inline void Source::set_name(const char* value,
    size_t size) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Source.name)
}
inline std::string* Source::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Source::release_name() {
  // @@protoc_insertion_point(field_release:pb.Source.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Source::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Source.name)
}

// uint64 size = 3;
inline void Source::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Source::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Source::size() const {
  // @@protoc_insertion_point(field_get:pb.Source.size)
  return _internal_size();
}
inline void Source::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
}
inline void Source::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:pb.Source.size)
}

// string media_type = 4;
inline void Source::clear_media_type() {
  media_type_.ClearToEmpty();
}
inline const std::string& Source::media_type() const {
  // @@protoc_insertion_point(field_get:pb.Source.media_type)
  return _internal_media_type();
}
inline void Source::set_media_type(const std::string& value) {
  _internal_set_media_type(value);
  // @@protoc_insertion_point(field_set:pb.Source.media_type)
}
inline std::string* Source::mutable_media_type() {
  // @@protoc_insertion_point(field_mutable:pb.Source.media_type)
  return _internal_mutable_media_type();
}
inline const std::string& Source::_internal_media_type() const {
  return media_type_.Get();
}
inline void Source::_internal_set_media_type(const std::string& value) {
  
  media_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Source::set_media_type(std::string&& value) {
  
  media_type_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.media_type)
}
inline void Source::set_media_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  media_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Source.media_type)
}
inline void Source::set_media_type(const char* value,
    size_t size) {
  
  media_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Source.media_type)
}
inline std::string* Source::_internal_mutable_media_type() {
  
  return media_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Source::release_media_type() {
  // @@protoc_insertion_point(field_release:pb.Source.media_type)
  return media_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Source::set_allocated_media_type(std::string* media_type) {
  if (media_type != nullptr) {
    
  } else {
    
  }
  media_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), media_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Source.media_type)
}

// string url = 5;
inline void Source::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& Source::url() const {
  // @@protoc_insertion_point(field_get:pb.Source.url)
  return _internal_url();
}
inline void Source::set_url(const std::string& value) {
  _internal_set_url(value);
  // @@protoc_insertion_point(field_set:pb.Source.url)
}
inline std::string* Source::mutable_url() {
  // @@protoc_insertion_point(field_mutable:pb.Source.url)
  return _internal_mutable_url();
}
inline const std::string& Source::_internal_url() const {
  return url_.Get();
}
inline void Source::_internal_set_url(const std::string& value) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Source::set_url(std::string&& value) {
  
  url_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.url)
}
inline void Source::set_url(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Source.url)
}
inline void Source::set_url(const char* value,
    size_t size) {
  
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Source.url)
}
inline std::string* Source::_internal_mutable_url() {
  
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Source::release_url() {
  // @@protoc_insertion_point(field_release:pb.Source.url)
  return url_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Source::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Source.url)
}

// bytes sd_hash = 6;
inline void Source::clear_sd_hash() {
  sd_hash_.ClearToEmpty();
}
inline const std::string& Source::sd_hash() const {
  // @@protoc_insertion_point(field_get:pb.Source.sd_hash)
  return _internal_sd_hash();
}
inline void Source::set_sd_hash(const std::string& value) {
  _internal_set_sd_hash(value);
  // @@protoc_insertion_point(field_set:pb.Source.sd_hash)
}
inline std::string* Source::mutable_sd_hash() {
  // @@protoc_insertion_point(field_mutable:pb.Source.sd_hash)
  return _internal_mutable_sd_hash();
}
inline const std::string& Source::_internal_sd_hash() const {
  return sd_hash_.Get();
}
inline void Source::_internal_set_sd_hash(const std::string& value) {
  
  sd_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Source::set_sd_hash(std::string&& value) {
  
  sd_hash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.sd_hash)
}
inline void Source::set_sd_hash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  sd_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Source.sd_hash)
}
inline void Source::set_sd_hash(const void* value,
    size_t size) {
  
  sd_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Source.sd_hash)
}
inline std::string* Source::_internal_mutable_sd_hash() {
  
  return sd_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Source::release_sd_hash() {
  // @@protoc_insertion_point(field_release:pb.Source.sd_hash)
  return sd_hash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Source::set_allocated_sd_hash(std::string* sd_hash) {
  if (sd_hash != nullptr) {
    
  } else {
    
  }
  sd_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sd_hash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Source.sd_hash)
}

// bytes bt_infohash = 7;
inline void Source::clear_bt_infohash() {
  bt_infohash_.ClearToEmpty();
}
inline const std::string& Source::bt_infohash() const {
  // @@protoc_insertion_point(field_get:pb.Source.bt_infohash)
  return _internal_bt_infohash();
}
inline void Source::set_bt_infohash(const std::string& value) {
  _internal_set_bt_infohash(value);
  // @@protoc_insertion_point(field_set:pb.Source.bt_infohash)
}
inline std::string* Source::mutable_bt_infohash() {
  // @@protoc_insertion_point(field_mutable:pb.Source.bt_infohash)
  return _internal_mutable_bt_infohash();
}
inline const std::string& Source::_internal_bt_infohash() const {
  return bt_infohash_.Get();
}
inline void Source::_internal_set_bt_infohash(const std::string& value) {
  
  bt_infohash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Source::set_bt_infohash(std::string&& value) {
  
  bt_infohash_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Source.bt_infohash)
}
inline void Source::set_bt_infohash(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  bt_infohash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Source.bt_infohash)
}
inline void Source::set_bt_infohash(const void* value,
    size_t size) {
  
  bt_infohash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Source.bt_infohash)
}
inline std::string* Source::_internal_mutable_bt_infohash() {
  
  return bt_infohash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Source::release_bt_infohash() {
  // @@protoc_insertion_point(field_release:pb.Source.bt_infohash)
  return bt_infohash_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Source::set_allocated_bt_infohash(std::string* bt_infohash) {
  if (bt_infohash != nullptr) {
    
  } else {
    
  }
  bt_infohash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), bt_infohash,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Source.bt_infohash)
}

// -------------------------------------------------------------------

// Fee

// .pb.Fee.Currency currency = 1;
inline void Fee::clear_currency() {
  currency_ = 0;
}
inline ::pb::Fee_Currency Fee::_internal_currency() const {
  return static_cast< ::pb::Fee_Currency >(currency_);
}
inline ::pb::Fee_Currency Fee::currency() const {
  // @@protoc_insertion_point(field_get:pb.Fee.currency)
  return _internal_currency();
}
inline void Fee::_internal_set_currency(::pb::Fee_Currency value) {
  
  currency_ = value;
}
inline void Fee::set_currency(::pb::Fee_Currency value) {
  _internal_set_currency(value);
  // @@protoc_insertion_point(field_set:pb.Fee.currency)
}

// bytes address = 2;
inline void Fee::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& Fee::address() const {
  // @@protoc_insertion_point(field_get:pb.Fee.address)
  return _internal_address();
}
inline void Fee::set_address(const std::string& value) {
  _internal_set_address(value);
  // @@protoc_insertion_point(field_set:pb.Fee.address)
}
inline std::string* Fee::mutable_address() {
  // @@protoc_insertion_point(field_mutable:pb.Fee.address)
  return _internal_mutable_address();
}
inline const std::string& Fee::_internal_address() const {
  return address_.Get();
}
inline void Fee::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Fee::set_address(std::string&& value) {
  
  address_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Fee.address)
}
inline void Fee::set_address(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Fee.address)
}
inline void Fee::set_address(const void* value,
    size_t size) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Fee.address)
}
inline std::string* Fee::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Fee::release_address() {
  // @@protoc_insertion_point(field_release:pb.Fee.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Fee::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Fee.address)
}

// uint64 amount = 3;
inline void Fee::clear_amount() {
  amount_ = PROTOBUF_ULONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fee::_internal_amount() const {
  return amount_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Fee::amount() const {
  // @@protoc_insertion_point(field_get:pb.Fee.amount)
  return _internal_amount();
}
inline void Fee::_internal_set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  amount_ = value;
}
inline void Fee::set_amount(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:pb.Fee.amount)
}

// -------------------------------------------------------------------

// Image

// uint32 width = 1;
inline void Image::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:pb.Image.width)
  return _internal_width();
}
inline void Image::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void Image::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:pb.Image.width)
}

// uint32 height = 2;
inline void Image::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:pb.Image.height)
  return _internal_height();
}
inline void Image::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void Image::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:pb.Image.height)
}

// -------------------------------------------------------------------

// Video

// uint32 width = 1;
inline void Video::clear_width() {
  width_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::_internal_width() const {
  return width_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::width() const {
  // @@protoc_insertion_point(field_get:pb.Video.width)
  return _internal_width();
}
inline void Video::_internal_set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  width_ = value;
}
inline void Video::set_width(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:pb.Video.width)
}

// uint32 height = 2;
inline void Video::clear_height() {
  height_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::height() const {
  // @@protoc_insertion_point(field_get:pb.Video.height)
  return _internal_height();
}
inline void Video::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  height_ = value;
}
inline void Video::set_height(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:pb.Video.height)
}

// uint32 duration = 3;
inline void Video::clear_duration() {
  duration_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Video::duration() const {
  // @@protoc_insertion_point(field_get:pb.Video.duration)
  return _internal_duration();
}
inline void Video::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  duration_ = value;
}
inline void Video::set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:pb.Video.duration)
}

// .pb.Audio audio = 15;
inline bool Video::_internal_has_audio() const {
  return this != internal_default_instance() && audio_ != nullptr;
}
inline bool Video::has_audio() const {
  return _internal_has_audio();
}
inline void Video::clear_audio() {
  if (GetArena() == nullptr && audio_ != nullptr) {
    delete audio_;
  }
  audio_ = nullptr;
}
inline const ::pb::Audio& Video::_internal_audio() const {
  const ::pb::Audio* p = audio_;
  return p != nullptr ? *p : reinterpret_cast<const ::pb::Audio&>(
      ::pb::_Audio_default_instance_);
}
inline const ::pb::Audio& Video::audio() const {
  // @@protoc_insertion_point(field_get:pb.Video.audio)
  return _internal_audio();
}
inline void Video::unsafe_arena_set_allocated_audio(
    ::pb::Audio* audio) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(audio_);
  }
  audio_ = audio;
  if (audio) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pb.Video.audio)
}
inline ::pb::Audio* Video::release_audio() {
  
  ::pb::Audio* temp = audio_;
  audio_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::pb::Audio* Video::unsafe_arena_release_audio() {
  // @@protoc_insertion_point(field_release:pb.Video.audio)
  
  ::pb::Audio* temp = audio_;
  audio_ = nullptr;
  return temp;
}
inline ::pb::Audio* Video::_internal_mutable_audio() {
  
  if (audio_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Audio>(GetArena());
    audio_ = p;
  }
  return audio_;
}
inline ::pb::Audio* Video::mutable_audio() {
  // @@protoc_insertion_point(field_mutable:pb.Video.audio)
  return _internal_mutable_audio();
}
inline void Video::set_allocated_audio(::pb::Audio* audio) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete audio_;
  }
  if (audio) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(audio);
    if (message_arena != submessage_arena) {
      audio = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, audio, submessage_arena);
    }
    
  } else {
    
  }
  audio_ = audio;
  // @@protoc_insertion_point(field_set_allocated:pb.Video.audio)
}

// -------------------------------------------------------------------

// Audio

// uint32 duration = 1;
inline void Audio::clear_duration() {
  duration_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Audio::_internal_duration() const {
  return duration_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Audio::duration() const {
  // @@protoc_insertion_point(field_get:pb.Audio.duration)
  return _internal_duration();
}
inline void Audio::_internal_set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  duration_ = value;
}
inline void Audio::set_duration(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:pb.Audio.duration)
}

// -------------------------------------------------------------------

// Software

// string os = 1;
inline void Software::clear_os() {
  os_.ClearToEmpty();
}
inline const std::string& Software::os() const {
  // @@protoc_insertion_point(field_get:pb.Software.os)
  return _internal_os();
}
inline void Software::set_os(const std::string& value) {
  _internal_set_os(value);
  // @@protoc_insertion_point(field_set:pb.Software.os)
}
inline std::string* Software::mutable_os() {
  // @@protoc_insertion_point(field_mutable:pb.Software.os)
  return _internal_mutable_os();
}
inline const std::string& Software::_internal_os() const {
  return os_.Get();
}
inline void Software::_internal_set_os(const std::string& value) {
  
  os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Software::set_os(std::string&& value) {
  
  os_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Software.os)
}
inline void Software::set_os(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Software.os)
}
inline void Software::set_os(const char* value,
    size_t size) {
  
  os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Software.os)
}
inline std::string* Software::_internal_mutable_os() {
  
  return os_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Software::release_os() {
  // @@protoc_insertion_point(field_release:pb.Software.os)
  return os_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Software::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    
  } else {
    
  }
  os_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Software.os)
}

// -------------------------------------------------------------------

// Language

// .pb.Language.Language language = 1;
inline void Language::clear_language() {
  language_ = 0;
}
inline ::pb::Language_Language Language::_internal_language() const {
  return static_cast< ::pb::Language_Language >(language_);
}
inline ::pb::Language_Language Language::language() const {
  // @@protoc_insertion_point(field_get:pb.Language.language)
  return _internal_language();
}
inline void Language::_internal_set_language(::pb::Language_Language value) {
  
  language_ = value;
}
inline void Language::set_language(::pb::Language_Language value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:pb.Language.language)
}

// .pb.Language.Script script = 2;
inline void Language::clear_script() {
  script_ = 0;
}
inline ::pb::Language_Script Language::_internal_script() const {
  return static_cast< ::pb::Language_Script >(script_);
}
inline ::pb::Language_Script Language::script() const {
  // @@protoc_insertion_point(field_get:pb.Language.script)
  return _internal_script();
}
inline void Language::_internal_set_script(::pb::Language_Script value) {
  
  script_ = value;
}
inline void Language::set_script(::pb::Language_Script value) {
  _internal_set_script(value);
  // @@protoc_insertion_point(field_set:pb.Language.script)
}

// .pb.Location.Country region = 3;
inline void Language::clear_region() {
  region_ = 0;
}
inline ::pb::Location_Country Language::_internal_region() const {
  return static_cast< ::pb::Location_Country >(region_);
}
inline ::pb::Location_Country Language::region() const {
  // @@protoc_insertion_point(field_get:pb.Language.region)
  return _internal_region();
}
inline void Language::_internal_set_region(::pb::Location_Country value) {
  
  region_ = value;
}
inline void Language::set_region(::pb::Location_Country value) {
  _internal_set_region(value);
  // @@protoc_insertion_point(field_set:pb.Language.region)
}

// -------------------------------------------------------------------

// Location

// .pb.Location.Country country = 1;
inline void Location::clear_country() {
  country_ = 0;
}
inline ::pb::Location_Country Location::_internal_country() const {
  return static_cast< ::pb::Location_Country >(country_);
}
inline ::pb::Location_Country Location::country() const {
  // @@protoc_insertion_point(field_get:pb.Location.country)
  return _internal_country();
}
inline void Location::_internal_set_country(::pb::Location_Country value) {
  
  country_ = value;
}
inline void Location::set_country(::pb::Location_Country value) {
  _internal_set_country(value);
  // @@protoc_insertion_point(field_set:pb.Location.country)
}

// string state = 2;
inline void Location::clear_state() {
  state_.ClearToEmpty();
}
inline const std::string& Location::state() const {
  // @@protoc_insertion_point(field_get:pb.Location.state)
  return _internal_state();
}
inline void Location::set_state(const std::string& value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:pb.Location.state)
}
inline std::string* Location::mutable_state() {
  // @@protoc_insertion_point(field_mutable:pb.Location.state)
  return _internal_mutable_state();
}
inline const std::string& Location::_internal_state() const {
  return state_.Get();
}
inline void Location::_internal_set_state(const std::string& value) {
  
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Location::set_state(std::string&& value) {
  
  state_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.state)
}
inline void Location::set_state(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Location.state)
}
inline void Location::set_state(const char* value,
    size_t size) {
  
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Location.state)
}
inline std::string* Location::_internal_mutable_state() {
  
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Location::release_state() {
  // @@protoc_insertion_point(field_release:pb.Location.state)
  return state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Location::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    
  } else {
    
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Location.state)
}

// string city = 3;
inline void Location::clear_city() {
  city_.ClearToEmpty();
}
inline const std::string& Location::city() const {
  // @@protoc_insertion_point(field_get:pb.Location.city)
  return _internal_city();
}
inline void Location::set_city(const std::string& value) {
  _internal_set_city(value);
  // @@protoc_insertion_point(field_set:pb.Location.city)
}
inline std::string* Location::mutable_city() {
  // @@protoc_insertion_point(field_mutable:pb.Location.city)
  return _internal_mutable_city();
}
inline const std::string& Location::_internal_city() const {
  return city_.Get();
}
inline void Location::_internal_set_city(const std::string& value) {
  
  city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Location::set_city(std::string&& value) {
  
  city_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.city)
}
inline void Location::set_city(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Location.city)
}
inline void Location::set_city(const char* value,
    size_t size) {
  
  city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Location.city)
}
inline std::string* Location::_internal_mutable_city() {
  
  return city_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Location::release_city() {
  // @@protoc_insertion_point(field_release:pb.Location.city)
  return city_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Location::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    
  } else {
    
  }
  city_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), city,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Location.city)
}

// string code = 4;
inline void Location::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& Location::code() const {
  // @@protoc_insertion_point(field_get:pb.Location.code)
  return _internal_code();
}
inline void Location::set_code(const std::string& value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:pb.Location.code)
}
inline std::string* Location::mutable_code() {
  // @@protoc_insertion_point(field_mutable:pb.Location.code)
  return _internal_mutable_code();
}
inline const std::string& Location::_internal_code() const {
  return code_.Get();
}
inline void Location::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Location::set_code(std::string&& value) {
  
  code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:pb.Location.code)
}
inline void Location::set_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:pb.Location.code)
}
inline void Location::set_code(const char* value,
    size_t size) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:pb.Location.code)
}
inline std::string* Location::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Location::release_code() {
  // @@protoc_insertion_point(field_release:pb.Location.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Location::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:pb.Location.code)
}

// sint32 latitude = 5;
inline void Location::clear_latitude() {
  latitude_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Location::_internal_latitude() const {
  return latitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Location::latitude() const {
  // @@protoc_insertion_point(field_get:pb.Location.latitude)
  return _internal_latitude();
}
inline void Location::_internal_set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  latitude_ = value;
}
inline void Location::set_latitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_latitude(value);
  // @@protoc_insertion_point(field_set:pb.Location.latitude)
}

// sint32 longitude = 6;
inline void Location::clear_longitude() {
  longitude_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Location::_internal_longitude() const {
  return longitude_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Location::longitude() const {
  // @@protoc_insertion_point(field_get:pb.Location.longitude)
  return _internal_longitude();
}
inline void Location::_internal_set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  longitude_ = value;
}
inline void Location::set_longitude(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_longitude(value);
  // @@protoc_insertion_point(field_set:pb.Location.longitude)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pb::ClaimList_ListType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::ClaimList_ListType>() {
  return ::pb::ClaimList_ListType_descriptor();
}
template <> struct is_proto_enum< ::pb::Fee_Currency> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Fee_Currency>() {
  return ::pb::Fee_Currency_descriptor();
}
template <> struct is_proto_enum< ::pb::Software_OS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Software_OS>() {
  return ::pb::Software_OS_descriptor();
}
template <> struct is_proto_enum< ::pb::Language_Language> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Language_Language>() {
  return ::pb::Language_Language_descriptor();
}
template <> struct is_proto_enum< ::pb::Language_Script> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Language_Script>() {
  return ::pb::Language_Script_descriptor();
}
template <> struct is_proto_enum< ::pb::Location_Country> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::Location_Country>() {
  return ::pb::Location_Country_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_claim_2eproto
